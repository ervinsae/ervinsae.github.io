<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[怎么用Kotlin去提高生产力：Kotlin Tips]]></title>
    <url>%2F2018%2F11%2F23%2FKotlin-Tips%2F</url>
    <content type="text"><![CDATA[目录 Tip1-更简洁的字符串 1、三个引号 2、字符串模版 Tip2-Kotlin中大多数控制结构都是表达式 1、语句和表达式 2、if 3、when Tip3-更好调用的函数：显式参数名及默认参数值 1、显式参数名 2、默认参数值 3、@JvmOverloads Tip4-扩展函数和属性 1、扩展函数 2、扩展属性 Tip5-懒初始化bylazy和延迟初始化lateinit 1、by lazy 2、lateinit Tip6-不用再手写findViewById 1、Activity 2、子View或者include标签 3、Fragment Tip7-利用局部函数抽取重复代码 1、局部函数 2、扩展函数 Tip8-使用数据类来快速实现model类 Tip9-用类委托来快速实现装饰器模式 Tip10-Lambda表达式简化OnClickListener Tip11-with函数来简化代码 Tip12-apply函数来简化代码 Tip13-在编译阶段避免掉NullPointerException 1、可空和不可空类型 2、let 3、Elvis操作符 Tip14-运算符重载 Tip15-高阶函数简化代码 Tip16-用Lambda来简化策略模式 Tip1-更简洁的字符串回到目录 三个引号详见案例代码KotlinTip1 Kotlin中的字符串基本Java中的类似，有一点区别是加入了三个引号”””来方便长篇字符的编写。而在Java中，这些都需要转义，先看看java中的式例12345678910111213public void testString1() &#123; String str1 = "abc"; String str2 = "line1\n" + "line2\n" + "line3"; String js = "function myFunction()\n" + "&#123;\n" + " document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";\n" + "&#125;"; System.out.println(str1); System.out.println(str2); System.out.println(js);&#125; kotlin除了有单个双引号的字符串，还对字符串的加强，引入了三个引号，”””中可以包含换行、反斜杠等等特殊字符：12345678910111213141516171819/** kotlin对字符串的加强，三个引号"""中可以包含换行、反斜杠等等特殊字符* */fun testString() &#123; val str1 = "abc" val str2 = """line1\n line2 line3 """ val js = """ function myFunction() &#123; document.getElementById("demo").innerHTML="My First JavaScript Function"; &#125; """.trimIndent() println(str1) println(str2) println(js)&#125; 字符串模版同时，Kotlin中引入了字符串模版，方便字符串的拼接，可以用$符号拼接变量和表达式123456789/** kotlin字符串模版，可以用$符号拼接变量和表达式* */fun testString2() &#123; val strings = arrayListOf("abc", "efd", "gfg") println("First content is $strings") println("First content is $&#123;strings[0]&#125;") println("First content is $&#123;if (strings.size &gt; 0) strings[0] else "null"&#125;")&#125; 值得注意的是，在Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是${‘$’}1234567/** Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是$&#123;'$'&#125;* */fun testString3() &#123; println("First content is \$strings") println("First content is $&#123;'$'&#125;strings")&#125; Tip2-Kotlin中大多数控制结构都是表达式回到目录 首先，需要弄清楚一个概念语句和表达式，然后会介绍控制结构表达式的优点：简洁 语句和表达式是什么？ 表达式有值，并且能作为另一个表达式的一部分使用 语句总是包围着它的代码块中的顶层元素，并且没有自己的值Kotlin与Java的区别 Java中，所有的控制结构都是语句，也就是控制结构都没有值 Kotlin中，除了循环（for、do和do/while）以外，大多数控制结构都是表达式(if/when等) 详见案例代码tip2 Example1：if语句java中，if 是语句，没有值，必须显式的return12345678910/** java中的if语句* */public int max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125;&#125; kotlin中，if 是表达式，不是语句，因为表达式有值，可以作为值return出去123456/** kotlin中，if 是表达式，不是语句，类似于java中的三目运算符a &gt; b ? a : b* */fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; 上面的if中的分支最后一行语句就是该分支的值，会作为函数的返回值。这其实跟java中的三元运算符类似，123456/** java的三元运算符* */public int max2(int a, int b) &#123; return a &gt; b ? a : b;&#125; 上面是java中的三元运算符，kotlin中if是表达式有值，完全可以替代，故kotlin中已没有三元运算符了，用if来替代。上面的max函数还可以简化成下面的形式1234/** kotlin简化版本* */fun max2(a: Int, b: Int) = if (a &gt; b) a else b Example2：when语句Kotlin中的when非常强大，完全可以取代Java中的switch和if/else，同时，when也是表达式，when的每个分支的最后一行为当前分支的值先看一下java中的switch12345678910111213141516/** java中的switch* */public String getPoint(char grade) &#123; switch (grade) &#123; case 'A': return "GOOD"; case 'B': case 'C': return "OK"; case 'D': return "BAD"; default: return "UN_KNOW"; &#125;&#125; java中的switch有太多限制，我们再看看Kotlin怎样去简化的123456789101112/** kotlin中，when是表达式，可以取代Java 中的switch，when的每个分支的最后一行为当前分支的值* */fun getPoint(grade: Char) = when (grade) &#123; 'A' -&gt; "GOOD" 'B', 'C' -&gt; &#123; println("test when") "OK" &#125; 'D' -&gt; "BAD" else -&gt; "UN_KNOW"&#125; 同样的，when语句还可以取代java中的if/else if，其是表达式有值，并且更佳简洁123456789101112131415/** java中的if else* */public String getPoint2(Integer point) &#123; if (point &gt; 100) &#123; return "GOOD"; &#125; else if (point &gt; 60) &#123; return "OK"; &#125; else if (point.hashCode() == 0x100) &#123; //... return "STH"; &#125; else &#123; return "UN_KNOW"; &#125;&#125; 再看看kotlin的版本，使用不带参数的when，只需要6行代码123456789/** kotlin中，when是表达式，可以取代java的if/else，when的每个分支的最后一行为当前分支的值* */fun getPoint2(grade: Int) = when &#123; grade &gt; 90 -&gt; "GOOD" grade &gt; 60 -&gt; "OK" grade.hashCode() == 0x100 -&gt; "STH" else -&gt; "UN_KNOW"&#125; Tip3-更好调用的函数-显式参数名及默认参数值回到目录 显式参数名Kotlin的函数更加好调用，主要是表现在两个方面：1，显式的标示参数名，可以方便代码阅读；2，函数可以有默认参数值，可以大大减少Java中的函数重载。例如现在需要实现一个工具函数，打印列表的内容：详见案例代码KotlinTip312345678910111213141516171819202122232425/** 打印列表的内容* */fun &lt;T&gt; joinToString(collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList() &#123; val list = listOf(2, 4, 0) // 不标明参数名 println(joinToString(list, " - ", "[", "]")) // 显式的标明参数名称 println(joinToString(list, separator = " - ", prefix = "[", postfix = "]"))&#125; 如上面的代码所示，函数joinToString想要打印列表的内容，需要传入四个参数：列表、分隔符、前缀和后缀。由于参数很多，在后续使用该函数的时候不是很直观的知道每个参数是干什么用的，这时候可以显式的标明参数名称，增加代码可读性。 默认参数值同时，定义函数的时候还可以给函数默认的参数，如下所示：1234567891011121314151617181920212223/** 打印列表的内容，带有默认的参数，可以避免java的函数重载* */fun &lt;T&gt; joinToString2(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList3() &#123; val list = listOf(2, 4, 0) println(joinToString2(list, " - ")) println(joinToString2(list, " , ", "["))&#125; 这样有了默认参数后，在使用函数时，如果不传入该参数，默认会使用默认的值，这样可以避免Java中大量的函数重载。 @JvmOverloads在java与kotlin的混合项目中，会发现用kotlin实现的带默认参数的函数，在java中去调用的化就不能利用这个特性了，还是需要给所有参数赋值，像下面java这样：123List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2(arr, "-", "", "");System.out.println(res); 这时候可以在kotlin的函数前添加注解@JvmOverloads，添加注解后翻译为class的时候kotlin会帮你去生成多个函数实现函数重载，kotlin代码如下：12345678910111213141516/** 通过注解@JvmOverloads解决java调用kotlin时不支持默认参数的问题* */@JvmOverloadsfun &lt;T&gt; joinToString2New(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125; 这样以后，java调用kotlin的带默认参数的函数就跟kotlin一样方便了：12345List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2New(arr, "-");System.out.println(res);String res2 = joinToString2New(arr, "-", "=&gt;");System.out.println(res2); Tip4-扩展函数和属性回到目录 扩展函数和扩展属性是Kotlin非常方便实用的一个功能，它可以让我们随意的扩展第三方的库，你如果觉得别人给的SDK的Api不好用，或者不能满足你的需求，这时候你可以用扩展函数完全去自定义。 扩展函数例如String类中，我们想获取最后一个字符，String中没有这样的直接函数，你可以用.后声明这样一个扩展函数：详见案例代码KotlinTip41234567891011/** 扩展函数* */fun String.lastChar(): Char = this.get(this.length - 1)/** 测试* */fun testFunExtension() &#123; val str = "test extension fun"; println(str.lastChar())&#125; 这样定义好lastChar()函数后，之后只需要import进来后，就可以用String类直接调用该函数了，跟调用它自己的方法没有区别。这样可以避免重复代码和一些静态工具类，而且代码更加简洁明了。例如我们可以改造上面tip3中的打印列表内容的函数：12345678910111213141516171819/** 用扩展函数改造Tip3中的列表打印内容函数* */fun &lt;T&gt; Collection&lt;T&gt;.joinToString3(separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;fun printList4() &#123; val list = listOf(2, 4, 0) println(list.joinToString3("/"))&#125; 扩展属性除了扩展函数，还可以扩展属性，例如我想实现String和StringBuilder通过属性去直接获得最后字符：12345678910111213141516171819202122/** 扩展属性 lastChar获取String的最后一个字符* */val String.lastChar: Char get() = get(length - 1)/** 扩展属性 lastChar获取StringBuilder的最后一个字符* */var StringBuilder.lastChar: Char get() = get(length - 1) set(value: Char) &#123; setCharAt(length - 1, value) &#125;/** 测试* */fun testExtension() &#123; val s = "abc" println(s.lastChar) val sb = StringBuilder("abc") println(sb.lastChar)&#125; 定义好扩展属性后，之后只需import完了就跟使用自己的属性一样方便了。 Why？Kotlin为什么能实现扩展函数和属性这样的特性？在Kotlin中要理解一些语法，只要认识到Kotlin语言最后需要编译为class字节码，Java也是编译为class执行，也就是可以大致理解为Kotlin需要转成Java一样的语法结构，Kotlin就是一种强大的语法糖而已，Java不具备的功能Kotlin也不能越界的。 那Kotlin的扩展函数怎么实现的呢？介绍一种万能的办法去理解Kotlin的语法：将Kotlin代码转化成Java语言去理解，步骤如下： 在Android Studio中选择Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode 这样就把Kotlin转化为class字节码了 class码阅读不太友好，点击左上角的Decompile就转化为Java 再介绍一个小窍门，在前期对Kotlin语法不熟悉的时候，可以先用Java写好代码，再利用AndroidStudio工具将Java代码转化为Kotlin代码，步骤如下： 在Android Studio中选中要转换的Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File 我们看看将上面的扩展函数转成Java后的代码123456789101112131415161718192021/** 扩展函数会转化为一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char lastChar(@NotNull String $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char getLastChar(@NotNull StringBuilder $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final void setLastChar(@NotNull StringBuilder $receiver, char value) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); $receiver.setCharAt($receiver.length() - 1, value);&#125; 查看上面的代码可知：对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象，这样把类的实例传入函数以后，函数内部就可以访问到类的公有方法。对于扩展属性也类似，获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象，设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象。函数内部可以访问公有的方法和属性。顶层的扩展函数是static的，不能被override 从上面转换的源码其实可以看到扩展函数和扩展属性适用的地方和缺陷： 扩展函数和扩展属性内只能访问到类的公有方法和属性，私有的和protected是访问不了的 扩展函数不是真的修改了原来的类，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型，案例代码StaticllyExtension.kt 12345678910111213141516171819202122open class C class D : C() fun C.foo() = "c" fun D.foo() = "d" /** https://kotlinlang.org/docs/reference/extensions.html* Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,* but merely make new functions callable with the dot-notation on variables of this type. Extension functions are* dispatched statically.* */fun printFoo(c: C) &#123; println(c.foo())&#125; fun testStatically() &#123; printFoo(C()) // print c printFoo(D()) // also print c&#125; 上面的案例中即使调用printFoo(D())还是打印出c，而不是d。转成java中会看到下面的代码，D类型在调用的时候会强制转换为C类型： 12345678910111213141516171819public static final String foo(@NotNull C $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "c";&#125; public static final String foo(@NotNull D $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "d";&#125; public static final void printFoo(@NotNull C c) &#123; Intrinsics.checkParameterIsNotNull(c, "c"); String var1 = foo(c); System.out.println(var1);&#125;public static final void testStatically() &#123; printFoo(new C()); printFoo((C)(new D()));&#125; 声明扩展函数作为类的成员变量 上面的例子扩展函数是作为顶层函数，如果把扩展函数申明为类的成员变量，即扩展函数的作用域就在类的内部有效，案例代码ExtensionsAsMembers.kt123456789101112131415161718192021222324252627282930313233343536open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // call the extension function &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;fun testAsMembers() &#123; C().caller(D()) // prints "D.foo in C" C1().caller(D()) // prints "D.foo in C1" - dispatch receiver is resolved virtually C().caller(D1()) // prints "D.foo in C" - extension receiver is resolved statically C1().caller(D1()) // prints "D.foo in C1"&#125; 函数caller的类型是D，即使调用C().caller(D1())，打印的结果还是D.foo in C，而不是D1.foo in C，不是运行时来动态决定类型，成员扩展函数申明为open，一旦在子类中被override，就调用不到在父类中的扩展函数，在子类中的作用域内的只能访问到override后的函数，不能像普通函数override那样通过super关键字访问了。 下面再举几个扩展函数的例子，让大家感受一下扩展函数的方便：1234567891011121314151617181920212223242526272829303132333435/** show toast in activity* */fun Activity.toast(msg: String) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()&#125;val Context.inputMethodManager: InputMethodManager? get() = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager/** hide soft input* */fun Context.hideSoftInput(view: View) &#123; inputMethodManager?.hideSoftInputFromWindow(view.windowToken, 0)&#125;/** * screen width in pixels */val Context.screenWidth get() = resources.displayMetrics.widthPixels/** * screen height in pixels */val Context.screenHeight get() = resources.displayMetrics.heightPixels/** * returns dip(dp) dimension value in pixels * @param value dp */fun Context.dip2px(value: Int): Int = (value * resources.displayMetrics.density).toInt() Tip5-懒初始化bylazy和延迟初始化lateinit回到目录 懒初始化by lazy懒初始化是指推迟一个变量的初始化时机，变量在使用的时候才去实例化，这样会更加的高效。因为我们通常会遇到这样的情况，一个变量直到使用时才需要被初始化，或者仅仅是它的初始化依赖于某些无法立即获得的上下文。详见案例代码KotlinTip512345678910/** 懒初始化api实例* */val purchasingApi: PurchasingApi by lazy &#123; val retrofit: Retrofit = Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(MoshiConverterFactory.create()) .build() retrofit.create(PurchasingApi::class.java)&#125; 像上面的代码，retrofit生成的api实例会在首次使用到的时候才去实例化。需要注意的是by lazy一般只能修饰val不变的对象，不能修饰var可变对象。12345678class User(var name: String, var age: Int)/** 懒初始化by lazy* */val user1: User by lazy &#123; User("jack", 15)&#125; 延迟初始化lateinit另外，对于var的变量，如果类型是非空的，是必须初始化的，不然编译不通过，这时候需要用到lateinit延迟初始化，使用的时候再去实例化。12345678/** 延迟初始化lateinit* */lateinit var user2: Userfun testLateInit() &#123; user2 = User("Lily", 14)&#125; by lazy 和 lateinit 的区别 by lazy 修饰val的变量 lateinit 修饰var的变量，且变量是非空的类型 Tip6-不用再手写findViewById回到目录 在Activity中使用在Android的View中，会有很多代码是在声明一个View，然后通过findViewById后从xml中实例化赋值给对应的View。在kotlin中可以完全解放出来了，利用kotlin-android-extensions插件，不用再手写findViewById。步骤如下：详见案例代码KotlinTip6 步骤1，在项目的gradle中 apply plugin: ‘kotlin-android-extensions’ 步骤2，按照原来的习惯书写布局xml文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tip6Tv" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/tip6Img" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/tip6Btn" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 步骤3，在java代码中import对应的布局就可以开始使用了，View不用提前声明，插件会自动根据布局的id生成对应的View成员（其实没有生成属性，原理见下面） 123456789101112131415161718192021222324252627import com.sw.kotlin.tips.R/** 导入插件生成的View* */import kotlinx.android.synthetic.main.activity_tip6.*class KotlinTip6 : Activity() &#123; /* * 自动根据layout的id生成对应的view * */ override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_tip6) tip6Tv.text = "Auto find view for TextView" tip6Img.setImageBitmap(null) tip6Btn.setOnClickListener &#123; test() &#125; &#125; private fun test()&#123; tip6Tv.text = "update" &#125;&#125; 像上面代码这样，Activity里的三个View自动生成了，不用再去声明，然后findViewById，然后转型赋值，是不是减少了很多没必要的代码，让代码非常的干净。 Why？原理是什么？插件帮我们做了什么？要看原理还是将上面的代码转为java语言来理解，参照tips4提供的方式转换为如下的java代码：12345678910111213141516171819202122232425262728293031323334353637383940414243public final class KotlinTip6 extends Activity &#123; private HashMap _$_findViewCache; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setContentView(2131296284); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"Auto find view for TextView"); ((ImageView)this._$_findCachedViewById(id.tip6Img)).setImageBitmap((Bitmap)null); ((Button)this._$_findCachedViewById(id.tip6Btn)).setOnClickListener((OnClickListener)(new OnClickListener() &#123; public final void onClick(View it) &#123; KotlinTip6.this.test(); &#125; &#125;)); &#125; private final void test() &#123; TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence) "update"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; var2 = this.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125;&#125; 如上面的代码所示，在编译阶段，插件会帮我们生成视图缓存，视图由一个Hashmap结构的_$_findViewCache变量缓存，会根据对应的id先从缓存里查找，缓存没命中再去真正调用findViewById查找出来，再存在HashMap中。 子View或者include标签中findViewById子子View或者include标签中，同样可以省略findViewById，但需要主要默认的activity的布局import是不会将这个include的View引入进来123456789101112131415&lt;include layout="@layout/layout_tip6"/&gt;//include layout&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/test_inside_id" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/app_name"/&gt;&lt;/FrameLayout&gt; 需要我们引入对应的View的id，像这样import kotlinx.android.synthetic.main.layout_tip6.*123456//导入插件生成的Viewimport kotlinx.android.synthetic.main.activity_tip6.*//include layout的Viewimport kotlinx.android.synthetic.main.layout_tip6.*test_inside_id.text = "Test include" 在Fragment中findViewById在Fragment中也类似，但有一点需要注意但地方，例子如下：12345678910111213141516171819class Tip6Fragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val view = inflater?.inflate(R.layout.fragment_tip6, container, false) /* * 这时候不能在onCreateView方法里用view，需要在onViewCreate里，原理是插件用了getView来findViewById * */ // tip6Tv.text = "test2" return view &#125; /* * 需要在onViewCreate里，原理是插件用了getView来findViewById * */ override fun onViewCreated(view: View?, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) tip6Tv.text = "test" &#125;&#125; 如上所示，Fragment需要注意，不能在onCreateView方法里用view，不然会出现空指针异常，需要在onViewCreate里，原理是插件用了getView来findViewById，我们看看将上面的代码转成java后的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class Tip6Fragment extends Fragment &#123; private HashMap _$_findViewCache; @Nullable public View onCreateView(@Nullable LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater != null?inflater.inflate(2131296286, container, false):null; return view; &#125; public void onViewCreated(@Nullable View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"test"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; View var10000 = this.getView(); if (var10000 == null) &#123; return null; &#125; var2 = var10000.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125; // $FF: synthetic method public void onDestroyView() &#123; super.onDestroyView(); this._$_clearFindViewByIdCache(); &#125;&#125; 跟Activity中类似，会有一个View的HashMap，关键不同的地方在_$findCachedViewById里面，需要getView获得当前Fragment的View，故在onViewCreated中getView还是空的，原理就好理解了。另外在onDestroyView会调用$_clearFindViewByIdCache方法清掉缓存。 Tip7-利用局部函数抽取重复代码回到目录 局部函数抽取代码Kotlin中提供了函数的嵌套，在函数内部还可以定义新的函数。这样我们可以在函数中嵌套这些提前的函数，来抽取重复代码。如下面的案例所示:详见案例代码KotlinTip71234567891011121314class User(val id: Int, val name: String, val address: String, val email: String)fun saveUser(user: User) &#123; if (user.name.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Name") &#125; if (user.address.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Address") &#125; if (user.email.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Email") &#125; // save to db ...&#125; 上面的代码在判断name、address等是否为空的处理其实很类似。这时候，我们可以利用在函数内部嵌套的声明一个通用的判空函数将相同的代码抽取到一起：123456789101112131415/** 利用局部函数抽取相同的逻辑，去除重复的代码* */fun saveUser2(user: User) &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty $fildName") &#125; &#125; validate(user.name, "Name") validate(user.address, "Address") validate(user.email, "Email") // save to db ...&#125; 扩展函数抽取代码除了利用嵌套函数去抽取，此时，其实也可以用扩展函数来抽取，如下所示：12345678910111213141516171819/** 利用扩展函数抽取逻辑* */fun User.validateAll() &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $id: empty $fildName") &#125; &#125; validate(name, "Name") validate(address, "Address") validate(email, "Email")&#125;fun saveUser3(user: User) &#123; user.validateAll() // save to db ...&#125; Tip8-使用数据类来快速实现model类回到目录 在java中要声明一个model类需要实现很多的代码，首先需要将变量声明为private，然后需要实现get和set方法，还要实现对应的hashcode equals toString方法等，如下所示：详见案例代码Tip81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static class User &#123; private String name; private int age; private int gender; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + ", address='" + address + '\'' + '&#125;'; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; if (gender != user.gender) return false; if (name != null ? !name.equals(user.name) : user.name != null) return false; return address != null ? address.equals(user.address) : user.address == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; result = 31 * result + gender; result = 31 * result + (address != null ? address.hashCode() : 0); return result; &#125;&#125; 这段代码Java需要70行左右，而如果用kotlin，只需要一行代码就可以做到。123456789/** Kotlin会为类的参数自动实现get set方法* */class User(val name: String, val age: Int, val gender: Int, var address: String)/** 用data关键词来声明一个数据类，除了会自动实现get set，还会自动生成equals hashcode toString* */data class User2(val name: String, val age: Int, val gender: Int, var address: String) 对于Kotlin中的类，会为它的参数自动实现get set方法。而如果加上data关键字，还会自动生成equals hashcode toString。原理其实数据类中的大部分代码都是模版代码，Kotlin聪明的将这个模版代码的实现放在了编译器处理的阶段。 Tip9-用类委托来快速实现装饰器模式回到目录 通过继承的实现容易导致脆弱性，例如如果需要修改其他类的一些行为，这时候Java中的一种策略是采用装饰器模式：创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个成员变量。与原始类拥有相同行为的方法不用修改，只需要直接转发给原始类的实例。如下所示：详见案例代码KotlinTip91234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 常见的装饰器模式，为了修改部分的函数，却需要实现所有的接口函数* */class CountingSet&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; &#123; var objectAdded = 0 override val size: Int get() = innerSet.size /* * 需要修改的方法 * */ override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; /* * 需要修改的方法 * */ override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125; override fun contains(element: T): Boolean &#123; return innerSet.contains(element) &#125; override fun containsAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.containsAll(elements) &#125; override fun isEmpty(): Boolean &#123; return innerSet.isEmpty() &#125; override fun clear() &#123; innerSet.clear() &#125; override fun iterator(): MutableIterator&lt;T&gt; &#123; return innerSet.iterator() &#125; override fun remove(element: T): Boolean &#123; return innerSet.remove(element) &#125; override fun removeAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.removeAll(elements) &#125; override fun retainAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.retainAll(elements) &#125;&#125; 如上所示，想要修改HashSet的某些行为函数add和addAll，需要实现MutableCollection接口的所有方法，将这些方法转发给innerSet去具体的实现。虽然只需要修改其中的两个方法，其他代码都是模版代码。只要是重复的模版代码，Kotlin这种全新的语法糖就会想办法将它放在编译阶段再去生成。这时候可以用到类委托by关键字，如下所示：1234567891011121314151617/** 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了* */class CountingSet2&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123; var objectAdded = 0 override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125;&#125; 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了，通过类委托将10行代码就可以实现上面接近100行的功能，简洁明了，去掉了模版代码。 Tip10-Lambda表达式简化OnClickListener回到目录 详见案例代码KotlinTip10lambda表达式可以简化我们的代码。以Android中常见的OnClickListener来说明，在Java中我们一般这样设置：1234567TextView textView = new TextView(context);textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // handle click &#125;&#125;); Java中需要声明一个匿名内部类去处理，这种情况可以用lambda表达式来简化。 lambda表达式一般长这样 { x:Int, y:Int -&gt; x+y } 参数 -&gt; 表达式 并且始终在大括号中 it作为默认参数名 lambda捕捉，当捕捉final变量时，它的值和lambda代码一起存储 非final变量，它的值被封装在一个特殊的包装器中，这个包装器的引用会和lambda代码一起存储 我们来看看Kotlin中的例子：12345678910111213141516171819val textView = TextView(context)/** 传统方式* */textView.setOnClickListener(object : android.view.View.OnClickListener &#123; override fun onClick(v: android.view.View?) &#123; // handle click &#125;&#125;)/** lambda的方式* */textView.setOnClickListener(&#123; v -&gt; &#123; // handle click &#125;&#125;) 当lambda的参数没有使用时可以省略，省略的时候用it来替代123456/** lambda的参数如果没有使用可以省略，省略的时候用it来替代* */textView.setOnClickListener(&#123; // handle click&#125;) lambda在参数的最后一个的情况可以将之提出去123456/** lambda在参数的最后一个的情况可以将之提出去* */textView.setOnClickListener() &#123; // handle click&#125; lambda提出去之后，函数如果没有其他参数括号可以省略123456/** lambda提出去之后，函数如果没有其他参数括号可以省略* */textView.setOnClickListener &#123; // handle click&#125; 我们再看看如果自己去实现一个带lambda参数的函数应该怎么去定义：1234567891011121314151617181920212223242526interface OnClickListener &#123; fun onClick()&#125;class View &#123; var listener: OnClickListener? = null; /* * 传统方式 * */ fun setOnClickListener(listener: OnClickListener) &#123; this.listener = listener &#125; fun doSth() &#123; // some case: listener?.onClick() &#125; /* * 声明lambda方式，listener: () -&gt; Unit * */ fun setOnClickListener(listener: () -&gt; Unit) &#123; &#125;&#125; 在函数参数中需要声明lambda的类型后，再调用该函数的时候就可以传入一个lambda表达式了。 Tip11-with函数来简化代码回到目录 with 函数原型： 1inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() with函数并不是扩展函数，返回值是最后一行，可以直接调用对象的方法 Kotlin中可以用with语句来省略同一个变量的多次声明，例如下面的函数详见案例代码KotlinTip11123456789101112/**打印字母表函数，在函数内result变量在好几处有使用到* */fun alphabet(): String &#123; val result = StringBuilder() result.append("START\n") for (letter in 'A'..'Z') &#123; result.append(letter) &#125; result.append("\nEND") return result.toString()&#125; 在上面的函数中，result变量出现了5次，如果用with语句，可以将这5次都不用再出现了，我们来一步一步地看是怎么实现的：1234567891011121314/** 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了* */fun alphabet2(): String &#123; val result = StringBuilder() return with(result) &#123; this.append("START\n") for (letter in 'A'..'Z') &#123; this.append(letter) &#125; this.append("\nEND") this.toString() &#125;&#125; 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了，而且这个this是可以省略的 1234567891011121314/** 通过with语句，将result参数作为参数，在内部this也可以省略掉* */fun alphabet3(): String &#123; val result = StringBuilder() return with(result) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 在内部this省略掉后，现在只有一个result了，这个其实也是没必要的，于是出现了下面的最终版本：12345678910111213/** 通过with语句，可以直接将对象传入，省掉对象的声明* */fun alphabet4(): String &#123; return with(StringBuilder()) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 像上面这样，我们可以把同一个变量的显式调用从5次变为0次，发现Kotlin的魅力了吧。 Tip12-apply函数来简化代码回到目录 apply 函数原型： 1inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 除了用上面的with可以简化同一个变量的多次声明，还可以用apply关键字，我们来改造一下tip11中的函数：详见案例代码KotlinTip1212345678910/** 用apply语句简化代码，在apply的大括号里可以访问类的公有属性和方法* */fun alphabet5() = StringBuilder().apply &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND")&#125;.toString() 像上面这样的，通过apply后，在apply的大括号里可以访问类的公有属性和方法。这在对应类的初始化是非常方便的，例如下面的例子12345678910111213141516171819202122/** 用apply语句简化类的初始化，在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁* */fun testApply(context: Context) &#123; var imgView = ImageView(context).apply &#123; setBackgroundColor(0) setImageBitmap(null) &#125; var textView = TextView(context).apply &#123; text = "content" textSize = 20.0f setPadding(10, 0, 0, 0) &#125; var user = User().apply &#123; age = 15 name = "Jack" val a = address address = "bbb" &#125;&#125; 在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁 Tip13-在编译阶段避免掉NullPointerException回到目录 可空类型和不可空类型NullPointerException是Java程序员非常头痛的一个问题，我们知道Java 中分受检异常和非受检异常，NullPointerException是非受检异常，也就是说NullPointerException不需要显示的去catch住，往往在运行期间，程序就可能报出一个NullPointerException然后crash掉，Kotlin作为一门高效安全的语言，它尝试在编译阶段就把空指针问题显式的检测出来，把问题留在了编译阶段，让程序更加健壮。详见案例代码KotlinTip13 Kotlin中类型分为可空类型和不可空类型，通过？代表可空，不带？代表不可为空 123456789101112131415161718192021fun testNullType() &#123; val a: String = "aa" /* * a是非空类型，下面的给a赋值为null将会编译不通过 * */ // a = null a.length /* * ？声明是可空类型，可以赋值为null * */ var b: String? = "bb" b = null /* * b是可空类型，直接访问可空类型将编译不通过，需要通过?.或者!!.来访问 * */ // b.length b?.length b!!.length&#125; 对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过 对于一个可空类型：通过？声明，在访问该类型的时候直接访问不能编译通过，需要通过?.或者!!. ?. 代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性 !!. 代表着如果该类型为空的话就抛出NullPointerException，如果不为空就去访问对应的方法或者属性，所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出NullPointerException。而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了：12345/** 不推荐这样的写法：链式的连续用!!.* */val user = User()user!!.name!!.subSequence(0,5)!!.length 对应一个可空类型，每次对它的访问都需要带上?.判断12345678val user: User? = User() /* * 每次访问都用用?.判断 * */ user?.name user?.age user?.toString() 但这样多了很多代码，kotlin做了一些优化，12345678/** 或者提前判断是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了* */if (user != null) &#123; user.name user.age user.toString()&#125; 通过if提前判断类型是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了。 let语句简化对可空对象对访问 let 函数原型： 1inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) let函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。 上面的代码还可以用?.let语句进行，如下所示：12345678/** 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作* */user?.let &#123; it.name it.age it.toString()&#125; 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作 Elvis操作符 ?: 简化对空值的处理如果值可能为空，对空值的处理可能会比较麻烦，像下面这样：123456789101112131415161718/** 对空值的处理* */fun testElvis(input: String?, user: User?) &#123; val a: Int? if (input == null) &#123; a = -1 &#125; else &#123; a = input?.length &#125; if (user == null) &#123; var newOne = User() newOne.save() &#125; else &#123; user.save() &#125;&#125; Elvis操作符?:能够简化上面的操作，?:符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟?.let正好相反，例如我们可以用两行代码来简化上面从操作：1234567/** * Elvis操作符 ?: 简化对空值的处理 */fun testElvis2(input: String?, user: User?) &#123; val b = input?.length ?: -1; user?.save() ?: User().save()&#125; Tip14-运算符重载回到目录 Kotlin支持对运算符的重载，这对于对一些对象的操作更加灵活直观。 使用operator来修饰plus\minus函数 可重载的二元算术符 A * B times A / B div A % B mod A + B plus A - B minus 以下面对坐标点Point的案例说明怎么去重载运算符：详见案例代码KotlinTip14123456789101112131415161718192021class Point(val x: Int, val y: Int) &#123; /* * plus函数重载对Point对象的加法运算符 * */ operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125; /* * minus函数重载对Point对象的减法运算符 * */ operator fun minus(other: Point): Point &#123; return Point(x - other.x, y - other.y) &#125; override fun toString(): String &#123; return "[x:$x, y:$y]" &#125;&#125; 如上所示，通过plus函数重载对Point对象的加法运算符，通过minus函数重载对Point对象的减法运算符，然后就可以用+、-号对两个对象进行操作了：1234567fun testOperator() &#123; val point1 = Point(10, 10) val point2 = Point(4, 4) val point3 = point1 + point2 println(point3) println(point1 - point2)&#125; Tip15-高阶函数简化代码回到目录 高阶函数：以另一个函数作为参数或者返回值的函数 函数类型 (Int, String) -&gt; Unit 参数类型-&gt;返回类型 Unit不能省略 1234567891011121314val list = listOf(2, 5, 10)/** 传入函数来过滤* */println(list.filter &#123; it &gt; 4 &#125;) /** 定义函数类型* */val sum = &#123; x: Int, y: Int -&gt; x + y &#125;val action = &#123; println(42) &#125;val sum2: (Int, Int) -&gt; Int = &#123; x: Int, y: Int -&gt; x + y &#125;val action2: () -&gt; Unit = &#123; println(42) &#125; 函数作为参数函数作为参数，即高阶函数中，函数的参数可以是一个函数类型，例如要定义一个函数，该函数根据传入的操作函数来对2和3做相应的处理。详见案例代码KotlinTip15 123456789101112/** 定义对2和3的操作函数* */fun twoAndThree(operator: (Int, Int) -&gt; Int) &#123; val result = operator(2, 3) println("Result:$result")&#125;fun test03() &#123; twoAndThree &#123; a, b -&gt; a + b &#125; twoAndThree &#123; a, b -&gt; a * b &#125;&#125; operator是函数类型，函数的具体类型为(Int, Int) -&gt; Int，即输入两个Int返回一个Int值。定义完了后就可以像上面这样使用了。再举一个例子，实现String类的字符过滤：123456789101112131415/** 函数作为参数，实现String类的字符过滤* */fun String.filter(predicate: (Char) -&gt; Boolean): String &#123; val sb = StringBuilder() for (index in 0 until length) &#123; val element = get(index) if (predicate(element)) sb.append(element) &#125; return sb.toString()&#125;fun test04() &#123; println("12eafsfsfdbzzsa".filter &#123; it in 'a'..'f' &#125;)&#125; 像上面这样predicate是函数类型，它会根据传入的char来判断得到一个Boolean值。 函数作为返回值函数作为返回值也非常实用，例如我们的需求是根据不同的快递类型返回不同计价公式，普通快递和高级快递的计价规则不一样，这时候我们可以将计价规则函数作为返回值： 1234567891011121314151617181920enum class Delivery &#123; STANDARD, EXPEDITED&#125;/** 根据不同的运输类型返回不同的快递方式* */fun getShippingCostCalculator(delivery: Delivery): (Int) -&gt; Double &#123; if (delivery == Delivery.EXPEDITED) &#123; return &#123; 6 + 2.1 * it &#125; &#125; return &#123; 1.3 * it &#125;&#125;fun test05() &#123; val calculator1 = getShippingCostCalculator(Delivery.EXPEDITED) val calculator2 = getShippingCostCalculator(Delivery.STANDARD) println("Ex costs $&#123;calculator1(5)&#125;") println("St costs $&#123;calculator2(5)&#125;")&#125; 如果是普通快递，采用1.3 it的规则计算价格，如果是高级快递按照6 + 2.1 it计算价格，根据不同的类型返回不同的计价函数。 Tip16-用Lambda来简化策略模式回到目录 策略模式是常见的模式之一，java的例子如下。详见案例代码Tip1612345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 定义策略接口 */ public interface Strategy &#123; void doSth(); &#125; /** * A策略 */ public static class AStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do A Strategy"); &#125; &#125; /** * B策略 */ public static class BStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do B Strategy"); &#125; &#125; /** * 策略实施者 */ public static class Worker &#123; private Strategy strategy; public Worker(Strategy strategy) &#123; this.strategy = strategy; &#125; public void work() &#123; System.out.println("START"); if (strategy != null) &#123; strategy.doSth(); &#125; System.out.println("END"); &#125; &#125; 如上面的例子所示，有A、B两种策略，Worker根据不同的策略做不同的工作，使用策略时：1234Worker worker1 = new Worker(new AStrategy());Worker worker2 = new Worker(new BStrategy());worker1.work();worker2.work(); 在java中实现这种策略模式难免需要先定义好策略的接口，然后根据接口实现不同的策略，在Kotlin中完全可以用用Lambda来简化策略模式，上面的例子用Kotlin实现：1234567891011121314151617181920212223242526/** * 策略实施者 * @param strategy lambda类型的策略 */class Worker(private val strategy: () -&gt; Unit) &#123; fun work() &#123; println("START") strategy.invoke() println("END") &#125;&#125;/** 测试* */fun testStrategy() &#123; val worker1 = Worker(&#123; println("Do A Strategy") &#125;) val bStrategy = &#123; println("Do B Strategy") &#125; val worker2 = Worker(bStrategy) worker1.work() worker2.work()&#125; 不需要先定义策略的接口，直接把策略以lambda表达式的形式传进来就行了。 参考文档 《Kotlin in Action》 https://kotlinlang.org/docs/reference/ https://savvyapps.com/blog/kotlin-tips-android-development]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒冬将至，Android的出路]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%AF%92%E5%86%AC%E5%B7%B2%E8%87%B3%EF%BC%8CAndroid%E7%9A%84%E5%87%BA%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。 Android开发的天花板很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。 再说职业上，确实Android应用开发很难升任CTO，一般的CTO主要是后端，这主要是两个原因：后端的技术栈很早就成熟了，我8年前转做Android开发时，那帮30多岁的Java开发就已经很厉害了，随着时间的推移，后端技术大牛远比Android大牛的人数要多，也更厉害，他们做技术经理时，我们都还在搬砖； 后端确实可以统筹全局，在公司业务上属于重要地位。 不过我们忽略了最重要的一点，如果我们是做后端的，一定能做到CTO吗？我想也是很难的，所以不要眼睛只盯着高处，先想想自己能达到什么程度，站在半山腰就说山下面的风景不开阔本身也不合理啊。 是否要转行Android不热门了，很多Android开发已经转行了，有的正走在转行的路上，还有的迟疑不决，到底要不要转呢？我们来分析下。 转什么好每个人的自身情况不同，转的方向也会有所区别，转人工智能相关开发肯定是最好的，毕竟风口上的猪也能飞，跟着风口无可厚非。只可惜人工智能相关对学历和算法要求很高，最起码得是个硕士吧，而且这只是低配。那么大多数Android开发可以转的方向主要有前端、后端和Python等等。我大概说一下： 转前端，这个是我认为最好转的一个方向，前端的理念很多都和Android类似，也可以作为Android的延伸，向大前端发展，如果对界面感兴趣的可以转前端试试。 转后端，后端这个就是完全的转行了，看似Java大家都会，但是后端的技术栈可不是只有Java，各种框架绝对叫你头大，很多人强调后端技术深，各种处理高并发看似十分有技术含量，不过这只是为数不多的公司在做。如果想要稳定的可以转后端试试。 转Python，Python最近真是很火，因为他跟人工智能发生了关联，其实大部分学Python的没有搞什么人工智能相关，基本都是在搞爬虫。追求浪潮的可以转Python试试。 不要轻易转行，要转就早点转转行有两种我认为是正常的，一种是行业消失或者没落了，个人无法施展才华。另一种是兴趣不在本行，因此转一个自己感兴趣的。而现在大部分转行纯属是为了跟风，为了那点钱，而忽略了长期的发展。我们来看看下面的图。 从图中可以看出，大部分人在35岁前是在加速期，35岁后是上升或者衰落期。以Android开发转前端来说，假设一个Android高级A同学转行前端会变为前端初级，这时从事前端的人都在加速提高，A同学要想赶超前面的拥有同样加速度的人是不可能办到的，这就导致他在转行前期极为被动，A同学还要保证在35岁前成为前端专家或者Leader才有可能在35岁后不进入衰落期，当然这时A同学的Android基本也就荒废了，很难成为专家。如果还想要在技术领域走的更远，就不要轻易的进行转行，如果想要转越早越好，越快越好，因为其他的竞争者都在加速提高，没人会停下等你的。 转行大部分都不是质变一个开发的质变可以理解为在一个领域的大幅提升，或者是不相关领域的跨界，举个例子：可以在Android领域由高级质变为了专家，或者是由一个高级开发升到了Leader，再或者跨界开始做了一些技术相关的培训、演讲、出书等等而被人所熟知。凡是能帮助35岁后进入上升期的都可以看做是一次质变，而转行很少是质变，更多的是倒退回到原点重新出发，形象点来说，就是换了个不同的砖头接着搬砖而已（高技术含量的除外）。因此我们更应该去追求质变，而不是平行或者倒退，一次倒退可以承受，多次倒退就很难在35岁后进入上升期。 如何提升竞争力选择一个细分领域Android现在细分的领域非常多，前面说到的有应用开发、逆向安全、音视频、车联网、物联网、手机开发、SDK开发和智能电视盒子开发等等，在这些领域中选择一个并不断深入。比如音视频，在8年前我刚入门Android时，音视频就是闷声发大财了（PC端），工资高的令人乍舌，现在在移动端，音视频更是青出于蓝，是一个非常好的选择，如果想要入门可以看看何俊林《Android音视频开发》。 尽量学习半衰期长的知识知识半衰期指的是：随着知识更新周期变短，知识裂变速度加快，一个知识落伍的周期。知识半衰期长的职业都是越老越值钱的，比如英语老师和外科医生，知识更新慢并且几乎不会落伍。这一点我们程序员是绝对比不了的，我们的大部分知识半衰期是比较短的，一个框架短短几年可能就会被淘汰，这也导致程序员需要不断的学习新知识，而我们每个人的时间和精力是有限的，那么根据知识半衰期，有策略的进行学习就变得尤为重要。（这个观点很有吸引力） 上面的半衰期图不完全准确，但是却值得参考，如果你是其他的技术领域也可以参考这个半衰期图。这个图不是告诉我们不要去学RN和小程序，而是结合自身工作尽量学习半衰期长的知识。 做减法，尽量专精一门技术现在的社会，技术分工越来越细，越细就意味着大部分企业（小作坊除外）需要专精的人才（最好是精通一门通多门）。你会发现身边脱颖而出的技术人大多都是靠一门技术，却很少看到会一堆技术却都不精通的冒出来。好比在武侠的世界，高手对决都在同一个时间段拿出看家武学，如果看家武学都不精，分分钟被虐，剩下的武学也无需拿出来献丑了。联想到现实版本就是去大公司面试Android，结果Android技术了解不深，被各种虐，剩下的前端技术、后端技术、Python什么的，面试官也没兴趣了解了。 所以并不是你会的技术越多越好，一定要做好减法，先专精一门，然后再去学别的技术。（值得借鉴） 说说最近Android火热的技术Android相关的火热技术最近几年也是频出，没事就在刷屏，我来说说对这些火热技术的看法。 Kotlin，从知识的半衰期来看，这门语言非常值得学习，不过想要普及还是非常难，因为Kotlin还没有表现出非用它不可的竞争力，另外很多企业使用的成本比较高，大多数领导都是不求有功但求无过，不会下力气推广。 Flutter，从知识的半衰期来看，这个框架存在的时间相对不会长，目前也就一些有技术储备的公司去试验去尝试，如果自己公司技术储备不够，就贸然当小白鼠显然不是很明智。 这两个技术都建议大家来学习，但不要指望它们会给你增加什么太大竞争力，李四1周能学会，张三同样也能。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>规划</tag>
        <tag>半衰期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之CSS入门]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[详解css中的display属性（行内元素和块级元素） 首先，所有主流浏览器都支持display属性。其次，display属性规定了元素应该生成的框的类型。默认值：inline 我们常用的display属性有： inline block inlien-block none 把display设置成none就不会保留元素本该显示的空间（元素直接不显示），但是visibility：hidden会保留。那么其他三个有什么区别呢？看下下面css代码： 1234567891011&lt;body&gt;&lt;span class=&quot;inline&quot;&gt;inline&lt;/span&gt;inline &lt;span class=&quot;block&quot;&gt;block&lt;/span&gt;block &lt;span class=&quot;inline-block&quot;&gt;inline-block&lt;/span&gt; inline-block&lt;/body&gt; 点此看效果 inline特性我们发现内联对象inline给它设置属性height和width是没用的，致使它变宽变大的原因是： 内部元素的宽高‘+padding’。观察inline对象的前后元素我们会发现inline不单独占一行，其他元素会紧跟其后。 block特性 而块对象‘block’是可以设置宽高的，但是它的实际宽高是本身宽高+’padding‘。观察block的前后元素，我们会发现block会独占一行。 如果，我们即希望div有宽高，又不希望它独占一行要怎么办？ inline-block这个时候我们就需要’inline-block‘属性了，我们看下显示效果，就会发现： inline-block即具有block的宽高特性又具有inline的同行元素特性。 也就是说，当我们想让一个元素即不独占一行，又可以设置其宽高属性的时候，我们就可以选择inline-block了。 行内元素特点 和其他元素都在一行上； 元素的高度，宽度，行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素特点 每个块级元素都是从新的一行开始，并且其后的元素也另起一行； 元素的高度，宽度，行高及顶部和底部边距都是可以设置的； 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素一致），除非设定一个宽度。 在html中，span,a,lable,input,img,strong和em就是典型的行内元素。div,p,h1,form,ul,li就是块级元素。 块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 更多CSS display请参考]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>CSS</tag>
        <tag>小程序</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程中的TCP和UDP通信方式简介]]></title>
    <url>%2F2018%2F11%2F03%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code） TCP方式和UDP的区别 TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现 UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现 网络协议简介通过上图知道不管是TCP还是UDP都是互联网络协议中的一层—传输层协议。 图中简单对网络协议做了分层，金典的网络协议是四层，这里给了不同的四层。 最底层的以太网协议规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信，但是以太网协议不能解决多个局域网如何互通，这由IP协议解决（IP协议可以连接多个局域网） IP协议定义了一套自己的地址规则，成为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息（路由器就是基于IP协议，局域网之间靠路由器连接）。 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入很多根网线，路由器内部有一张路由表，规定了A段IP地址走出口一，B段IP地址走出口二。…通过这套指路牌，实现了数据包的转发。 IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要靠TCP协议了。 TCP协议具体的TCP协议可能是一本书的内容，这里管中窥豹一下。简单来说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 原来，我们只是简单知道TCP协议的七次==连接==，三挥四别，这里我们来完整了解下他其中的原理。 TCP数据包大小以太网数据包（pakage）的大小是固定的，最初是1518字节，后来增加到了1522字节。其中，1500字节是负载（payload），22字节是头信息（head）。IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少20字节，所以IP数据包的负载最多1480字节，TCP数据包在IP数据包的负载里面，TCP的头也要占20字节，因此TCP数据包最大负载1460字节。由于，IP和TCP协议往往还有额外的头信心，所以TCP实际负载为1400字节左右，下图会清晰的表明这种关系： 因此，一条1500字节的信息需要两个TCP数据包来承载发送。==HTTP/2协议==的一大改进就是压缩了HTTP协议的头信息，使得一个HTTP请求可以放在一个TCP数据包里面，而不是分成多个，这样就提高了传输速度。 TCP数据包的编号（SEQ）一个包1400字节，那么发送一个10M大小的数据包，需要发送7100多个包，发送的时候，TCP协议会给每个包编号，一边接收方按照顺序还原，万一发生丢包，也可以知道丢失的是哪个包。一般第一个包编号是随机的。假设我们叫第一个包编号为1号包，这个包负载100字节，那么可以推算出下一个包的编号应该是101，就是说，每个数据包都可以得到两个编号：一个自身的编号，及下一个数据包的编号。几首方由此知道，应该按照什么顺序将他们还原成原始文件。（可以用抓包工具抓来看） TCP数据包的组装收到TCP数据包以后，由操作系统来完成组装操作，应用程序是不会直接处理TCP数据包的，而是处理由他封装的例如HTTP协议的数据包。对应用程序来说，不用关心数据通信的细节，应用程序需要的数据放在了TCP数据包里面，有自己的格式（比如常见的HTTP协议），TCP不能标识原始文件大小，这个只能由应用层协议来规定，如HTTP头COntent-length，表示了信息体的大小。对于操作系统来说，就是持续的接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据，一旦组装好TCP数据包，就把他们交给引用程序（怎么组装呢？？），TCP数据包里面有个端口（port）就是用来指定转交给监听该端口的应用程序。 如上图：系统根据TCP数据包中端口，将组装好的数据转交给相应的应用程序。如21端口是FTP服务器，25端口是SMTP（邮件协议）服务，80是Web服务器（常用的Http请求）。这些一般都是在服务端的。 慢启动和ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。==TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。==（NB）。Linux 内核里面设定了（常量==TCP_INIT_CWND==），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 期待要收到下一个数据包的编号。 接收方的接收窗口剩余容量 （图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。） 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 数据包的遗失处理丢包时有发生，TCP的可靠性是怎么保证的呢？简单来说：由于每一数据包都带有编号，如有下一个数据包没收到，那么ACK的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。==这会导致大量重复内容的 ACK==。如果发送方发现收到了==三个==连续重复的ACK，或者超时没收到任何ACK，就会确认丢包了，及5号包丢了，从而再次发送这个包，通过这种机制，TCP保证了不会有数据包丢失。==（好像TCP会丢包的）== 。下图比较形象说明了这个例子： （图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。） TCP连接 Java的TCP实现（Socket）123456789101112131415161718192021public void client() throws Exception &#123; // InetAddress.getLocalHost()为客户端请求连接的主机号，此处设置为本地主机，服务进程的端口号是8090 // 主机号和端口号唯一确定了唯一主机上面的唯一进程。 Socket socket = new Socket(InetAddress.getLocalHost(), 8090); // socket.getOutputStream()获得输出流，通过输出流像主机发送数据。 OutputStream os = socket.getOutputStream(); os.write("黑猫呼叫白猫收到请回复!".getBytes()); // 关闭数据输出，如果不关闭的话服务端并不知道数据传输已经结束还会一直等待。 socket.shutdownOutput(); // 接收server端发送的数据 InputStream is = socket.getInputStream(); int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; is.close(); os.close(); socket.close(); &#125; 123456789101112131415161718192021222324public void server() throws Exception &#123; // 给服务端一个端口号8090使得客户端可以连接。 ServerSocket ss = new ServerSocket(8090); // 接受客户端的连接 Socket socket = ss.accept(); // 获得客户端的输入流 InputStream is = socket.getInputStream(); // 输出client端发送的数据 int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; OutputStream os = socket.getOutputStream(); // 通过输出流向客户端发送数据。 os.write("黑猫这里是白猫，我已收到你的呼叫!".getBytes()); os.close(); // socket.shutdownOutput(); is.close(); socket.close(); ss.close(); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+Github搭建个人Blog]]></title>
    <url>%2F2018%2F10%2F24%2FHEXO%2BGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog%2F</url>
    <content type="text"><![CDATA[HEXO背景hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面 超快部署 支持MarkDown 一键部署 丰富的插件 下面以我的Blog为例，记录搭建过程。 环境准备 安装NodeJs 123456789//mac下安装node很简单，使用mac下的包管理工具brew命令就可以了$ brew install node$ brew install npm//brew一般被安装在/usr/local/bin 目录下面//验证是否安装成功$ node -v 安装HEXO 1$ npm install hexo-cli -g 运行 装上Hexo后就可以在本地跑服务了，执行一下命令（HEXO的常见命令） 1234567$ hexo clean// 生成静态网页$ hexo g / hexo generator// 开启服务$ hexo s / hexo server运行：localhost：4000 托管托管就是将你生成的静态网页保存在服务器上，别人可以通过域名去访问（当然需要在hexo上去配置）. 一般是在github上免费托管，也可以自己去买个小鸡，既可以搭个小机场，也可以托管博客. 如果要部署到github上，首先要有GitHub账号（没有的可以不用看了），然后在仓库建一个”github账号.github.io” 名字一定要一样 添加部署插件hexo-deployer-git 1$ npm install hexo-deployer-git --save 添加git源 1234567// 编辑根目录.config.ymlvim .config.ymldeploy: type: git repo: &lt;repository url&gt; branch: [branch] branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 添加源后就可以部署了 1$ hexo d 配置全局配置关于hexo的配置都在根目录下的.config_yml下面，而关于主题的配置都在/theme/**/.config_yml下面，详细配置可以查看官方文档 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言 theme -&gt; 主题配置（主题名字 /theme目录下） 坑：进行配置时，需要在冒号:后加一个英文空格 主题配置Hexo 中有很多主题，可以在官网查看。主题现在比较流行的是Next — hexo-theme-next。 下载：推荐去官方看最新下载。 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 设置主要是在theme/next/_config.yml文件。然后去找官方或者别人的方案修改即可。 发布文章 使用命令：1$ hexo new test 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 直接将写好的markdown文件放在_posts文件下面即可，在markdown下添加头部 1234---title: categories: []--- 使用命令查看效果 12$ hexo g$ hexo s 主题美化主题美化借鉴了一些前人的集思广益，参考了网上许多文章教程，本博客就是实践出来的，感谢！ 这里mark一些借鉴连接，供大家详参！ Hexo主题美化 干货 Hexo官网]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android存储]]></title>
    <url>%2F2018%2F10%2F22%2FAndroid%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[Android存储路径先来看一张大图： 内部存储 Environment.getDataDirectory().getParentFile();也就是根目录，一般就是指/data/data目录下的数据，需要root之后可以看见 /data/app 该文件存放着系统中安装的第三方应用apk Android的应用安装就是将应用安装包拷贝到/data/app目录下面，每个包本质是一个zip压缩文件。为了提升启动效率，Android会将解压的dex提取出来，缓存在/data/dalvik-cache目录下 api 路径 getDataDirectory() /data getDownloadCacheDirectory() /cache getRootDirectory() /system /data/data 该文件夹存放存储包==私有数据==，对于设备中每一个安装的App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除data/data目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类： 地址 说明 api data/data/包名/cache 存放缓存信息 context.getCacheDir() data/data/包名/database APP数据库信息 context.getDataDir() / context.getDatabasePath(name) data/data/包名/files 存放APP的文件信息 context.getFilesDir() 外部存储每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。 获取外部存储路径及状态 Environment.getExternalStorageState() Environment.getExternalStorageDirectory() 公共目录 Android在外部存储上提供了十个公共目录来存储对应的文件，通过api：Environment.getExternalStoragePublicDirectory(type)来访问 名称 地址 DIRECTORY_MUSIC /storage/emulated/0/Music DIRECTORY_PODCASTS /storage/emulated/0/Podcasts DIRECTORY_RINGTONES /storage/emulated/0/Ringtones DIRECTORY_ALARMS /storage/emulated/0/Alarms DIRECTORY_NOTIFICATIONS /storage/emulated/0/Notifications DIRECTORY_PICTURES /storage/emulated/0/Pictures DIRECTORY_MOVIES /storage/emulated/0/Movies DIRECTORY_DOWNLOADS /storage/emulated/0/Downloads DIRECTORY_DCIM /storage/emulated/0/Dcim DIRECTORY_DOCUMENTS /storage/emulated/0/Documents 3. 私有目录 Android2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。==与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。====和内部存储一样，会在 SD 卡的 Android/data ++目录下生成对应包名的文件夹++== 地址 api /storage/emulated/0/Android/data/应用包名/files context.getExternalFilesDir(type) /storage/emulated/0/Android/data/应用包名/cache context.getExternalCacheDir() /storage/emulated/0/Android/obb/应用包名 context.getObbDir() Android其它目录 /system/app 和 /data/app 的区别 /data/app 里软件权限没全开，/system/app 里的软件获取了所有权限 /data/app 可以应用卸载，/system/app 只能 root 后删除 /data/app 文件夹大小随便，/system/app 文件夹有大小限制 卸载/system/app 目录下的文件并不会增加系统空间，即可用 ROM 空间]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维的误区-幸存者偏见]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%80%9D%E7%BB%B4%E7%9A%84%E8%AF%AF%E5%8C%BA-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81%20%2F</url>
    <content type="text"><![CDATA[何为“幸存者偏见” “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。 &emsp;&emsp;&emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下： 有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？ 不同领域中的“幸存者偏见”西赛罗的那个故事，属于宗教领域的“幸存者偏见”。除了宗教领域，还有很多领域（甚至可以说，所有的领域）都会存在这类偏见。下面，俺挑选几个领域来举例。 IT 领域——创业的“银弹” &emsp;&emsp;&emsp;作为 IT 从业人员，俺经常在某些 IT 网站上看到某某公司的创业事迹。如果你也跟俺一样，估计这方面的故事也看了不少。 &emsp;&emsp;&emsp;不知你有没有发现，那些广为流传的创业案例，都是【成功】案例。越成功的，越具有传奇色彩，被宣传的次数就越多（比如乔布斯、盖茨）。相反，那些创业【失败】的案例，（相比而言）被提及的次数非常非常少。 &emsp;&emsp;&emsp;这会产生啥问题捏？ &emsp;&emsp;&emsp;假设某个有志青年想要创业，他看了很多创业成功的案例，这些案例都提到某些共同的因素。于是捏，此人就误以为这些共同的因素是“银弹”——只要具备这些银弹，创业必定成功。这就如同西赛罗的那个故事——只看到存活的祈祷者，就误以为“祈祷”是存活的【充分条件】。 成功学领域——虚假的“充分条件” &emsp;&emsp;&emsp;说完“创业”，很自然就联想到“成功学”。那些鼓吹“成功学”的文章/书籍，通常存在很多谬误，其中一个谬误是——号称“某某方法论”是成功的【充分条件】。换句话说，只要具备了该方法论，就一定可以获得成功。 &emsp;&emsp;&emsp;为啥俺说这是一个谬误捏？因为这些鼓吹成功学的文章/书籍，通常都【没有】去检验：该方法论是否也出现在失败者身上。只要有一个失败者也采用了该方法论，就足以说明——这个方法论【不是】成功的充分条件。比如说，很多成功学的理论提到了“勤奋”是成功的充分条件。但其实捏，勤奋而没有成功的，大有人在。 投资领域——仅凭运气的“股神” 最近半年，天朝股市迎来新一轮的牛市行情。前几天有读者建议俺聊聊股市的话题，所以今天顺便拿投资领域来说事儿。似乎在每一个国家的股市中，都有那么几个人被誉为“股神”。如果碰到牛市，被冠以“股神”的人还会再多出好几倍。（暂且【不】考虑“弄虚作假、谎报战绩”的情况）假设这些获得股神称号的人，都在实际操作过程中获得远高于大盘的收益率，他们有资格获得“股神”的称号吗？为了说明这个例子，俺转载某篇文章的其中一段（此文写于1984年）。 我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。 “幸存者偏见”导致的问题 错误的认知 这个最好理解了——由于“错误的认知”会导致你对“沉默证据”的忽视，所以你对该领域的认知是不完全的。 错误的归因 在【只看到】“显式样本”的情况下，你可能会产生一些错误的归因。“幸存者偏见”导致的“错误归因”会有很多种。俺这里仅举几个例子。 因果倒置 想必大伙儿都看过举重比赛。对于举重运动员，很多人都有一个错误的观点——以为这些运动员是在练习举重之后，才导致身材变得矮壮。但实际上捏，举重队在一开始筛选运动员的时候，就把那些身材细长的忽略掉了（这些身材细长的候选人，就是“沉默的样本”）。换句话说，是因为他们身材矮壮，才有可能被选中去参加举重培训，而不是因为参加举重培训导致身材如此——这就是【因果倒置】。 牵强的归因（无中生有） 假设某个赌徒去赌场玩“押大小”（此游戏的胜负概率皆为 50%），连续赢了10次。对于大型赌场，每天来玩的人足够多，那么一段时间之后，总会出现某个赌徒玩“押大小”连续赢10次（甚至更多次）。从概率学的角度讲，这是很普通的。但是对该赌徒而言，如果他陷入了“幸存者偏见”这个误区，他就会企图给这个现象找到一个解释（进行“归因”）。假如此人是个宗教信徒，他/她可能会断言——有神明相助。这就属于“牵强的归因”——把【随机事件】看作是有其它原因，并企图在随机性之外寻找一个解释。 错误的决策 还以刚才赌徒的例子来说事儿。假设这个赌徒是宗教信徒，并且误以为自己连续赢10次是神明相助，那么他/她就会获得一种【虚假的信心】，并在这个“虚假信心”的支持下继续玩，甚至还会加大赌注/筹码。最后的结局很可能是——彻底输光。这就是“幸存者偏见”导致的“错误决策”。如果你比较喜欢琢磨，可以把这个赌场的例子替换成天朝的牛市，你会发现其中有某些相通之处。 如何对付“幸存者偏见”？ 意识到“沉默证据”的存在 这是最起码的一点——你首先要能意识到“沉默证据”的存在。这说起来容易，做起来很难——你需要形成这样一种思维习惯：每当看到“显式的证据”，你都要在内心反问：是否存在与之对应的“隐式证据”？ 找到不同类型、不同层次的“沉默证据” 在前一条的基础上，你如果能找到“沉默的证据/隐式的证据”，自然就会获得更全面的认知。有必要提醒一下：“隐式的证据”有时候不止一种类型。碰到这种情况，不是每个人都能想到所有的类型。前面提到的“天朝舆论”的例子。那些思考问题不够深入的同学，通常只意识到“网管审查/删贴”导致的“沉默证据”，而忽略了更隐蔽的“沉默证据”——那些连上网条件都没有的人，是无法在网上表达不满的。 决定一个样本会成为“隐式样本”or“显式样本”，有两种可能：情况A至少有一个原因在起作用（比如前面提到“莎草纸的例子”，气候是原因之一）情况B根本就【没有任何原因】（比如前面提到的“抛硬币的猩猩”），仅仅是随机性决定了某个样本会成为“显式” or “隐式”。对此种情况，如果你非要去找出一个原因，就会出现前面提到的“牵强的归因”。 如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。具体该如何排除捏？在本文的最后，咱们重新回到本文开头提到的那篇巴菲特演讲。在说完“猩猩抛硬币”的游戏之后，巴菲特又说了如下一段话。通过这段话，你可以借鉴一下——如何规避“随机因素”的干扰。 然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；(b)如果经过20天的竞赛，只剩下215只赢家；(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。 于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。 科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。 除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。 在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。 我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>好文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下全局翻墙]]></title>
    <url>%2F2018%2F10%2F20%2FMac%E4%B8%8B%E7%9A%84%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mac下全局翻墙 路由翻墙 ssr + .bash_profile 使用工具，类似profixer，surge等 使用iterm的，环境变量也可以使用.bash的(需要在.zsh中去设置环境变量走.bash_profile)也可以在.zshrc中 由于ss或者ssr只是支持了socks5的代理，也就是所有的都走socks5协议，而浏览器本身是支持socks5的（当然还有http，https，ftp等），但是如果你想mac上装的客户端，比如telegram也能通过ssr达到科学上网就想多了，但是这些软件，还比如AS都可以手动去设置代理的（socks5），一般ssr默认的设置如下： 123ip：127.0.0.1# http走的是1087端口port：1086 方法2设置步骤 vimb(vim .bash_profile) 修改文件（添加下面代码） source .bash_profile 验证：curl www.google.com 12345# proxyproxy=socks5://127.0.0.1:1086export http_proxy=$proxyexport https_proxy=$proxyexport ftp_proxy=$proxy 通过上面设置就能在命令行中发现已经可以科学上网了，目前还有两个蛋痛的地方没解决： profixer在mac上装不了了，一直弹窗。权限都给了 使用Google Drive同步文件用不了，只有将ssr设置全局才可以，MD。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云集成IM]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1IM%E9%9B%86%E6%88%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面 集成集成其实很简单，网易提供了两种方式，jar和gradle，毫无疑问gradle 12345678// 基础功能 (必需)netease_basesdk : &apos;com.netease.nimlib:basesdk:5.1.1&apos;,// 音视频需要netease_avchat : &apos;com.netease.nimlib:avchat:5.1.1&apos;,// 音视频需要netease_nrtc : &apos;com.netease.nimlib:nrtc:5.1.1&apos;,// 全文检索服务需要netease_lucene : &apos;com.netease.nimlib:lucene:5.1.1&apos;, 其中第一个是早就集成了的，自带IM功能，第二第三则是音视频需要的，第四个是需要做聊天记录搜索要用到的 APPID申请 权限 初始化 前两个看官方文档就可以了，初始化一般就是在主APP的Aplication中进行，代码如下 1234567891011// 注册通知消息过滤器registerIMMessageFilter();// 初始化消息提醒NIMClient.toggleNotification(true);// 注册网络通话来电enableAVChat();//初始化IM UI组件NimUIKit.init(this); 官方文档和demo中也有说明，需要使用到哪种能力就去初始化哪些，比如该版本还用到了IM的自定义消息，那么也必须在这里进行注册 注意：以上的初始化只能在主线程中进行，为此，云信提供了一个API：NIMUtil.isMainProcess(this) 123NIMClient.getService(MsgService.class).registerCustomAttachmentParser(new CustomAttachParse()); NimUIKit.registerMsgItemViewHolder(DiagnosisMsg.class, MsgViewHolderDiagnosis.class); IM消息监听 123456// 注册IM消息监听 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, true);// 反注册 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, false); 相关概念 注册登陆：集成网易云后，需要将本地用户与网易云id关联，每一个用户在网易云有一个唯一的accid和token，对于登陆相当于用户名及密码，对于业务比如：视频/IM则相当与电话号码，你需要和别人通信的时候必须知道对方的accid。 用户信息托管：由于本地用户在网易云有一个id关联，那么当要用到网易云的一些能力的时候，我们希望用户的一些基础信息（头像，昵称）是要与本地后端保持一致的。 消息锚点：其实就是一个消息对象，它携带了一些时间或者其他信息，方便搜索。 上面两点都是本地后端处理的，前段需要处理的则是，在登陆系统成功后，需要手动调用网易登陆api去帮助用户登陆到网易云，并且监听用户的登陆状态。 123456789101112131415161718192021222324252627282930313233public void nimLogin(User user) &#123; LoginInfo info = new LoginInfo(user.accid, user.token); // config... RequestCallback&lt;LoginInfo&gt; callback = new RequestCallback&lt;LoginInfo&gt;() &#123; @Override public void onSuccess(LoginInfo param) &#123; Logger.d(&quot;login nim success&quot;); &#125; @Override public void onFailed(int code) &#123; Logger.d(&quot;login nim failed :&quot; + code); &#125; @Override public void onException(Throwable exception) &#123; Logger.e(exception, &quot;login nim failed&quot;); &#125; &#125;; AbortableFuture&lt;LoginInfo&gt; request = NIMClient.getService(AuthService.class).login(info); request.setCallback(callback); &#125; @Override public void observeNimOnlineStatus(User user) &#123; NIMClient.getService(AuthServiceObserver.class).observeOnlineStatus( (Observer&lt;StatusCode&gt;) status -&gt; &#123; Log.i(&quot;nim&quot;, &quot;User status changed to: &quot; + status); if (status.shouldReLogin()) &#123; new Handler().postDelayed(() -&gt; nimLogin(user), 5000); &#125; &#125;, true); &#125; IM相关界面由于lib_neteaseui库提供了界面能力，所以自然自定义界面的话需要集成他的界面，这里有两种方式 集成现有类（比如p2pmessage）,只需要修改layout，并且传递需要的参数即可。 继承SDK中的UI并实现ModuleProxy代理类中方法 开启单聊很简单直接看代码 1IMMessageActivity.start(getContext(), entity.accid, customization, null, IMMessageActivity.class); 其中，entity.accid代表了对方的号码。 消息面板设置 面板类：MessageListPanelEx，这里面封装了发送消息面板的所有功能 抽屉：基类BaseAction，比如拍照，相片或者自定义类型都是通过这个基类来实现的。 IM面板layout：nim_message_activity_text_layout 设置用户托管信息： 12// 设置网易云用户资料（IM中的头像，昵称等）NimUserManager.setUserBasicInfo(user.patientName,user.imgUrl); 消息设置 消息屏蔽： 1234//屏蔽所有消息NIMClient.toggleNotification(false);//屏蔽某个用户消息NIMClinet.getService(FriendService.class).setMessageNotify(account,checkState) 消息接收 12345678910/** * IM消息监听 */ com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt; messageObserver = new com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt;() &#123; @Override public void onEvent(List&lt;IMMessage&gt; imMessages) &#123; Logger.d(&quot;im message received&quot;); &#125; &#125;; 自定义消息 自定义消息比较复杂，参见代码。具体步骤如下： 定义消息 1234567/** * 需要多端统一 */public interface CustomAttachmentType &#123; int diagnosisMsg = 1001;&#125; 自定义消息的基础类 1234567891011121314151617181920public abstract class CustomAttachment implements MsgAttachment &#123; protected int type; CustomAttachment(int type) &#123; this.type = type; &#125; public void fromJson(JsonObject data) &#123; if (data != null) &#123; parseData(data); &#125; &#125; @Override public String toJson(boolean send) &#123; return CustomAttachParse.packData(type, packData()); &#125; public int getType() &#123; return type; &#125; protected abstract void parseData(JsonObject data); protected abstract JsonObject packData();&#125; 自定义消息结构类（用于组装自定义数据） 1public class DiagnosisMsg extends CustomAttachment 自定义消息解析类（用于显示自定义消息） 1public class CustomAttachParse implements MsgAttachmentParser 参见官方文档 其他 注册账号accid网易云强制小写 网易云消息从后端还是本地拉取 1messageListPanel = new MessageListPanelEx(container, rootView, anchor, false, remote); 其中最后一个参数remote = true表示从云端拉取数据 IM聊天点击头像事件layout：MsgAdapter中layout.nim_message_item 点击事件：NimUIKitImpl.setSessionListener]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的常用命令行]]></title>
    <url>%2F2018%2F10%2F19%2FMac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看IP123$curl ip.gs$ifconfig 关于文件操作由于mac下面不能使用右键新建文件，所以需要使用一些工具，如workflow，或者直接命令行 123456789101112# 查看文件如果没有则创建新文件touch filename# 新建文件夹mkdir filename# 删除文件或者目录rm -rf filename# 查看文件详细信息stat filename# 查看目录结果，需要装treenpm install treetree -L 1 vim常规操作 操作命令 效果 i 在光标处插入，进入编辑模式 dd 剪切光标所在的一行内容 yy 复制光标所在的一行内容 D 删除光标右边的所有内容 gg 将光标快速移动到文件首 G 将光标快速移动到文件尾 0 将光标快速移动到行首 $ 将光标快速移动到行尾 退出命令 效果 :w 保存 :q 未保存直接退出（如果没有修改，用下面的命令） :q！ 强制退出 :wq 保存退出 :wq 强制保存退出]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用心得]]></title>
    <url>%2F2018%2F10%2F18%2Fgit%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1. 具体1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用1git reset HEAD &lt;file&gt; 将某个文件从暂存区拿出来。 2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用1git reset -soft/--mix/--hard &lt;commite id&gt; 会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。12# 查询所有git的提交记录，包括详细commite idgit reflog 2. git add语法 语法 描述 git add -A stages All git add . stages new and modified, without deleted git add -u stages modified and deleted, without new 3. git merge合并现在最简单的merge模式就是fast-farward merge了，就是从master拉出的分支develop后，master没有再做任何修改，所有的代码都在develop分支上提交，等到最后要合并develop到master上时，可以使用如下命令： 1234# 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop 4. git tag打标签标签可以针对某一时间点的版本做标记，常用于版本发布。 1.列出标签 1234# 在控制台打印出当前仓库的所有标签git tag# 搜索符合模式的标签git tag -l ‘v0.1.*’ 2.打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。 123456# 创建轻量标签git tag v0.1.2-light# 创建附注标签git tag -a v0.1.2 -m &quot;0.1.2版本&quot;# 针对某个提交打标签git tag v1.0 &lt;commite id&gt; 3.切换标签 1git show v0.1.2 4.删除标签 1234# 删除本地标签git tag -d v0.1.2# 删除远程标签git push origin --delete tag v1.0 5.标签发布 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： 1234# 将v0.1.2标签提交到git服务器git push origin v0.1.2# 将本地所有标签一次性提交到git服务器git push origin –tags 5. git stash该命令用来保存当前分支上还没commite的修改，使当前分支保持clean状态（git status） 使用场景:执行git stash后，你在dev分支没有提交的修改暂时被“藏”了起来，看起来dev分支是干净的。但是，请一定注意，你还在dev分支！因为你需要切换到master分支去修改bug，因此此时需要切换到master分支（如果不执行git stash就切换到master分支是不行的：git会报告当前dev分支还存在未提交的修改，比如先提交才允许你切换分支，而出于各种原因，你还不能现在提交dev分支的内容（一般也就先提交了，大不了再切回来改就是哦），这就是git stash存在的价值）。 切换到stash分支后的恢复命令12345678# 恢复并删除stash内容git stash pop# 查看现场git stash list# 保存现场git stash 6. git分支管理 master:主分支，当前分支上的代码随时可以直接发布，并且只能通过Pull Request从其他分支进行合并，而不能直接push修改。当开发告一段落，产生了新的可供发布的代码时，master分支通过Pull Request更新了代码，同时，每一次更新必须添加对应版本号的标签TAG。 develop:开发分支，保存当前最新开发成果的分支，即当一个新功能开发完毕需要先合并到develop分支，这个分支的代码会进行每日的代码持续集成(Daily Build)。所有的开发任务都是从这个分支Checkout新的特性分支进行开发。 feature:特性分支，当开发新的功能时，从develop分支Checkout新的feature分支，这个分支的代码最终要合并回develop分支或者废弃掉(例如预研功能效果不好时)。feature分支最好以功能为单位。 hotfix:紧急修复分支，唯一从master分支派生的分支，当生产环境中发现了异常或者缺陷的时候，从master分支上指定的TAG版本Checkout hotfix分支进行紧急修复工作，当修复完成之后，必须同时合并到master分支和develop分支。合并完代码之后删除hotfix分支。 新建分支(已feature为例) 12345678# 切换本地分支到develop分支git checkout develop# 拉取远程Git仓库中的最新的develop分支的代码git pull# 创建本地特性分支featuregit checkout -b feature# 推送本地特性分支到远程Git仓库（即创建远程特性分支），-u为追踪远程分支git push -u origin feature 已feature分支为例开发合并全流程 12345# 开发代码。以下两步的作用是保证你本地的feature分支的代码为最新，因为有可能你是和别人合作开发的该功能，如果你刚更新过或者你是一个人在开发则可以省略此操作# 切换到本地feature分支git checkout feature# 拉取远程分支代码，--rebase最好加上git pull --rebase 123456789# 合并代码# 切换到本地develop分支git checkout develop# 拉取最新的远程origin/develop分支代码，因为可能已经有人提交了代码git pull --rebase# 从本地feature-login分支合并代码，--no-ff为禁止fast-farward模式git merge --no-ff feature-login# 推送到远程分支git push 1234567# 代码已经合并完，可以删除本地特性分支和远程特性分支# 删除本地feature-login特性分支git branch -d feature-login# 删除远程origin/feature-login特性分支（废除，实验无效）git branch -r -d origin/feature-login#在v1.7.0 之后，可以使用这种语法删除远程分支(同删除标签tag类似)git push origin --delete &lt;branch name&gt; 7.git pushpush到远程分支有https和ssh两种方式，https每次push都会要求输入用户名和密码，而ssh只要在远端注册了ssh key则不需要。另外，ssh可以上传大文件，https貌似不行。12# 这个会把本地当前分支的内容push到远端的demo分支，如果远端没有该分支则自动创建git push -u origin demo 1234# 生成ssh key,该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：ssh-keygen# 可以查看远程分支情况git remote -v 8.git reset第一小节有类似操作。 本地代码回滚 1234# 回滚到commit-id，讲commit-id之后提交的commit都去除git reset --hard commit-id# 将最近3次的提交回滚git reset --hard HEAD~3 远程代码回滚。应用场景：app已经发布了，发现有问题需要回滚到某个commit，再重新发布。这时需要先将本地分支退回到某个commit，删除远程分支，再重新push本地分支。操作步骤（还没检验） 1234567891011121314# 1git checkout the_branch# 2git pull# 3 备份一下这个分支当前的情况(本地新建分支？)git branch the_branch_backup# 4 把the_branch本地回滚到the_commit_idgit reset --hard the_commit_id# 5 删除远程 the_branch（可以删除远程分支）git push origin :the_branch# 6 用回滚后的本地分支重新建立远程分支git push origin the_branch# 7 如果前面都成功了，删除这个备份分支git push origin :the_branch_backup 9.git remote多源操作，一般是一个源，但是多源也很有用1234567891011121314151617# 如果想关联另一个远端仓库（加一个源）git remote add &lt;origin name&gt; git@gitlab.com:demo/demo.git# 显示全部源git remote / git remote -v# renamegit remote rename &lt;origin name&gt; &lt;origin new name&gt;# deletedgit remote rm &lt;origin name&gt;# 查看指定源的全部信息git remote show &lt;origin name&gt;# 修改远程仓库地址git remote set-url origin &lt;origin url&gt; 10.git commit合并某个分支上的某个commit或者多个commit到master分支上123dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature] 比如，feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做： 123# 示例git checkout mastergit cherry-pick 62ecb3 在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。(未实验，要实验一下) 1234# 首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：git checkout -bnewbranch 62ecb3# 然后，rebase这个新分支的commit到master（--ontomaster）。76cada^ 指明你想从哪个特定的commit开始。git rebase --ontomaster 76cada^ 11.git rebase12345678910111213```### 12.git detached HEAD在一些情况下，会出现detached HEAD的情况，（后面分析下原因）。detached head即游离的HEAD，HEAD指向了未知的分支，即不在所有已知的分支范围内。解决办法：```git$ git branch* (HEAD detached at origin/master) dev master HEAD指向了一个未知的分支，可用git checkout -b基于当前分支创建一个新的临时分支保留代码，合并到合适的分支后删除12345678910111213$ git checkout -b tempSwitched to a new branch &apos;temp&apos;$ git branch dev master* temp$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.$ git merge tempAlready up-to-date.$ git branch -d tempDeleted branch temp (was 3e74a7a).]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
</search>
