<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊一聊LRU算法及LinkedHashMap]]></title>
    <url>%2F2020%2F07%2F23%2F%E8%81%8A%E8%81%8AHashMap%2F</url>
    <content type="text"><![CDATA[概述以前聊过HashMap的数据结构，其实就是一个数组+链表Android内存优化。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。 LinkedHashMap的数据结构LinkedHashMap是Map接口的哈希表和双向链表实现，继承了HashMap，其基本操作与父类相似，采用的Hash算法和HashMap一样。其实其数据结构基本和HashMap是一样的，只是Entry不一样，除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链表列表。HashMap的Entry是： 1234final K key;V value;final int hash;HashMapEntry&lt;K, V&gt; next; 而LinkedHashMap的Entry则多了before和after： 123456final K key;V value;final int hash;HashMapEntry&lt;K, V&gt; next;Entry&lt;K, V&gt; before; //上一个元素的引用Entry&lt;K, V&gt; after; //下一个元素的引用 next指针是每一个数组后面的链表，而before和after则是整个LinkedHashMap的元素顺序，看图可能更好理解： 正是由于拥有before和after指针，所以LinkedHashMap是有序的而HashMap是无序的 使用场景先来看例子：HashMap是无序的，而LinkedHashMap是有顺序的 123456789101112Map&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;();hashMap.put("name1", "josan1");hashMap.put("name2", "josan2");hashMap.put("name3", "josan3");Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();while(iterator.hasNext()) &#123; Entry entry = iterator.next(); String key = (String) entry.getKey(); String value = (String) entry.getValue(); System.out.println("key:" + key + ",value:" + value);&#125; 自己可以打印输出结果看到，它不是按照put顺序的，同样的数据我们换成LinkedHashMap 123456789101112Map&lt;String, String&gt; hashMap = new LinkedHashMap&lt;String, String&gt;();hashMap.put("name1", "josan1");hashMap.put("name2", "josan2");hashMap.put("name3", "josan3");Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();while(iterator.hasNext()) &#123; Entry entry = iterator.next(); String key = (String) entry.getKey(); String value = (String) entry.getValue(); System.out.println("key:" + key + ",value:" + value);&#125; 打印结果完全和put顺序一致。key：name1，value：josan1key：name2，value：josan2key：name3，value：josan3 以上只是LinkedHashMap其中一种双向链表的存储顺序特性：插入顺序(输出完全和插入顺序保持一致)，并且这个为LinkedHashMap的默认顺序。通过默认构造方法实现：1Map&lt;String, String&gt; hashMap = new LinkedHashMap&lt;String, String&gt;(); 我们看下同样的数据，换一种写法：1234567891011121314Map&lt;String, String&gt; hashMap = new LinkedHashMap&lt;String, String&gt;(16,0.5f,true);hashMap.put("name1", "josan1");hashMap.put("name2", "josan2");hashMap.put("name3", "josan3");hashMap.get("name1")Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();while(iterator.hasNext()) &#123; Entry entry = iterator.next(); String key = (String) entry.getKey(); String value = (String) entry.getValue(); System.out.println("key:" + key + ",value:" + value);&#125; 多了一行代码，先get了一个元素打印结果:key：name2，value：josan2key：name3，value：josan3key：name1，value：josan1 这就是LinkedMap另一种牛逼的存储特性叫：访问顺序 其通过带参数的构造方法实现： 1Map&lt;String, String&gt; hashMap = new LinkedHashMap&lt;String, String&gt;(16,0.5f,true); LinkedHashMap的实现 成员变量 来看下源码：12345678910111213141516171819/*** The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。（默认为false）*/private final boolean accessOrder;/*** 双向链表的表头元素。 */private transient Entry&lt;K,V&gt; header;/*** LinkedHashMap的Entry元素。* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 */private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; ……&#125; 构造方法 1234public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)&#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 从源码可以看出，在LinkedHashMap的构造方法中，实际调用了HashMap的相关构造方法来构造一个底层存放的table数组。（如果没有指定initialCapacity的大小，系统默认是1&lt;&lt;4也就是16），这里需要注意的是accessOrder参数，如果不设置默认为false，代表按照插入顺序迭代，如果为true，则代表可以按照访问顺序进行迭代。（访问顺序迭代这个特性可以用在LRU算法中，这个后面单独弄一期）。 初始化 这一块很多分析源码的都说有init方法，但是看了下发现没找到这个方法，先暂存 存储（PUT） LinkedHashMap并没有重现父类的put的方法， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 但是重写了当key存在时的afterNodeAccess方法，这个方法在HashMap中是一个空方法，这个操作就是把节点移动到最后（看这个参数accessOrder），实现访问顺序： 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMapEntry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; 读取 LinkedHashMap 重写了父类 HashMap 的 get 方法。 1234567891011121314151617181920212223/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. */ public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value; &#125; 总结LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。 这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个 LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用带参数的构造方法。 该哈希映射的迭代顺序就是最后访问其条目的顺序，这种特性很适合构建 LRU 缓存。LinkedHashMap 提供了 removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) 方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。 参考LinkedHashMap 的实现原理 图解LinkedHashMap原理 HashMap 最新底层原理分析]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技能提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtomicBoolean详解]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%9F%BA%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84AtomicBoolean%2F</url>
    <content type="text"><![CDATA[背景java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。 CAS思想先看下AtomicBoolean的用法： 1boolean compareAndSet(expectedValue, updateValue); 我们看到了上面提到的一个在java并发中非常重要的一类算法：CAS：compare And set比较设置。我们用上面方法为例来解释下CAS的思想。当内存中可见的值如果和期望的值（expectedValue）一致，则将内存中的值修改为新值（updateValue），并且返回true。该操作是原子性的，意思是线程安全的。当多个线程同时访问某个对象时，如果其中一个线程通过CAS操作获得了访问权限，则其他线程只能在该线程处理完之后才能访问。这类似于同步关键字synchronized但是效率更高，因为没有锁的机制，即使在JDK7之后进行过优化。下面会举例子说明，在多线程中这种原子操作的必要性。例子： 12345678910111213141516171819202122232425262728293031323334353637383940private static volatile AtomicBoolean aFlag = new AtomicBoolean(true); private static Boolean bFlag = true; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); AtomicDemo demo = new AtomicDemo(); for(int i = 0 ;i &lt; 10 ;i++) &#123; es.submit(new Runnable() &#123; @Override public void run() &#123; //demo.executeAtomicLogic(); demo.executeLogic(); &#125; &#125;); &#125; &#125; public void executeLogic() &#123; //synchronized (this) &#123; if (bFlag) &#123; try &#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑开始..."); Thread.sleep(5000); System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑完毕."); &#125; catch (Exception e) &#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑失败!!!"); &#125; finally &#123; bFlag = !bFlag; &#125; &#125; else &#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--已经存在处理中的业务，请稍后再试!"); &#125; &#125; //&#125; 上面代码是用一个boolea值来简单判断其它线程是否能进入业务代码执行，我们想看到的是线程1执行完后才能执行线程2，我们来看下结果： 可以看到这个结果是相当混乱，所有线程都抢占了资源。我们再看下使用了AtomicBoolean来看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AtomicDemo &#123; private static volatile AtomicBoolean aFlag = new AtomicBoolean(true); private static Boolean bFlag = true; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); AtomicDemo demo = new AtomicDemo(); for(int i = 0 ;i &lt; 10 ;i++) &#123; es.submit(new Runnable() &#123; @Override public void run() &#123; demo.executeAtomicLogic(); //demo.executeLogic(); &#125; &#125;); &#125; &#125; public void executeAtomicLogic() &#123; if (aFlag.compareAndSet(true, false)) &#123; try&#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑开始..."); Thread.sleep(5000); System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑完毕."); &#125;catch(Exception e)&#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--处理业务逻辑失败!!!"); &#125;finally&#123; aFlag.set(true); &#125; &#125; else &#123; System.out.println(LocalDate.now() + " " + LocalTime.now() + "--" + Thread.currentThread().getName() + "--已经存在处理中的业务，请稍后再试!"); &#125; &#125;&#125; 结果： 和加锁的效果完全一样。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java并发，能力提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八一八强引用、软引用、弱引用、虚引用]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%85%AB%E4%B8%80%E5%85%AB%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景我们都知道JVM的垃圾回收机制中，GC判断堆中的对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。 引用先说说引用，Java中的引用，类似C语言中的指针。都知道Java分为基本类型和引用类型。有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的。JAVA中一切皆对象，无论你是直接操作对象本身，还是通过指向对象的引用来间接操作对象，都是采用统一的一种方法。 在 JDK 1.2 之前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 refrence 数据是代表某块内存、某个对象的引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。比如我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为： 强引用（Strong Reference） 软引用（Soft Reference） 弱引用（Weak Reference） 虚引用（Phantom Reference）这四种引用强度依次逐渐减弱，Java中引入这四种引用的目的是让程序自己决定对象的生命周期，JVM通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。其中FinalReference类是包内可见，其它三种引用类型均为public，可以在应用程序中直接使用。 强引用在Java中最常见的就是强引用，就是直接new出来的对象都是强引用，例如： 12// person就是一个强引用Person person = new Person（） 当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收器回收的，即使该对象用用不会被用到也不会被回收。当内存不足，JVM开始垃圾回收，对于强引用的对象，就算出现了OOM也不会对该对象进行回收，因此强引用有时也是造成Java内存泄漏的原因之一。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为null，一般就认为是可以被GC回收的。 12345678910public class StrongRefenenceDemo &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = o1; o1 = null; System.gc(); System.out.println(o1); //null System.out.println(o2); //java.lang.Object@2503dbd3 &#125;&#125; 这里尽管o1已经被回收了，但是o2强引用了o1，所以不会被GC回收。o1指向的内存为null，但是o2指向的原来o1的内存对象是不会被回收的。 软引用软引用是一种相对强引用弱化了一些的引用。它用来描述一些还有用，但是并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。 对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。看例子： 12345678910111213141516171819202122232425262728293031323334353637public class JavaReference &#123; public static void main(String[] args) &#123; softRefMemoryEnough(); System.out.println("------内存不够用的情况------"); softRefMemoryNotEnough(); &#125; private static void softRefMemoryEnough() &#123; Object o1 = new Object(); SoftReference s1 = new SoftReference(o1); System.out.println(o1); System.out.println(s1.get()); o1 = null; System.gc(); System.out.println(o1); System.out.println(s1.get());//不会被回收 &#125; /** * JVM配置`-Xms5m -Xmx5m` ，然后故意new一个一个大对象，使内存不足产生 OOM，看软引用回收情况 */ private static void softRefMemoryNotEnough() &#123; Object o1 = new Object(); SoftReference s1 = new SoftReference(o1); System.out.println(o1); System.out.println(s1.get()); o1 = null; byte[] bytes = new byte[10 * 1024 * 1024]; System.out.println(o1); System.out.println(s1.get()); //会被回收 &#125;&#125; 软引用通常在对内存敏感的程序中，比如告诉缓存就有用到软引用，内存够用的时候就保留，不够用就回收。Android中图片库Glide就是用到软引用，还比如Mybatis缓存类SoftCache用到软引用 123456789101112131415161718public Object getObject(Object key) &#123; Object result = null; SoftReference softReference = (SoftReference)this.delegate.getObject(key); if (softReference != null) &#123; result = softReference.get(); if (result == null) &#123; this.delegate.removeObject(key); &#125; else &#123; synchronized(this.hardLinksToAvoidGarbageCollection) &#123; this.hardLinksToAvoidGarbageCollection.addFirst(result); if (this.hardLinksToAvoidGarbageCollection.size() &gt; this.numberOfHardLinks) &#123; this.hardLinksToAvoidGarbageCollection.removeLast(); &#125; &#125; &#125; &#125; return result;&#125; 弱引用弱引用也是用来描述非必需对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。弱引用需要用WeakReference类来实现，它比软引用的生存周期更短。 12345678910private static void weakRefDemo() &#123; Object o1 = new Object(); WeakReference w1 = new WeakReference(o1); System.out.println(o1); System.out.println(w1.get()); o1 = null; System.gc(); System.out.println(o1); //被回收 System.out.println(w1.get());//被回收 &#125; 官方文档说弱引用常被用来实现规范化映射，JDK中的WeakHashMap就是一个这样的例子（ThreadLocal中也用到弱引用） 1234567891011121314151617181920212223242526public static void myHashMap() &#123; HashMap map = new HashMap(); String key = new String("k1"); String value = "v1"; map.put(key, value); System.out.println(map); key = null; System.gc(); System.out.println(map);//不会被回收 &#125; public static void myWeakHashMap() throws InterruptedException &#123; WeakHashMap map = new WeakHashMap(); //String key = "weak"; //key指向一个JVM字符串常量池中的"weak"字符串 // 刚开始写成了上边的代码 //思考一下，写成上边那样会怎么样？ 那可不是引用了 String key = new String("weak"); String value = "map"; map.put(key, value); System.out.println(map); //去掉强引用 key = null; System.gc(); Thread.sleep(1000); System.out.println(map);//被回收，因为只被一个弱引用引用（WeakHashMap的原理） &#125; 虚引用虚引用也称为“幽灵引用”，是一种最弱的引用关系。顾名思义，就是形同虚设，与其它集中引用不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。如果一个对象仅持有虚引用，那么它就和没有任务引用一样，在任何时候都可能被GC回收，它不能单独使用也不能通过它来访问对象，虚引用必须和引用队列（RefenenceQueue）联合使用。虚引用主要作用是跟踪对象垃圾回收的状态，仅仅是提供一种确保对象finalize后可以做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。 设置虚引用的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理。 Java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 123456789101112131415161718/** * 虚引用 */private static void phantomRefDemo() throws InterruptedException &#123; Object o1 = new Object(); ReferenceQueue referenceQueue = new ReferenceQueue(); PhantomReference phantomReference = new PhantomReference(o1,referenceQueue); System.out.println(o1); System.out.println(referenceQueue.poll()); System.out.println(phantomReference.get()); o1 = null; System.gc(); Thread.sleep(3000); System.out.println(o1); System.out.println(referenceQueue.poll()); //引用队列中 System.out.println(phantomReference.get());&#125; 引用队列ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。SoftReference,WeakReference,PhantomReference都有一个可以传递ReferenceQueue的构造器。创建引用的时候，可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技能提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin内联函数]]></title>
    <url>%2F2020%2F05%2F30%2FKotlin%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Kotlin中内联函数的理解kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。即那些在函数体内会访问到的变量。内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。 调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针移出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。 来看一个官方的例子： 12345678fun &lt;T&gt; lock(l: Lock, body: () -&gt; T): T &#123; l.lock() try &#123; return body() &#125; finally &#123; l.unlock() &#125; &#125; 调用这个方法： 1lock(l, &#123;"do something!"&#125;)//l是一个Lock对象 对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果只要函数体类似这样： 123456l.lock()try &#123; return "do something!"&#125; finally &#123; l.unlock()&#125; 这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制大量重复代码，那么有没有一种机制，又能少些重复代码（变成一个可供调用的方法）又不会在调用过程中频繁压栈出栈影响性能呢。有的，这就是kotlin的内联函数inline所拥有的能力。 inline使用inline声明的函数，会在编译时将会拷贝到调用的地方。 inline function定义一个sum函数计算两个数的和 1234567fun main(args: Array&lt;String&gt;) &#123; println(sum(1, 2))&#125;fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 反编译为Java代码看看 12345678public static final void main(@NotNull String[] args) &#123; int var1 = sum(1, 2); System.out.println(var1);&#125;public static final int sum(int a, int b) &#123; return a + b;&#125; 正常的样子，在该调用的地方调用函数。 然后为sum函数添加inline声明： 12345678public static final void main(@NotNull String[] args) &#123; int var1 = sum(1, 2); System.out.println(var1);&#125;public static final inline sum(int a, int b) &#123; return a + b;&#125; 再反编译为Java代码： 1234567891011public static final void main(@NotNull String[] args) &#123; //... byte a$iv = 1; int b$iv = 2; int var4 = a$iv + b$iv; System.out.println(var4);&#125;public static final int sum(int a, int b) &#123; return a + b;&#125; 可以看到sum函数的实现代码被直接拷贝到了调用的地方。上面的例子其实并没有体现inline的优势，因为拷贝代码和在调用的地方调用方法没有本质区别，但是如果你的函数中有lambda形参数，或者是参数为函数的时候，inline的优势才会体现（因为不会新建函数对象，可以减少内存损耗）。 inline function with lambda parameters再来看一个例子： 123456789fun sum(a: Int, b: Int, lambda: (result: Int) -&gt; Unit): Int &#123; //sum方法中有一个函数参数 val r = a + b lambda.invoke(r) return r&#125;fun main(args: Array&lt;String&gt;) &#123; sum(1, 2) &#123; println("Result is: $it") &#125;&#125; 反编译为java： 1234567891011public static final int sum(int a, int b, @NotNull Function1 lambda) &#123; //... int r = a + b; lambda.invoke(r); return r;&#125;public static final void main(@NotNull String[] args) &#123; //... sum(1, 2, (Function1)null.INSTANCE);&#125; (Function1）null.INSTANCE，是由于反编译器工具在找不到等效的 Java 类时的显示的结果。 我们传递的那个lambda被转换为了Function1类型，它是Kotlin函数的一部分，它以1结尾是因为我们在lambda函数中传递了一个参数。 再来看一个代码： 12345fun main(args: Array&lt;String&gt;) &#123; for (i in 0..10) &#123; sum(1, 2) &#123; println("Result is: $it") &#125; &#125;&#125; 我们在循环中调用sum函数，每次都传递一个lambda函数打印结果，反编译为java： 123for(byte var2 = 10; var1 &lt;= var2; ++var1) &#123; sum(1, 2, (Function1)null.INSTANCE);&#125; 可见在每次循环里面都会创建一个Function1的实例对象，这里就是性能的优化点所在，如何优化呢？ 在循环外部建立lambda对象 12345val l: (r: Int) -&gt; Unit = &#123; println(it) &#125;for (i in 0..10) &#123; sum(1, 2, l)&#125; 反编译为java 123456Function1 l = (Function1)null.INSTANCE;int var2 = 0;for(byte var3 = 10; var2 &lt;= var3; ++var2) &#123; sum(1, 2, l);&#125; 只会创建一个Function对象，优化了原来在循环内部不停创建对象。 使用inline 1234567891011fun main(args: Array&lt;String&gt;) &#123; for (i in 0..10) &#123; sum(1, 2) &#123; println("Result is: $it") &#125; &#125;&#125;inline fun sum(a: Int, b: Int, lambda: (result: Int) -&gt; Unit): Int &#123; val r = a + b lambda.invoke(r) return r&#125; 反编译java 123456789101112public static final void main(@NotNull String[] args) &#123; //... int var1 = 0; for(byte var2 = 10; var1 &lt;= var2; ++var1) &#123; byte a$iv = 1; int b$iv = 2; int r$iv = a$iv + b$iv; String var9 = "Result is: " + r$iv; System.out.println(var9); &#125;&#125; lambda函数对象在编译的时候被拷贝到了调用的地方，避免了创建Fuction对象 inline使用注意事项 public inline函数不能访问私有属性 1234567891011class Demo(private val title: String) &#123; inline fun test(l: () -&gt; Unit) &#123; println("Title: $title") // 编译错误: Public-Api inline function cannot access non-Public-Api prive final val title &#125; // 私有的没问题 private inline fun test(l: () -&gt; Unit) &#123; println("Title: $title") &#125;&#125; 注意程序控制流程 当使用inline的时候，如果传递给inline函数的lambda，有return语句，那么会导致闭包的调用者也返回。 看个例子： 1234567891011121314inline fun sum(a: Int, b: Int, lambda: (result: Int) -&gt; Unit): Int &#123; val r = a + b lambda.invoke(r) return r&#125;fun main(args: Array&lt;String&gt;) &#123; println("Start") sum(1, 2) &#123; println("Result is: $it") return // 这个会导致 main 函数 return &#125; println("Done")//不会被执行&#125; 反编译java 123456789public static final void main(@NotNull String[] args) &#123; String var1 = "Start"; System.out.println(var1); byte a$iv = 1; int b$iv = 2; int r$iv = a$iv + b$iv; String var7 = "Result is: " + r$iv; System.out.println(var7);&#125; 反编译之后也能看到，lambda return之后的代码不会执行。（println（“Done”）没有执行）。怎么解决这个问题呢，不要使用return可以使用return@label语法，返回到lambda被调用的地方。 12345678fun main(args: Array&lt;String&gt;) &#123; println("Start") sum(1, 2) &#123; println("Result is: $it") return@sum &#125; println("Done")//会被执行&#125; noinline当一个inline函数中，有多个lambda函数做为参数的时候，可以在不想内联的lambda函数前使用noinline声明。不会被拷贝代码到被调用的地方。 看一个例子： 12345678910111213inline fun sum(a: Int, b: Int, lambda: (result: Int) -&gt; Unit, noinline lambda2: (result: Int) -&gt; Unit): Int &#123; val r = a + b lambda.invoke(r) lambda2.invoke(r) return r&#125;fun main(args: Array&lt;String&gt;) &#123; sum(1, 2, &#123; println("Result is: $it") &#125;, &#123; println("Invoke lambda2: $it") &#125; )&#125; 反编译为java： 12345678910111213141516public static final int sum(int a, int b, @NotNull Function1 lambda, @NotNull Function1 lambda2) &#123; int r = a + b; lambda.invoke(r); lambda2.invoke(r); return r;&#125;public static final void main(@NotNull String[] args) &#123; byte a$iv = 1; byte b$iv = 2; Function1 lambda2$iv = (Function1)null.INSTANCE;//lambda2新建了对象 int r$iv = a$iv + b$iv; String var8 = "Result is: " + r$iv; System.out.println(var8); lambda2$iv.invoke(r$iv);&#125; 从反编译代码中可以看到使用inline声明的lambda形参函数被搬到了被调用的地方，而被noinline声明的函数则生成了Function对象。 crossinline声明一个lambda函数不能有return语句（可以有return@label语句），这样可以避免使用inline时，lambda中的return影响流程导致某些语句没有执行。被crossinline声明的lambda函数如果有return语句会在编译时报错。 例子： 123456789101112inline fun sum(a: Int, b: Int, crossinline lambda: (result: Int) -&gt; Unit): Int &#123; val r = a + b lambda.invoke(r) return r&#125;fun main(args: Array&lt;String&gt;) &#123; sum(1, 2) &#123; println("Result is: $it") return // 编译错误: return is not allowed here &#125;&#125; 总结 使用 inline，内联函数到调用的地方，能减少函数调用造成的额外开销，在循环中尤其有效。 使用 inline 能避免函数的 lambda 形参额外创建 Function 对象。 使用 noinline 可以拒绝形参 lambda 内联。 使用 crossinline 显示声明 inline 函数的形参 lambda 不能有 return 语句，避免lambda 中的 return 影响外部程序流程。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池实现原理（三）]]></title>
    <url>%2F2020%2F05%2F27%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转自美团技术团队 线程池生命周期管理上一期讲了线程池生命周期管理的任务管理，对于线程池来说，任务管理和线程管理是它必须关注的事情，而线程管理比任务管理则更复杂。 线程管理Worker线程（工作线程）线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker，先看一下源码： 1234private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; final Thread thread;//Worker持有的线程 Runnable firstTask;//初始化的任务，可以为null&#125; Worker这个线程，实现了Runnable接口，并持有一个线程thread变量，一个初始化的任务firstTask，thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值时非空的，那么线程就会在启动初期立即执行这个任务，也就是对应核心线程（corePool）创建时的情况，如果这个值时null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。 Worker执行任务的模型如下图所示： 线程池需要管理线程的生命周期，需要在线程池长时间不允许的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用，移除引用这样的操作来控制线程的生命周期，这个时候重要的是如何判断线程是否在运行。 Worker是通过继承AQS，使用AQS来实现独占锁这个功能（每次只能有一个线程能持有锁，是针对共享锁而言的，AQS源码中其内部类Node定义来两个常量SHARED和EXCLUSIVE，分别就是共享模式和独占模式，标示了AQS队列中等待线程的锁获取模式），为的就是实现不可重入的特性去反应线程当前的执行状态。 下图是Java中主流锁的分类：（锁的概念有很多，但是其实各种锁的维度是不同的，后面会详细深入了解） 那么如何判断线程是否正在运行呢： lock方法一旦获取了独占锁，表示当前线程正在执行任务中 如果正在执行任务，则不应该中断线程 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断 线程池在执行shutdown方法或者tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法使用tryLock方法来判断线程池中的线程是否空闲状态；如果是空闲状态则可以安全回收。 会在线程回收过程中也使用到了这种特性，回收过程如下图所示： Worker线程增加增加线程时通过线程池中addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。 addWorker方法有两个参数：firstTask，core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空（和Worker线程中的firstTask差不多），core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize（核心线程数），false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize（最大线程数），其执行流程如下： Worker线程回收线程池中线程的销毁依赖于JVM自动的回收，线程池做的工作时根据当前线程池的状态维护一定数量的线程引用（前面提到的用Hash表），防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断的进行轮训，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环就会结束，Worker会主动消除自身在线程池内的引用。 1234567try &#123; while (task != null || (task = getTask()) != null) &#123; //执行任务（循环） &#125;&#125; finally &#123; processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己&#125; 上述代码可以看出线程池回收时在processWorkerExit方法中完成的，下面是线程回收流程图： 实时上，在这个方法中，将线程引用移除线程池就已经结束线程池销毁线程的工作了（等待JVM自动回收线程）。但是由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的状态，是否要根据新状态，重新分配线程。 Woker线程执行任务在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法执行过程是： while循环不断通过getTask方法来获取任务 getTask方法总阻塞队列中获取任务 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 执行任务 如果getTask方法结果为null，则跳出循环，执行processWorkerExit方法，销毁线程 流程图如下：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技能提升</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池实现原理（二）]]></title>
    <url>%2F2020%2F05%2F20%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转自美团技术团队 线程池生命周期管理线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由线程池内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起。 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含了两部分的信息：运行状态（runState）和线程数量（workerCount），高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。这样做的好处是：源码中经常出现要同时判断上述两种状态的情况，这时候通过一个变量就可以获取，而不用为了维护两者的一致去占用资源锁，然后线程池也提供了很多方法供用户获取当前的运行状态和线程个数。这里都是用位运算，速度会比基本运算快很多。下面代码是一些线程池的方法： 123private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //计算当前运行状态private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; //计算当前线程数量private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; //通过状态和线程数生成ctl ThreadPoolExecutor的运行状态有5种，分别为： 运行状态 状态描述 RUNNING 能接受新提交的任务，并且也能处理阻塞队列中的任务 SHUTDOWN 关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务 STOP 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程 TIDYING 所有任务都已经终止了，workerCount为0 TERMINATED 在terminated()方法执行后进入该状态 其生命周期转换如下所示： 任务管理机制任务调度任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。先来介绍一些基本概念： corePoolSize: 线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。（线程池本身也要创建线程去执行任务，只是线程池维护了这些创建线程的生命周期，看什么时候需要创建，什么时候要销毁） maximumPoolSize: 线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。若果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largesPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么生活曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()来改变这个最大线程数目。 poolSize: 线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；poolSize也不会超过maximumPoolSize. 首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在的线程池的运行状态、运行线程数目、运行策略、决定接下来执行的流程，是直接申请线程执行，缓冲到队列中执行，还是直接拒绝执行。参看上图任务分配机制。其执行过程如下： 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。 如果workerCount（线程数量） &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列（BlockQueue）没有满，则将任务添加到该阻塞队列中。 如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize,且线程池中阻塞队列已满，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= maximumPoolSize,并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的拒绝策略是直接抛出异常。 其执行流程如下图所示： 任务缓冲任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，其中任务的管理相对是一件容易的事情，复杂的是线程的管理，这会涉及到线程池数量，等待/唤醒，同步/锁，线程创建和死亡等问题。线程池中以生产者消费者模式，通过一个阻塞队列来实现将任务和线程两者解耦的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者时往队列中添加元素的线程，消费者时总队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只是从容器里拿元素。下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素： 使用不同的队列可以实现不一样的任务存取策略，在这里，我们可以再介绍下阻塞队列的成员：(针对不同场景使用) 名称 描述 ArrayBlockingQueue 一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁 LinkedBlockingQueue 一个由链表结构组成的有界队列，此队列按照先进先出的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，所以默认创建的该队列有容量危险 PriorityBlockingQueue 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序 DelayQueue 一个实现了PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素，只有延迟满后才能从队列中获取元素 SynchronousQueue 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个只用场景是在线程池里。Executors.newCachedThreadPool()就使用了这个队列，这个线程池根据需要（新任务到来时）创建新线程，如果有空闲线程则会重复使用，线程空闲了60s后会被回收（需要关注使用场景） LinkedTransferQueue 一个由链表结构组成的无界阻塞队列，相比与其他队列，LinkedTransferQueue队列多了transfer和tryTransfer方法 LinkedBlockingDeque 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半 任务申请由上文的任务分配部分可以知道，任务的执行有两种可能： 直接创建新的线程来处理。（在线程初始创建的时候） 线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次从队列中申请任务去执行。（大多数时间线程池工作的情况） 线程需要从任务缓存模块中不断的取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现。其执行流程如下： getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态，如果线程池现在不应该持有那么多线程，则返回null。工作线程Worker会不断接收新任务执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。（怎么判断线程是否为可回收） 任务拒绝任务拒绝模块是线程池的保护部分，线程池有一个最大的容量（maximumPoolSize），当线程池任务队列已满，并且线程池中的线程数目达到最大容量，就需要拒绝执行该任务了，采取任务拒绝策略来保护线程池。 拒绝策略需要实现一个接口： 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下： 序号 名称 描述 1 ThreadPoolExecutor.AborPolicy 默认方式，直接丢弃任务并抛出RejectedExecutionException异常。在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现问题 2 ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常。使用此策略，可能使我们无法发现系统的异常状态。 3 ThreadPoolExecutor.DiscardOldestPolicy 丢弃队列最前面的任务，然后重新提交被拒绝的任务。 4 ThreadPoolExecutor.CallerRunsPolicy 由调用线程（提交任务的线程）处理该任务，这种情况是需要让所有任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技能提升</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池实现原理（一）]]></title>
    <url>%2F2020%2F05%2F13%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景线程池是什么线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，或者涉及到一些复杂线程操作需要重复开启线程。线程过多会带来额外的开销，包括创建线程的开销，调度线程的开销等等，同时也降低了计算机的整体性能。线程池能维护多个线程，等待监督管理分配可并发执行的任务，这种做法一方面避免了处理任务时创建销毁线程开销的代价，另一方面也避免了线程数量膨胀的过分调度问题，保证了对内核的充分利用。Java中对线程池的实现都是基于ThreadPoolExcutor类，它能带来一系列的好处： 降低资源消耗： 通过池化技术重复利用已经创建的线程，降低线程创建和销毁造成的损耗 提高响应速度： 任务到达时，无需等待线程创建就可以立即执行（前提是线程池中有可用的线程） 提高线程的可管理性： 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。不用开发者自己去维护这一整个流程。 提供更多更强大的功能： 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。 线程池能解决什么问题线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题： 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。 为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。这种思想也广泛应用于计算机的其它领域中： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。例如Sql连接池 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。例如String。 Java线程池核心设计于实现总体设计Java中的线程池核心实现类是ThreadPoolExecutor，首先分析UML类图，如下： 具体分析： Executor： ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦，用户无需关注如何创建线程，如何调度线程来执行任务，用户只需要提供Runable对象，将任务的执行逻辑提交到执行器（Executor）中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService：接口增加了一些能力： 扩充执行任务的能力，补充可以为一个或是一批异步任务生成Future方法 提供了管控线程池的方法，比如停止线程池的运行。 AbstractExecutorService：是上层的抽象类，将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法即可。ThreadPoolExecutor：最下层的实现类实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时还需要管理线程和任务，使两者良好的结合从而执行并行任务。 下图是ThreadPoolExecutor的运行机制： 从图中可以看出来，线程池内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。 线程池的运行主要分成两部分：任务管理，线程管理。任务管理：充当生成者的角色，当任务提交后，线程池会判断该任务后续的流转： 1. 直接申请线程执行该任务 2. 缓冲到队列中等待线程执行 3. 拒绝该任务 线程管理：线程管理部分是消费者，他们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务，线程就会被回收。 下一节继续按照下面三个部分去介绍线程池的运行机制： 线程池如何维护自身的生命周期 线程池如果管理任务 线程池如何管理线程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技能提升</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaGuide之AQS]]></title>
    <url>%2F2020%2F05%2F12%2FJavaGuide%E4%B9%8BAQS%2F</url>
    <content type="text"><![CDATA[文章转载：一行一行源码分析清楚 AbstractQueuedSynchronizer (二) 文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。 本文关注以下几点内容： 深入理解 ReentrantLock 公平锁和非公平锁的区别 深入分析 AbstractQueuedSynchronizer 中的 ConditionObject 深入理解 Java 线程中断和 InterruptedException 异常 基本上本文把以上几点都说清楚了，我假设读者看过上一篇文章中对 AbstractQueuedSynchronizer 的介绍 ，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。 其实这篇文章的信息量很大，初学者估计至少要 1 小时才能看完，希望本文对得起大家的时间。 公平锁和非公平锁ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。 1234567public ReentrantLock() &#123; // 默认非公平锁 sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 公平锁的 lock 方法： 12345678910111213141516171819202122232425262728293031static final class FairSync extends Sync &#123; final void lock() &#123; acquire(1); &#125; // AbstractQueuedSynchronizer.acquire(int arg) public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 非公平锁的 lock 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041static final class NonfairSync extends Sync &#123; final void lock() &#123; // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; // AbstractQueuedSynchronizer.acquire(int arg) public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 这里没有对阻塞队列进行判断 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 总结：公平锁和非公平锁只有两处不同： 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。 公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。 相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。 ConditionTips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 AbstractQueuedSynchronizer 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。 我们先来看看 Condition 的使用场景，Condition 经常可以用在生产者-消费者的场景中，请看 Doug Lea 给出的这个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); // condition 依赖于 lock 来产生 final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; // 生产 public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); // 队列已满，等待，直到 not full 才能继续生产 items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去 &#125; finally &#123; lock.unlock(); &#125; &#125; // 消费 public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费 Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。 2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue 我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《深入分析 java 8 编程语言规范：Threads and Locks》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。 在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，都必须获取到锁才能进行操作。 每个 ReentrantLock 实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例： 1234final ConditionObject newCondition() &#123; // 实例化一个 ConditionObject return new ConditionObject();&#125; 我们首先来看下我们关注的 Condition 的实现类 AbstractQueuedSynchronizer 类中的 ConditionObject。 12345678public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; // 条件队列的第一个节点 // 不要管这里的关键字 transient，是不参与序列化的意思 private transient Node firstWaiter; // 条件队列的最后一个节点 private transient Node lastWaiter; ...... 在上一篇介绍 AQS 的时候，我们有一个阻塞队列，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫条件队列（condition queue），我画了一张简单的图用来说明这个。 这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，阻塞队列和条件队列。 这里，我们简单回顾下 Node 的属性：12345volatile int waitStatus; // 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)volatile Node prev;volatile Node next;volatile Thread thread;Node nextWaiter; prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表 基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。 条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的； 我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter； 每个 condition 有一个关联的条件队列，如线程 1 调用 condition1.await() 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表； 调用condition1.signal() 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的条件队列的 firstWaiter（队头） 移到阻塞队列的队尾，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。 上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。 同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 这个图看懂后，下面的代码分析就简单了。 接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法： 12345678910111213141516171819202122232425262728293031// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断public final void await() throws InterruptedException &#123; // 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态 if (Thread.interrupted()) throw new InterruptedException(); // 添加到 condition 的条件队列中 Node node = addConditionWaiter(); // 释放锁，返回值是释放锁之前的 state 值 // await() 之前，当前线程是必须持有锁的，这里肯定要释放掉 int savedState = fullyRelease(node); int interruptMode = 0; // 这里退出循环有两种情况，之后再仔细分析 // 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了 // 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; // 被唤醒后，将进入阻塞队列，等待获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。 1. 将节点加入到条件队列addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。 12345678910111213141516171819202122// 将当前线程对应的节点入队，插入队尾private Node addConditionWaiter() &#123; Node t = lastWaiter; // 如果条件队列的最后一个节点取消了，将其清除出去 // 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？ if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列 unlinkCancelledWaiters(); t = lastWaiter; &#125; // node 在初始化的时候，指定 waitStatus 为 Node.CONDITION Node node = new Node(Thread.currentThread(), Node.CONDITION); // t 此时是 lastWaiter，队尾 // 如果队列为空 if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。 在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。 当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。 12345678910111213141516171819202122// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去// 纯属链表操作，很好理解，看不懂多看几遍就可以了private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的 if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125;&#125; 2. 完全释放独占锁回到 wait 方法，节点入队了以后，会调用 int savedState = fullyRelease(node); 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。 考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。 123456789101112131415161718192021// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。// 那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1// 相应的，如果 lock 重入了 n 次，savedState == n// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateExceptionfinal int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0 if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; 考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 node.waitStatus = Node.CANCELLED，这个已经入队的节点之后会被后继的节点”请出去“。 3. 等待进入阻塞队列释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。 12345678910int interruptMode = 0;// 如果不在阻塞队列中，注意了，是阻塞队列while (!isOnSyncQueue(node)) &#123; // 线程挂起 LockSupport.park(this); // 这里可以先不用看了，等看到它什么时候被 unpark 再说 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;&#125; isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了： 12345678910111213141516171819202122232425262728293031323334// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，// 这个方法就是判断 node 是否已经移动到阻塞队列了final boolean isOnSyncQueue(Node node) &#123; // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到 // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中 // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的) if (node.waitStatus == Node.CONDITION || node.prev == null) return false; // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了 if (node.next != null) return true; // 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列 // 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。 // 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail， // 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。 return findNodeFromTail(node);&#125;// 从阻塞队列的队尾往前遍历，如果找到，返回 trueprivate boolean findNodeFromTail(Node node) &#123; Node t = tail; for (;;) &#123; if (t == node) return true; if (t == null) return false; t = t.prev; &#125;&#125; 回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 LockSupport.park(this); 这里线程挂起。 4. signal 唤醒线程，转移到阻塞队列为了大家理解，这里我们先看唤醒操作，因为刚刚到 LockSupport.park(this); 把线程挂起了，等待唤醒。 唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 唤醒等待了最久的线程// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列public final void signal() &#123; // 调用 signal 方法的线程必须持有当前的独占锁 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125;// 从条件队列队头往后遍历，找出第一个需要转移的 node// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中private void doSignal(Node first) &#123; do &#123; // 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了 // 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉 first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推&#125;// 将节点从条件队列转移到阻塞队列// true 代表成功转移// false 代表在 signal 之前，节点已经取消了final boolean transferForSignal(Node node) &#123; // CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消， // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点 // 否则，将 waitStatus 置为 0 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; // enq(node): 自旋进入阻塞队列的队尾 // 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点 Node p = enq(node); int ws = p.waitStatus; // ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释 // 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1) if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节 LockSupport.unpark(node.thread); return true;&#125; 正常情况下，ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。 假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。 5. 唤醒后检查中断状态上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。 等线程从挂起中恢复过来，继续往下看 12345678int interruptMode = 0;while (!isOnSyncQueue(node)) &#123; // 线程挂起 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;&#125; 先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0 REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态 THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常 0 ：说明在 await 期间，没有发生中断 有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行： 常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark） 线程中断。在 park 的时候，另外一个线程对这个线程进行了中断 signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了 假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题 线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。 12345678// 1. 如果在 signal 之前已经中断，返回 THROW_IE// 2. 如果是 signal 之后中断，返回 REINTERRUPT// 3. 没有发生中断，返回 0private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125; Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 重新中断（REINTERRUPT） 的使用。 看看怎么判断是 signal 之前还是之后发生的中断： 1234567891011121314151617181920// 只有线程处于中断状态，才会调用此方法// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列// 返回 true：如果此线程在 signal 之前被取消，final boolean transferAfterCancelledWait(Node node) &#123; // 用 CAS 将节点状态设置为 0 // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0 if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; // 将节点放入阻塞队列 // 这里我们看到，即使中断了，依然会转移到阻塞队列 enq(node); return true; &#125; // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0 // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成 // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断 while (!isOnSyncQueue(node)) Thread.yield(); return false;&#125; 这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。 到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。 这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。 6. 获取独占锁while 循环出来以后，下面是这段代码： 12if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; 由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。 这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。 注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。 继续往下： 1234if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters();if (interruptMode != 0) reportInterruptAfterWait(interruptMode); 本着一丝不苟的精神，这边说说 node.nextWaiter != null 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。 可是，在判断发生中断的情况下，是 signal 之前还是之后发生的？ 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。 之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。 7. 处理中断状态到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。 0：什么都不做，没有被中断过； THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断； REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断 1234567private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt();&#125; 这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。 * 带超时机制的 await经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。 123456public final long awaitNanos(long nanosTimeout) throws InterruptedExceptionpublic final boolean awaitUntil(Date deadline) throws InterruptedExceptionpublic final boolean await(long time, TimeUnit unit) throws InterruptedException 这三个方法都差不多，我们就挑一个出来看看吧： 123456789101112131415161718192021222324252627282930313233343536373839public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; // 等待这么多纳秒 long nanosTimeout = unit.toNanos(time); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); // 当前时间 + 等待时长 = 过期时间 final long deadline = System.nanoTime() + nanosTimeout; // 用于返回 await 是否超时 boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 时间到啦 if (nanosTimeout &lt;= 0L) &#123; // 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法 // 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功 // 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛 timedout = transferAfterCancelledWait(node); break; &#125; // spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒 // 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好 if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; // 得到剩余时间 nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout;&#125; 超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。 * 不抛出 InterruptedException 的 await关于 Condition 最后一小节了。 123456789101112public final void awaitUninterruptibly() &#123; Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if (Thread.interrupted()) interrupted = true; &#125; if (acquireQueued(node, savedState) || interrupted) selfInterrupt();&#125; 很简单，贴一下代码大家就都懂了，我就不废话了。 AbstractQueuedSynchronizer 独占锁的取消排队这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。 接下来，我想说说怎么取消对锁的竞争？ 上篇文章提到过，最重要的方法是这个，我们要在这里面找答案： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 首先，到这个方法的时候，节点一定是入队成功的。 我把 parkAndCheckInterrupt() 代码贴过来： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 这两段代码联系起来看，是不是就清楚了。 如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 LockSupport.park(this); 中唤醒，然后 Thread.interrupted(); 返回 true。 我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 interrupted = true 然后继续下一次循环。而且，由于 Thread.interrupted(); 会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。 所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。 所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。 12345678public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。 来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。 我们来看 ReentrantLock 的另一个 lock 方法： 123public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125; 方法上多了个 throws InterruptedException ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 继续往里： 12345678910111213141516171819202122232425private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 就是这里了，一旦异常，马上结束这个方法，抛出异常。 // 这里不再只是标记这个方法的返回值代表中断状态 // 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly throw new InterruptedException(); &#125; &#125; finally &#123; // 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了 if (failed) cancelAcquire(node); &#125;&#125; 既然到这里了，顺便说说 cancelAcquire 这个方法吧： 1234567891011121314151617181920212223242526272829303132333435363738private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // Skip cancelled predecessors // 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“ Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; 其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。 再说 java 线程中断和 InterruptedException 异常在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。 线程中断首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。 Java 中的中断和操作系统的中断还不一样，这里就按照状态来理解吧，不要和操作系统的中断联系在一起 关于中断状态，我们需要重点关注 Thread 类中的以下几个方法： 12345678910// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态public boolean isInterrupted() &#123;&#125;// Thread 中的静态方法，检测调用这个方法的线程是否已经中断// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了public static boolean interrupted() &#123;&#125;// Thread 类中的实例方法，用于设置一个线程的中断状态为 truepublic void interrupt() &#123;&#125; 我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码： 1234while (!Thread.interrupted()) &#123; doWork(); System.out.println("我做完一件事了，准备做下一件，如果没有其他线程中断我的话");&#125; 这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。 当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。 如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到： 来自 Object 类的 wait()、wait(long)、wait(long, int)， 来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int) 这几个方法的相同之处是，方法上都有: throws InterruptedException 如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。 实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等 如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。 Selector 中的 select 方法，参考下我写的 NIO 的文章 一旦中断，方法立即返回 对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），并且在做出相应的操作后都会重置中断状态为 false。 那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。 InterruptedException 概述它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 throws InterruptedException，我们通常称这些方法为阻塞方法（blocking method）。 阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。 当我们看到方法上带有 throws InterruptedException 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能感知到线程中断了。 处理中断一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。 我们经常会这么写代码： 123456try &#123; Thread.sleep(10000);&#125; catch (InterruptedException e) &#123; // ignore&#125;// go on 当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例） AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法： 1234567public void lock() &#123; sync.lock();&#125;public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125; 前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码： 1234567public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。 // 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了 selfInterrupt();// Thread.currentThread().interrupt();&#125; 而对于 lockInterruptibly() 方法，因为其方法上面有 throws InterruptedException ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。 在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的： 12void await() throws InterruptedException;void awaitUninterruptibly(); 通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：12345public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); ...... &#125; 熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。 总结这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。 欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。 推荐系列推荐系列2]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>源码</tag>
        <tag>技能提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot之事务]]></title>
    <url>%2F2020%2F03%2F03%2FSpring%20boot%E4%B9%8B%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Spring的事务机制所有的数据库访问技术都有事务处理机制，这些技术提供了API用于开启事务，提交事务完成数据操作，或者在发生错误的时候回滚数据。Spring的事务机制是用统一的机制来处理不同数据访问技术的事务处理，Spirng的事务机制提供了一个PlatformTransactionManager接口，不同的数据访问技术的事务使用不同的接口实现，如下表： 数据访问技术 实现 JDBC DataSourceTransactionManager JPA JPATransactionManager Hibernate HibernateTransactionManager JDO JdoTransactionManager 声明式事务Spring支持声明式事务，即使用注解来选择需要使用事务的方法，他使用@Transactional注解在方法上表明该方法需要事务支持。备注解的方法在被调用时，Spring开启一个新的事务，当方法无异常运行结束后，Spring会提交这个事务。如： 1234@Transactionalpublic void saveStudent(Student student)&#123; // 数据库操作&#125; 注意，@Transactional注解来自于org.springframework.transcation.annotation包，而不是javax.transaction。 注解事务行为@Transactional有如下表所示的属性来定制事务行为 属性 含义 Propagation 事务传播行为 isolation 事务隔离级别 readOnly 事务的读写性，boolean型 timeout 超时时间，int型，以秒为单位。 rollbackFor 一组异常类，遇到时回滚。（rollbackFor={SQLException.class}） rollbackForClassName 一组异常类名，遇到回滚，类型为 string[] noRollbackFor 一组异常类，遇到不回滚 norollbackForClassName 一组异常类名，遇到时不回滚。 类级别使用@Transactional@Transactional不仅可以注解在方法上，还可以注解在类上。注解在类上意味着此类的所有public方法都开启了事务。如果类级别和方法级别同时使用了@Transactional注解，则使用在类级别的注解会重载方法级别的注解（也就是已类级别的注解最终生效）。 Spring Boot的事务支持 自动配置的事务管理器，在使用JDBC作为数据库访问技术时（现在一般很少），配置如下： 123456@Bean@ConditionalOnMissingBean@ConditionalOnBean(DataSource.class)public PlatformTransactionManager transactionManager()&#123; return new DataSourceTransactionManager(this.dataSource)&#125; 在使用JAP作为数据持久化技术时，配置如下： 12345@Bean@ConditionalOnMissingBean(PlatformTransactionManager.class)public PlatformTransactionManager transactionManager()&#123; return new JpaTransactionManager()&#125; @Bean注解可以参考Springboot注解详解，大意是Springboot启动后扫描的一系列组件的标识 实战演示如何使用@Transactional使用异常数据回滚与使用异常导致数据不回滚 实体类（Entity） 1234567891011121314@Data@Entity@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age;&#125; 数据持久化层（Dao层）这里使用的是JPA 123@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Integer&gt; &#123;&#125; Service层 1234567public interface StudentService &#123; Student saveStudentWithRollBack(Student student); Student saveStudentWithoutRollBack(Student student);&#125; Service实现层（Impl） 12345678910111213141516171819202122232425262728293031@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired // 直接注入 StudentRepository 的 bean private StudentRepository studentRepository; // 使用 @Transactional 注解的 rollbackFor 属性，指定特定异常时，触发回滚 @Transactional(rollbackFor = &#123;IllegalArgumentException.class&#125;) @Override public Student saveStudentWithRollBack(Student student) &#123; Student s = studentRepository.save(student); if ("高斯林".equals(s.getName()))&#123; //硬编码，手动触发异常 throw new IllegalArgumentException("高斯林已存在，数据将回滚"); &#125; return s; &#125; // 使用 @Transactional 注解的 noRollbackFor 属性，指定特定异常时，不触发回滚 @Transactional(noRollbackFor = &#123;IllegalArgumentException.class&#125;) @Override public Student saveStudentWithoutRollBack(Student student) &#123; Student s = studentRepository.save(student); if ("高斯林".equals(s.getName()))&#123; throw new IllegalArgumentException("高斯林已存在，数据将不会回滚"); &#125; return s; &#125;&#125; controller层（接口调用层） 1234567891011121314151617181920@RestController@RequestMapping("/student")public class StudentController &#123; // 注入 studentservice 的 bean @Autowired private StudentService studentService; // 测试回滚情况 @PostMapping("/withRollBack") public Student saveStudentWithRollBack(@RequestBody Student student)&#123; return studentService.saveStudentWithRollBack(student); &#125; // 测试不回滚情况 @PostMapping("/withOutRollBack") public Student saveStudentWithoutRollBack(@RequestBody Student student)&#123; return studentService.saveStudentWithoutRollBack(student); &#125;&#125; 测试结果：有异常回滚成功后，数据并没有写入数据库；不回滚，有异常数据也会插入数据库]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot之事务传播]]></title>
    <url>%2F2020%2F02%2F25%2FSpring%20boot%E4%B9%8B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%2F</url>
    <content type="text"><![CDATA[背景Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为，这是Spring为我们提供的强大工具箱。使用事务传播可以为我们开发提供许多便利。但是人们对他的误解也很多，你一定听过“service方法事务最好不要嵌套”的传言。要想正确使用工具首先需要了解工具。 基础概念什么是事务传播行为事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另外一个方法时事务如何传播。伪代码说明： 123456789public void methodA()&#123; methodB(); //doSomething&#125;@Transaction(Propagation == XX)public void methodB()&#123; //doSomething&#125; 代码中methodA()方法嵌套调用了methodB()方法，methodB()的事务传播行为由@Transaction（）设置来决定。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot之JPA]]></title>
    <url>%2F2020%2F01%2F21%2FSpring%20boot%E4%B9%8BJPA%2F</url>
    <content type="text"><![CDATA[Spring boot连接数据库背景知识 JDBCJava DataBase Connectivity是Java连接数据操作的原生接口。JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为各个数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准的方法。 一句话概括：JDBC是所有框架操作数据库必须要用的，有数据库厂商提供，但是为了方便JAVA程序员调用各个数据库，各个数据库厂商都要实现JDBC接口（提供统一的标准） JPAJAVA Persistence API是JAVA持久化规范，是ORM框架的标准（注意，它是一种标准），主流ORM框架都实现了这个标准。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有的JAVA EE和JAVA SE应用开发工作；第二，Sun希望整合ORM技术，实现统一化操作。ORM是一种思想，是插入在应用程序与JDBC API之间的一个中间层，JDBC并不能很好地支持面向对象的程序设计，ORM解决了这个问题，通过JDBC将字段高效地与对象进行映射，具体实现（ORM框架）有：hibernate，toppling，spring data jpa，open jpa等。spring data jpa是对JPA规范的再次抽象，底层还是用的实现JPA的hibernate技术。本文讲的JPA就是其具体实现：Spring data jpa。 hibernate一个标准的ORM框架，实现了JPA接口 mybatis一个持久化框架，但是不完全是一个ORM框架，不是依照JPA规范。 Spring Boot JPASpring Boot Jpa是Spring基于ORM框架，JPA规范的基础上封装的一套JAP应用框架，可以使开发者使用极简的代码即可以实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。Spring Boot JPA让我们摆脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现 基本查询基本查询也分为两种，一种是默认实现，一种是根据查询的方法来自动解析成SQL。很好很强大。 默认实现Spring Boot Jpa默认预先生成来一些基本的CURD的方法，例如：增、删、查首先，继承JpaRepository，看代码： 1234@Repositorypublic interface PersonRepository extends JpaRepository&lt;Person,Long&gt; &#123;&#125; 就只是实现一个接口，PersonRepository便拥有了很多能力。如： 123456789public void testMethod(Person person) &#123; personRepository.save(person); personRepository.count(); personRepository.delete(person); personRepository.deleteAll(); personRepository.findAll(); //等等，上面这些都是默认提供的。 &#125; 是不是很爽，啥都不用写，就给你赋予了这么多操作数据库的能力。 自定义简单查询自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是：findXXBy，readXXBy，queryXXBy，countXXBy，getXXBy后面跟属性名称，看代码： 1234567891011@Repositorypublic interface PersonRepository extends JpaRepository&lt;Person,Long&gt; &#123; List&lt;Person&gt; findByName(String name); List&lt;Person&gt; findByAddress(String address); List&lt;Person&gt; findByNameAndAddress(String name,String address);&#125;//通过方法名就知道什么意思，能实现什么操作了 基本上SQL体系中的关键词都可以使用，如Like，IgnoreCase，OrderBy等。具体的关键字，使用方法和产生SQL如下表所示： KeyWord Sample JPQL snippet And findByLastnameAndFirstname Where x.lastname =?1 and x.firstname =?2 Or findByLastnameOrFirstname where x.lastname= =?1 and x.firstname =?2 Is,Equals findByFirstnameIs,findByFirstnameEquals where x.firstname = ?1 Between findByStartDateBetween where x.startDate between ?1 and ?2 LessThan findByAgeLessThan where x.age &lt; ?1 GreaterThanEqual findByAgeGreaterThanEqual where x.age &gt;= ?1 After findByStartDateAfter where x.startDate &gt; ?1 IsNull findByAgeIsNull where x.age is null Like findByFirstnameLike where x.firstname like ?1 StartingWith findByFirstnameStartingWith where x.firstname like ?1 (parameter bound with appended %) 具体更多参考官网 复杂查询在实际开发中我们需要用到分页，删除，连表等查询的时候就需要特殊的方法或者自定义SQL 分页查询分页查询在实际使用中非常普遍了，Spring Boot Jpa已经帮我吗实现了分页的功能，在查询方法中，需要传入一个参数 Pageable，当查询中有多个参数的时候Pageable建议作为最后一个参数传入。例子： 12Page&lt;User&gt; findALL(Pageable pageable);Page&lt;User&gt; findByUserName(String userName,Pageable pageable); Pageable是Spring封装的分页实现类，使用的时候初始化参数为：页数，每页条数，排序规则，看代码： 12345678910@Overridepublic List&lt;Person&gt; getPersonByPage(int page, int size) &#123; Sort sort = new Sort(Sort.Direction.DESC, "id"); Pageable pageable = PageRequest.of(page,size,sort);//new PageRequest(page,size,sort); Page&lt;Person&gt; personPage = personRepository.findAll(pageable); return personPage.getContent();&#125; 限制查询有时候我们只需要查询前N个元素，或者取前一个实体，这时候可以这样操作： 12345User findFirstByOrderByLastnameAsc();User findTopByOrderByAgeDesc();Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 这种操作也很常见，这样就很方便了。 自定义SQL查询其实Spring data绝大部份的SQL都可以根据方法名定义的方式来实现，但是总有情况我不想用自带的，就是要手写SQL，它也是支持的，使用@Query注解就可以做到，若果涉及到删除或者修改再需要加上@Modifying注解，也可以根据需要添加@Transactional对事物的支持，查询超时设置等。看代码： 123456789101112131415@Modifying@Query("update User u set u.userName = ?1 where u.id = ?2")int modifyByIdAndUserId(String userName, Long id); @Transactional@Modifying@Query("delete from User where id = ?1")void deleteByUserId(Long id); @Transactional(timeout = 10)@Query("select u from User u where u.emailAddress = ?1")User findByEmailAddress(String emailAddress);@Query("select p from Person p where p.name=:name and p.address=:address") List&lt;Person&gt; withNameAndAddressQuery(@Param("name")String Name, @Param("address")String address); 多表查询多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。 首先需要定义一个结果集的接口类。 12345678910111213public interface HotelSummary &#123; City getCity(); String getName(); Double getAverageRating(); default Integer getAverageRatingRounded() &#123; return getAverageRating() == null ? null : (int) Math.round(getAverageRating()); &#125;&#125; 查询的方法返回类型设置为新创建的接口 1234567@Query("select h.city as city, h.name as name, avg(r.rating) as averageRating " - "from Hotel h left outer join h.reviews r where h.city = ?1 group by h")Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);@Query("select h.name as name, avg(r.rating) as averageRating " - "from Hotel h left outer join h.reviews r group by h")Page&lt;HotelSummary&gt; findByCity(Pageable pageable); 使用： 1234Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, "name"));for(HotelSummary summay:hotels)&#123; System.out.println("Name" +summay.getName()); &#125; 在运行中 Spring 会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用 getXX的形式来获取 多数据源的支持未完待续。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局之Position（定位）]]></title>
    <url>%2F2020%2F01%2F15%2FCSS%E5%B8%83%E5%B1%80%E4%B9%8BPosition%EF%BC%88%E5%AE%9A%E4%BD%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CSS重点属性之Positionposition属性指定了元素的定位类型，它有5个值 static（默认） relative fixed absolute sticky 元素可以使用的top / bottom / left / right的属性进行定位。然而，这些属性无法正常工作，除非先设定position属性。他们也有不同的工作方式，这取决于定位方法。 staticHTML元素的默认值，没有定位，遵循正常的文档流对象。静态定位的元素不会收到top，bottom，left，right影响。 1234div.static &#123; position: static; border: 3px solid #73AD21;&#125; 运行效果 fixed元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动，这个类似于Android里面某个某个悬浮控件，屏幕滑动时该控件的位置也不变。 123456p.pos_fixed&#123; position:fixed; top:30px; right:5px;&#125; 运行效果可以滑动浏览器看看效果。 Fixed定位使元素的位置与文档流无关，因此不占据空间，Fixed定位的元素会与其它元素重叠。 relative相对其正常位置的定位（正常文档流是从上到下从左到右） 12345678910h2.pos_left&#123; position:relative; left:-20px;&#125;h2.pos_right&#123; position:relative; left:20px;&#125; 运行效果 absolute绝对定位的元素位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 123456h2&#123; position:absolute; left:100px; top:150px;&#125; 运行效果 同fixed定位一样，absolute定位使元素的位置与文档流无关，因此不占据空间，和其它元素会有重叠。 sticky基于用户的滚动位置来定位，粘性定位的元素是依赖于用户的滚动，在position：relative与position：fixed定位之间切换。它的行为就像position：relative；而当页面滚动超出目标区域时，它的表现就像position：fixed；它会固定在目标位置。固定的位置指的是top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 1234567div.sticky &#123; position: -webkit-sticky; /* Safari */ position: sticky; top: 0; background-color: green; border: 2px solid #4CAF50;&#125; 运行效果]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局之Flex布局]]></title>
    <url>%2F2020%2F01%2F08%2FCSS%E5%B8%83%E5%B1%80%E4%B9%8BFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Flex布局文章来源 前面讲过CSS基本的布局方法，默认排列位inline（行内元素）和block（块状元素），传统的布局解决方案，基于盒装模型，依赖display属性+position属性+float属性。它对于那些特殊布局非常不方便，09年，W3C提出了一种新的方案–Flex布局，可以简便完整响应式实现各种页面布局。目前已经得到了所有浏览器的支持，小程序也是支持Flex的。 flex布局是什么Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 1234567.box&#123; display: flex; //行内元素也可以使用Flex布局 display: inline-flex; //webkit内核的浏览器，必须加上-webkit前缀 display: -webkit-flex;&#125; 注意，设为Flex布局布局以后，子元素的float , clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，成为Flex容器（Flex container），简称“容器”。它所有子元素自动成为容器成员。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置叫做main start，结束位置叫做main end;交叉轴（垂直于水平主轴）,交叉轴开始位置叫cross start，结束位置叫cross end。项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。下图是Flex布局属性脑图： Flex容器布局属性以下六个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-item align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 1flex-direction: row | row-reverse | column | column-reverse 它有四个值 row(默认值)：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在由端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap属性默认情况下，项目都排在一条线上（又称“轴线”）上，flex-wrap属性定义，如果一条轴线排不下去，会自动换行 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse&#125; 它有三个值 nowrap: 不换行 wrap：换行，第一行在上面，从上到下换行 wrap-reverse：换行，第一行在下方，从下到上换行 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 123.box &#123; flex-flow: row || wrap;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它有五个值 flex-start: 默认值，左对齐 flex-end：右对齐 center：居中 space-between：两段对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔都相等。所以上图里面元素之间的间隔比元素与边框之间的间隔大一倍。 align-items属性align-items是针对纵轴元素的对齐方式 123.box&#123; align-items: flex-start | flex-end | center | space-between | space-around&#125; 它有五个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下 flex-start: 交叉轴的起点对齐 flex-start: 交叉轴的重点对齐 center: 交叉轴的重点对齐 baseline: 项目的第一行文字的基线对齐 stretch: 默认值，如果项目未设置高度或者设为auto，将占满整个容器的高度。 align-content属性align-content属性定于你了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。 123.box&#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch ;&#125; 它有六个值 flex-start: 与交叉轴的起点对齐 flex-end: 与交叉轴的终点对齐 center: 与交叉轴的中点对齐 space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch: 默认值，轴线占满整个交叉轴 Flex元素（项目）的属性以下6个属性设置在项目（元素）上 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 12345678910111213.item &#123; order: 1;&#125;``` ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)### flex-grow属性flex-grow属性定义项目的放大比例，默认为0，如果存在剩余空间，也不放大。```css.item &#123; flex-grow: 1;&#125; flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，如果空间不足，该元素将缩小 123.item &#123; flex-shrink: 1 (default)&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其它项目为1，则空间不足时，前者不会缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余的空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: 300px | auto&#125; 它可以设置为跟width或height属性一样的值（比如350px），则项目（元素）将占据固定空间。 flex属性flex属性时flex-grow，flex-shrink和flex-basis的简写，默认值0 1 auto。后两个属性可选。 123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto)和none（0 0 auto） 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其它项目不一样的对齐方式，可覆盖align-items属性。默认值为auto,表示继承父元素的align-item属性，如果没有父元素，则等同于streth。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可取6个值，除了auto，其它和align-item一样。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot初解]]></title>
    <url>%2F2019%2F12%2F25%2FSpring%20Boot%E5%88%9D%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot是什么从本质上来说，Springboot是一个专注于框架的框架。Spring Boot就是对各种框架的整合，让他们集成在一起更加简单。目前ssm框架还是比较常用的，其中ss指的无非就是Spring和SpringMVC，我们可以简单的认为“Spring Boot &gt;= Spring + SpringMVC”。Spring Boot的配置极其简单，可以让你不用或者只需要很少的配置就可以快速运行项目。 Spirng Boot的优缺点优点 快速构建项目 对主流开发框架的无配置集成 spring-boot-starter-web启动器自动依赖其它组件，减少了maven配置 项目可以独立运行，无需外部依赖Servlet容器（自带一个Tomcat） 内嵌离各种servlet容器，Tomcat，Jetty等，现在不用打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行了（java -jar .jar）,所有的依赖都在一个jar包内。可以以下命令修改tomcat的端口号：（java -jar .jar –server.port=9090） 提供运行时的应用监控 极大提高开发部署效率（还是因为配置简单） 与云计算天然集成 缺点 Spring Boot作为一个微框架，离微服务的实现还是有距离的。没有提供相应的服务发现和注册的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际URI的规范化工作。 快速入门上面提到使用Spring boot可以让你不用或者只需要很少的配置就可以让项目快速运行，说的就是使用代码注解来取代xml配置。其实从Spring3开始就已经提供java配置方式，使用java配置方式可以更好的理解你配置的Bean，如今Spring4更是推荐使用java配置方式，java配置方式可以完全替代xml配置，下面看两个最基本的注解 @Configuration 和 @BeanSpring的Java配置方式时通过@Configuration和@Bean来实现的 @configuration作用与类上，相当于一个xml配置文件 @Bean作用与方法上，相当于xml中的 例子 这是一个简单模拟从数据库取User数据的Dao类（注意代码，它没有使用过任何注解，也就是说UserDao目前没有交给Spring容器管理） 123456789public class UserDao &#123; public List&lt;String&gt; queryUserList() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add("User " + i); &#125; return list; &#125;&#125; 这是一个常见的service，通过注入UserDao，使用UserDao的方法获取用户数据 1234567891011121314@Servicepublic class UserService &#123; @Autowired UserDao userDao; public void getUserList() &#123; List&lt;String&gt; list = userDao.queryUserList(); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 从这里就开始和Spring不一样了，这个类使用了两个新的注解，其中@Configuration表明该类相当于Spring的一个xml配置文件，@Bean将一开始的UserDao配置给Spring管理 1234567@Configuration// 通过注解来表明该类是一个Spring的配置，相当于一个xml文件public class SpringConfig &#123; @Bean// 这里要注意,方法名"getUserDao"将作为UserDao在容器中的id public UserDao getUserDao() &#123; return new UserDao(); &#125;&#125; 接下来就时获取Spring容器，从容器中拿到UserService，并调用其获取用户数据的方法，代码如下： 1234567public class Test &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext acac = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = (UserService) acac.getBean("userService"); userService.getUserList(); &#125;&#125; Spring boot注解SpringBootApplication是Spring boot项目的核心注解，主要目的是开启自动配置。后续详解原理。 @RestController该注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都是以json格式输出。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环]]></title>
    <url>%2F2019%2F12%2F16%2FJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。 事件循环首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？ 关于执行中的线程： 主线程：也就是js引擎执行的线程，这个线程只有一个，页面渲染，函数处理都在这个主线程上执行。 工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取，网络请求灯异步事件。 如图： 从上图我们可以看出，js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行，在执行代码过程中，如果遇到一些异步代码（比如setTimeout，ajax，promise.then以及用户点击等操作），那么浏览器就会将这些代码放到另一个线程（工作线程）中执行，在前端由浏览器底层执行，在node端由libuv执行，这个线程的执行不阻塞主线程的执行，主线程执行栈中剩余的代码。 当工作线程里的代码执行完成后（比如setTimeout时间都了，ajax请求的到了响应），该线程就会将它的回调函数放在任务队列中（又称为事件队列，消息队列）中等待执行，而当主线程执行完栈中的所有代码后，它会检查任务队列是否有任务要执行，如果有任务要执行的话，那么久将该任务放到执行任务栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。跟大部分框架的消息队列其实本质原理都是一样的。下面我们来具体分析这套机制的运行过程。 任务队列那么，问题来了。如果任务队列中，有很多个任务的话，那么要先执行哪个任务呢？js是有两个任务队列的，一个叫做Macrotask Queue（Task Queue）大任务，一个叫Microtask Queue小任务。 Macrotask常见的任务： setTimeout setInterval setImmediate I/O 用户交互操作，UI渲染 Micraotask常见任务： Promise process.nextTick(nodejs) Object.observe（不推荐使用) 重点来了事件循环执行流程如下：主线程在执行主流程 检查Macrotask队列是否为空，若不为空，则进行下一步，若为空，则跳到第3步； 从Macrotask队列中取队首（在队列时间最长）的任务进去执行栈中执行，执行完后进入下一步； 检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到第一步（开始新的事件循环）； 从Microtask队列中取队首（在队列中时间最长）的任务进去事件队列执行，执行完后，跳到第3步中，在执行过程中新增的microtask任务会在当前事件循环周期内执行，而新增的macrotask任务只能等到下一个事件循环才能执行。 来看一段代码 1234567891011121314151617181920212223242526272829303132333435console.log(1)setTimeout(function() &#123; //settimeout1 console.log(2)&#125;, 0);const intervalId = setInterval(function() &#123; //setinterval1 console.log(3)&#125;, 0)setTimeout(function() &#123; //settimeout2 console.log(10) new Promise(function(resolve) &#123; //promise1 console.log(11) resolve() &#125;) .then(function() &#123; console.log(12) &#125;) .then(function() &#123; console.log(13) clearInterval(intervalId) &#125;)&#125;, 0);//promise2Promise.resolve() .then(function() &#123; console.log(7) &#125;) .then(function() &#123; console.log(8) &#125;)console.log(9) 运行结果 1,9,7,8,2,3,10,11,12,13 运行结果分析 第一次事件循环： console.log(1)被执行，输出1 settimeout1执行，加入macrotask队列 setinterval2执行，加入macrotask队列 settimeout2执行，加入macrotask队列 promise2执行，它的两个then函数加入microtask队列 console.log(9)执行，输出9 根据事件循环定义，接下来会执行新增的microtask任务，（上面标记的：在执行过程中新增的microtask任务会在当前事件循环周期内执行），按照进入队列的顺序，执行console.log(7)和console.log(8),输出7和8，microtask队列为空，回到第1步，进入下一个事件循环，此时macrotask队列为：settimeout1，setinterval1,settimeout2。 第二次事件循环： 从macrotask队列里面取出队首元素：settimeout1并执行，输出2，microtask队列为空，回到第1步，进行下一个事件循环，此时macrotask队列为：setinterval1，settimeout2。 第三次事件循环： 从macrotask队列里取位于队首元素：setiverval1并执行，输出3，然后又将新生成的setinterval1（间隔生产）加入macrotask队列，mincrotask队列为空，回道第1步，进入下一个事件循环，此时macrotask队列为：settimeout2，setinterval1。 第四次事件循环 从macrotask对列中取出队首元素：settimeout2并执行，输出10，并且执行new promise内的函数（new promise内的函数式同步操作，并不是异步操作），输出11，并且将它的两个then函数加入到microtask队列中，再从microtask队列中（当前事件循环周期内执行）取队首的任务执行，直到队列为空。因此，两个新增的microtask任务按照顺序执行，输出12和13，并且将setinterval1清空（不会再产生setiterval1的事件）。 结束 此时，mac和mic队列都为空，浏览器会一直检查队列是否为空，等待新的任务加入队列。在第一次循环中，为什么不是macrotask先执行呢？因为按照流程的话，不是应该先检查macrotask队列是否为空，再检查microtask队列吗。 原因：因为一开始js主线程中跑的任务就是macrotask任务，而根据事件循环流程，一次事件循环只会执行一个macrotask任务，因此，执行完主线程的代码后，它就去从microtask队列中取首任务来执行了。 注意：由于在执行microtask任务的时候，只有当microtask队列为空的时候，它才会进入下一个事件循环，因此，如果它源源不断地产生新的microtask任务，就会导致主线程一直在执行microtask任务，而没有办法执行macrotask任务，这样我们就无法进行UI渲染/IO操作/ajax请求了，因此，我们应该避免这种情况发生，在nodejs中process.necttick就可以设置最大的调用次数，以此来防止阻塞主线程。 定时器问题由上，我们来引入一个新的问题，定时器的问题。定时器是否真实可靠呢？比如我执行一个命令：settimeout（task,100）,他是否就能准确的在100ms后执行呢，如果知道上面运行机制就知道答案是否定的。 看个例子：12345678910111213const s = new Date().getSeconds();setTimeout(function() &#123; // 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行 console.log("Ran after " + (new Date().getSeconds() - s) + " seconds");&#125;, 500);while(true) &#123; if(new Date().getSeconds() - s &gt;= 2) &#123; console.log("Good, looped for 2 seconds"); break; &#125;&#125; 主线程跑了2s后才结束while循环，这才去执行macrotask中的settimeout回调任务。其实，你执行setTimeout（task,100）后只是确保这个任务会在100ms进入macrotask队列，但并不意味着他能立刻运行，可能当前主线程正在进行一个耗时的操作，也可能目前microtask队列有很多个任务，所以用setTimeout作为倒计时其实不会保证准确。 阻塞和非阻塞关于 js 阻塞还是非阻塞的问题，我觉得可以这么理解，不够在这之前，我们先理解下同步、异步、阻塞还是非阻塞的解释，在网上看到一段描述的非常好，引用下： 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。（轮询）异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗最蠢）异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 理解 Node.js 事件循环]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（三）]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[行程（2019-06-03）京都行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下： 这里竖着的带有颜色的竖条代表了各种线路（普通/快速/特快），横着的表示这条线路会停靠的站名。我们坐地铁从九盯木到淡路，然后坐阪急线到乌丸。这里还是要感叹一下，日本的地铁很准时，所以你要上对车，GoogleMap也是利器，标明了每一趟车的到站时间，分秒不差。经过大概1个多小时的车程终于到Kyoto了。 京都给人的感觉更像是大城市，大阪是一种生活的城市。 清水寺来了京都，checkin酒店后，就抓紧时间去附近景点了，防止后面没有时间，选定了不远的清水寺，出发！日本的公交车很贴心（对残障人士），靠站后，整个上车一侧的车身会倾斜下来靠近地面，大家跟容易上车（老年人），而且日本的公交车是前门下车，后门上车的（我觉得很合理）。 游客众多，天气也比较热，但是新鲜感让一切都变得那么美好 正门，其实日本的各种神社，就是类似中国的寺庙 从清水寺回程，我们选择了步行，这个选择我觉得非常正确，可以沿路看到普通的日本人的生活方式和街道等，套用一朋友的话，走在日本的街道上就像是小时候看的日本漫画一样。感觉，整齐，有序。 未完待续。。。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（二）]]></title>
    <url>%2F2019%2F07%2F04%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[行程（2019-06-02）高津宫住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。 貌似日本人结婚也会来这里祈福或者直接就在这里举行仪式 一个老大的墓碑 日式微缩版的小桥流水人家 典型的日本神社⛩️，门很有特色，然后也有神兽，不知道是狐狸还是狗 神兽 初来乍到，感觉什么都很新鲜，一路上用手机记录下沿途的风景，拍的有点多，后来去了京东清水寺，伏见稻荷神社发现高津宫就是小case，不过这个神社是日本人自己会来的（看见很多日本人来这里祭拜，投币拍手👏然后双手合十祈福），而那些都是游客去的，各有特色吧。 黑门市场来大阪怎么可能不吃小吃，吃小吃怎么可能不来黑门市场（小吃一条街），我们大概吃了5，6种小吃，由于是吃货，吃完才发现没有拍照。评分很高的章鱼小丸子我倒是不感冒，不过和牛倒是值得一试，特别是网上查的这家店（黑门市场几乎也都是中国人，大众点评很流行） 黑门市场 和牛（贵呀） 来一片，就是这家店的牛肉还有食客证。拍照 大丸百货吃完就是shopping了，来到了心斋桥附近的大丸百货，途径道顿掘 天公不作美，下雨了。 道顿掘怎么可能少得了这个标志呢，哈哈，感觉他跑很久了 好了，购物的就不看了，附一张老婆要的阿尔滨吧，后面的每天在补blog。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（一）]]></title>
    <url>%2F2019%2F06%2F27%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。 行程（2019-06-01）此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。 出发我们是从香港出发的，为了赶上12点多的飞机，早上起了个大早去深圳湾过关 坐了个商务车直达香港机场 接着就是托运行李等飞机啦。。。。。省略一万字，怀着不那么激动的心情终于降落到了关西机场 接着就是入境啦 入境就是填个单证明你来这里是要回去的，要有在日本酒店地址/电话，还要提供返程机票等，入境后有个小插曲，我有两个行李箱，然后出去后发现只有一个了，小的行李箱被我丢在里面了，然后只能用蹩脚的英语跟边境人员解释，最终还是顺利拿回来了。我们在大阪住的是在airbnb上订的名宿，在大阪市区，离周围的什么黑门市场，心斋桥，道顿掘都比较近。 大阪出了机场就是地铁了站（火车站），日本的地铁火车系统很发达，刚去的话坐车肯定是一脸懵逼，因为他们那边地铁站和火车站是一起的，各种运营线路，各种坐车套餐（我到现在还有些不清楚）。下面是关西机场的JR和南海电铁 我们去住的地方在难波附近，离的最近的地铁站叫九丁目，顺便说一句，国外Google Map是真好用，特别是日本的地铁火车很准时而且每趟车停的站是不一样的，它有普通，快速，特快之类的，上错车的概率是很大的，所以基本靠问和Google Map，google map完全就是神器。我们坐了南海电铁大概一个半小时到了地铁站 一出站就两个小姐姐现场表演，驻足看了下很Hi，但是太累了，而且也要尽快找到住的地方，所以没有多留，直接Google Map导航去民宿。 终于找到了 住的地方（好小啊，不过，五脏俱全） 晚上9点到民宿，还没吃饭，就下去附近逛逛觅食，诶，找到一家 图太多了，后面再讲吧！]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熵]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%86%B5%2F</url>
    <content type="text"><![CDATA[什么是熵为了理解熵，必须讲一点物理学。 19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。 后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。 能量的状态熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？ 物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。 上图中，能量转化会新生成大量的状态，那么状态多意味着什么呢？ 熵的另外一种解释状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：能量转换会让系统的混乱度增加，熵就是系统的混乱度。 熵的英文名为Entropy，我觉得这个翻译的人（胡刚复教授于1923年根据热温商之意首次把entropie译为“熵”）确实很牛逼，翻译的名字很好听。熵低则混乱度低，熵高则混乱度高。 转换的能量越大，创造出来的新状态就会越多，因此高能量系统不如低能量系统稳定，因为前者的熵较大。而且，凡是运动的系统都会有能量转换，热力学第二定律就是在说，所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。 举个例子： 冰块是分子的有序排列，能量释放后，变成液体水，分子排列变得无序。那么冰这个系统里的熵就比较低，而水这个系统的熵比较高。 熵：一种新的世界观熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。为什么”世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。 这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。 工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。 我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。我们需要能量，让世界变得有秩序，但这样是有代价的。物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。 感想人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。（能量守恒定律告诉我们地球的能量肯定是固定的，那么当人类能利用完地球上所有的能量（不一定能利用完），而假设没有外部能量输入，则这个时候的熵如果大到一定程度是不是就是人类悲剧的开始，比如核弹，病毒等。另外一种可能，为了一部分地区的有序和稳定，牺牲了另外一部分地区的有序和生态，而目前好像就是如此，人类破坏了其它生物的家园而将自己的家园建设的越来越好）。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>热力学第二定律</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin之集合操作符]]></title>
    <url>%2F2019%2F03%2F28%2FKotlin%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。 成员引用Kotlin中允许你去将表达式当作参数传递，你也可以直接传递函数，跟Java8一样，如果你把函数转化为一个值的话，可以用成员引用 val getAge = Person::age 这个表达式叫做 成员引用 。它为创建一个直接调用方法或访问属性的函数值提供了一种简短的语法。双冒号将类名从你需要引用的成员（方法或属性）名中分隔出来。它所做的事情跟下面其实是一样的，但是更简洁（少了一个中间变量）： val getAge = { person: Person -&gt; person.age } 这个成员引用是lambda中的知识点，还有很多用法，需要去理解。 maxBy找出这个集合中根据某个字段排序最大的值，可以仔细观察下面代码，它们的结果和意思完全一样。 123456789101112/** * list操作符之maxby */fun listOperatorMaxBy()&#123;//当lambda表达式是最后一个参数的时候可以不要（），直接用&#123;&#125; val people = listOf(Person2("Bob",24), Person2("Alice",42)) println(people.maxBy &#123; it.age &#125;) println(people.maxBy &#123; person2 -&gt; person2.age &#125;) people.maxBy(Person2::age)&#125; transform/joinString12345678910111213/** * list操作符之transform/joinToString */fun listOperatorTransform()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42)) val names = people.joinToString(separator = "，",postfix = ": ",transform = &#123;p: Person2 -&gt; p.name&#125;) val names1 = people.joinToString("","","",1) &#123; p -&gt; p.name &#125; println(names) //Bob，Alice: println(names1) //Bob&#125; filter根据条件过滤操作123456789101112131415161718/** * list操作符之filter */fun listOperatorFilter()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) //但是要注意，这份代码为每个人重复了最大年龄的查找步骤。所以，如果集合中有100个人，最大年龄的搜索将会执行100次！ people.filter &#123; it.age == people.maxBy(Person2::age)!!.age &#125; //people.filter &#123; it.age == people.maxBy&#123;person2 -&gt; person2.age&#125;!!.age &#125; //只计算了一次最大值 var maxAge = people.maxBy(Person2::age)?.age people.filter &#123; it.age == maxAge &#125;&#125; all，any，count，find等1234567891011121314151617181920212223242526/*** * list操作符all，any * list是否包含了所有这个条件 */fun listOperatorAllAny()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) val conditions = &#123;p: Person2 -&gt; p.age &gt; 25&#125; //全部匹配条件 people.all(conditions) // false people.all &#123; p:Person2 -&gt; p.age &gt; 23 &#125; // true //有一个匹配条件的 people.any(conditions) // true //有多少个符合条件的 people.count(conditions) // 2 // 查找哪个是符合条件的(如果有多个元素，函数将返回第一个匹配的元素。 // 如果没有满足的元素，函数返回 null 。 find 的一个同义词是 firstOrNull 。 // 如果如能够更加清晰的表达你对想法，你可以使用) people.find &#123; p:Person2 -&gt; p.age &gt; 23 &#125; //Alice,Ervin people.firstOrNull(conditions)&#125; groupBy分组操作符，想象一下，你需要根据你某些特性来将所有元素分割成不同的组。例如，你想把年龄相同的人放在一组。把这个特性直接作为一个参数进行传递非常方便！ 12345678910111213141516/** * list操作符groupBy */fun listOperatorGroupBy()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42), Person2("Ervin",34), Person2("Anny",34)) people.groupBy &#123; it.age &#125; //每一组都被保存成一个列表。所以结果的类型为 Map&lt;Int, List&lt;Person&gt;&gt; 。 // 你可以使用像 mapKeys 和 mapValues 这样的函数对这个映射做更多的修改。 print(people.groupBy &#123; it.age &#125;[34])&#125; groupBy之后返回结果是一个Map集合，最后print(people.groupBy { it.age }[34])中[34]其实是输出以34为key的Person。 map和flatMap这两个操作符在RxJava中是使用频率很高的操作符，map是对一个基本类型做一个转换，例如string -&gt; int，而flagMap则是将上游的observerable变为另外一个observerable。Kotlin中，map其实也是类型转换的意思，flatmap则是将集合中每个元素映射（map），然后把多个列表合并成一个。最终，其实它是一个集合 flatMap 函数做了两件事：首先它根据作为参数而给定的函数把每一个元素都变换（或映射）到一个集合中。然后它把多个列表合并为一个。有一个处理字符串的案例很好的解析了这个概念 123456789101112/** * list操作符flatMap */fun listOperatorMap()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) print(people.map &#123; it.name + "'s" &#125;) //[Bob's, Alice's, Ervin's] print(people.flatMap &#123; it.name.toList() &#125;) //[B, o, b, A, l, i, c, e, E, r, v, i, n]&#125; sequence 集合的序列操作，这个是很有用的东西。一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择，举个例子： NOTE 注意 一般来说，无论何时，你在大型集合中有链式操作时，请使用序列。在8.2一节，我们将会讨论为什么在Kotlin中，常规集合的延迟操作是高效的，尽管它会创建中间的集合。但是如果集合包含大量的元素，中间的元素重拍耗时巨大，所以延迟计算更 加可取。 1234567891011121314151617181920212223242526/** * list的序列操作 * * 一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择 */fun listOperatorSequence()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) //集合的链式调用 /** * Kotlin标准库参考（文档）指出， filter 和 map 都返回一个列表。这意味着这个链式调用将会创建两个列表：一个保存 filter 函数的结果，另一个存储 map 函数的结果。 * 当原来的列表只有包含两个元素时，这不会有问题。但是如果你有百万个元素时，这会变得非常低效。 为了把它变得更加高效，你可以转换这个操作。 */ people.map(Person2::name).filter &#123; it.contains('A') &#125; //序列的操作 /** * 没有保存元素的中间集合，对于元素比较大的集合来说，性能会有客观的改善 */ people.asSequence() //初始集合转化为序列 .map(Person2::name) .filter &#123; it.contains('A') &#125; .toList() //序列转化为集合&#125; 集合本身的操作是实时的，而序列的操作是懒加载式的，下面会详细说明序列的中间操作和最终操作 序列的中间和最终操作 看一个例子 123456789101112131415161718192021/** * list的序列操作之不同点 */fun listOperatorSequence1()&#123; //sequence的操作 //map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; print( "map($it) " ); it * it &#125; .filter &#123; print( "filter($it) " ); it % 2 == 0 &#125; .toList()//最终操作 //集合本身操作 //map(1) map(2) map(3) map(4) filter(1) filter(4) filter(9) filter(16) listOf( 1 , 2 , 3 , 4 ) .map &#123; print( "map($it) " ); it * it &#125; .filter &#123; print( "filter($it) " ); it % 2 == 0 &#125;&#125; 注意看sequence结果：map和filter是交替进行的，每个元素都是先map再filter，这证明了sequence是延迟计算的。而集合本身则是所有元素先map（中间集合），再用中间集合去filter。sequence中没有最后的toList（最终操作），则什么都不会输出。 最终操作导致所有的延迟计算都被执行了。 还有一个更重要的事要注意，在这个例子中，计算的执行顺序。原始的方法首先将会对每个元素调用 map 函数，然后对结果序列中的每个元素调用 filter 函数。这就是 map 和 filter 在集合上如何工作的。但序列并不是这样的。对于序列来说，所有的操作都会逐个应用于每个元素：处理完第一个元素（映射，然后过滤），然后处理第二个，以此类推。 这个方法意味着如果过早获取结果，某些元素根本不会被变换。我们来看一个有 map 和 find 操作的例子。首先，你把一个数映射为它的平方，之后你查找当中第一个大于３的元素（find操作符的作用）： 1234567fun listOperatorSequence2()&#123; print(listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; it * it &#125; .find &#123; it &gt; 3 &#125;)&#125; 如果同样的操作应用于一个集合而不是序列，那么首先会计算 map 的结果，变换初始集合中所有的元素。第二步，在中间集合中发现一个满足预言的元素。使用序列，惰性方法意味着你可以提阿偶偶处理某些元素。下图解释了（使用集合）提前和延迟（使用序列）方式执行这份代码的不同点。 集合提前计算对整个集合运行每一个操作，惰性求值则逐个计算（元素多的时候效率高，性能好） 再看一个例子啊： 123456789101112131415161718192021222324252627fun listOperatorSequence2()&#123; println(listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; it * it &#125; .find &#123; it &gt; 3 &#125;) val people = listOf(Person2("Bob",24), Person2("Alice",42), Person2("Ervin",34), Person2("Dan",34) ) /** * 先filter有助于减少变换的总次数， * 如果先进行 map ，每个元素都会进行变换。 * 但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。 */ //先map再过滤 println(people.asSequence().map(Person2::name).filter&#123; it.length &lt; 4&#125;.toList()) //println(people.asSequence().map&#123; person: Person2 -&gt; person.name&#125;.filter &#123; it.length &lt; 4 &#125;.toList()) //先过滤再映射 println(people.asSequence().filter&#123;it.name.length &lt; 4&#125;.map(Person2::name).toList())&#125; 先filter有助于减少变换的总次数。如果先进行 map ，每个元素都会进行变换。但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。 流 vs 序列 如果你熟悉Java 8的流，你将会看到，（Kotlin的）序列是完全一样的概念。由于Java 8的流在使用旧版本的Java搭建的平台中无法使用，比如Android，所以Kotlin提供了它自己的轮子。如果你把Java 8作为目标平台，流会给你带来一个很大的好处。但是，Kotlin的集合与序列并未实现在多个CPU上并行执行流操作（ map() 或者 filter() ）的能力。你可以基于你面向的Java版本和你的具体要求来选择流和序列。 实例代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Https证书详解]]></title>
    <url>%2F2019%2F03%2F21%2FAndroid%20Https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。 TLSTLS是基于 X.509 认证，他假定所有的数字证书都是由一个层次化的数字证书认证机构发出，即 CA。另外值得一提的是 TLS 是独立于 HTTP 的，任何应用层的协议都可以基于 TLS 建立安全的传输通道，如 SSH 协议。 CAHttps通信过程中需要交换服务器的公钥，但是怎么确保公钥就是服务器的公钥呢，就需要引入了一个第三方，也就是上面所说的 CA(Certificate Authority)。CA 用自己的私钥签发数字证书，数字证书中包含A的公钥。然后 B 可以用 CA 的根证书中的公钥来解密 CA 签发的证书，从而拿到合法的公钥。那么又引入了一个问题，如何保证 CA 的公钥是合法的呢。答案就是现代主流的浏览器会内置 CA 的证书。我们可以在浏览器中看到Https网站的证书信息： 中间证书当然，现在大多数CA不直接签署服务器证书，而是签署中间CA，然后用中间CA来签署服务器证书。这样根证书可以离线存储来确保安全，即使中间证书出了问题，可以用根证书重新签署中间证书。上图中第三级就是中间证书了。 Android配置HttpsAndroid 使用的是 Java 的 API。那么 Https 使用的 Socket 必然都是通过SSLSocketFactory 创建的 SSLSocket，当然自己实现了 TLS 协议除外。目前Android使用的网络通信基本都是Okhttp了，OK默认就支持Https，当你不配置的时候，它默认是支持在Android内部默认安装的100多个证书，在Android设置中可以看到这些内置根证书（会自动更新）。 如果你的后端证书是购买的那么基本就是这些内置根证书中的一种了，你可以不需要任何改动，直接就可以从Http过渡到Https（直接修改BaseURL），但是如果后端使用的是自制证书，那么你就必须要配置了（如果不配置会报证书锚点找不到的错误）。 SSLSocketFactory 创建SSL的工厂类，默认是这样实现的： 123456789 private synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, null, null); return defaultSslSocketFactory = sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); // The system has no TLS. Just give up. &#125;&#125; TrustManager 上文说了，SSL 握手开始后，会校验服务器的证书，那么其实就是通过 X509ExtendedTrustManager 做校验的，更一般性的说是 X509TrustManager : 1234567891011121314/** * The trust manager for X509 certificates to be used to perform authentication * for secure sockets. */public interface X509TrustManager extends TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException; public X509Certificate[] getAcceptedIssuers();&#125; 那么最后校验服务器证书的过程会落到 checkServerTrusted 这个函数，如果校验没通过会抛出 CertificateException 。很多博客说，配置 SSL 差不多是这样的: 12345678910111213141516171819202122private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, new TrustManager[]&#123; new X509TrustManager() &#123; public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; &#125;, null); return sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); &#125;&#125; 这个是信任所有证书的，包括自制证书，相当于客户端不会去检查证书的签名。这么做毫无安全性可言，一般不要这么做 SSL的配置Android中SSL的配置，可以不配置（系统会默认信任Android内置证书），但是如果用系统默认的 SSL，那么就是假设一切 CA 都是可信的。可往往 CA 有时候也不可信，比如某家 CA 被黑客入侵什么的事屡见不鲜。虽然 Android 系统自身可以更新信任的 CA 列表，以防止一些 CA 的失效。那么为了更高的安全性，我们希望指定信任的锚点（我们信任的证书），可以类似采用如下的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by Ervin on 2017/3/14. */public class CertificationFactory &#123; public static SSLContext getSLLContext(Context context)&#123; SSLContext sslContext = null; try &#123; //取得本地证书的流 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); InputStream cerInputStream = context.getAssets().open(&quot;root.crt&quot;); Certificate ca = cf.generateCertificate(cerInputStream); //创建Keystore包含我们的证书 String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // 创建一个 TrustManager 仅把 Keystore 中的证书 作为信任的锚点 String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); TrustManager[] trustManagers = tmf.getTrustManagers(); // 用 TrustManager 初始化一个 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, trustManagers, null); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sslContext; &#125;&#125; 在Okhttp中开启配置： 1234567891011httpClient = new OkHttpClient .Builder() .addInterceptor(new TokenValidInterceptor(this.context)) .addInterceptor(new HttpRespV3ConvertInterceptor()) .addInterceptor(loggingInterceptor) //开启SSL配置 .sslSocketFactory(CertificationFactory.getSLLContext(this.context).getSocketFactory()) .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .build(); 这样的话Okhttp会只信任“root.crt”以及被它签发的证书才会被信任。这里有个地方要注意：这里的root.crt在我的项目中代表了CA的根证书（第一级的证书，也许也是中间证书，过期时间比较久），还有一种证书是用这个root去签发的，在你购买证书后会给你去服务器配置的。因为在实际情况中，一般购买的证书（子证书）有效期都是2年左右，如果客户端信任这个子证书那么也就是2年后证书过期，你的APP就不能用了，因此我们考虑了使用根证书，（根证书默认会信任他以及他所签发的证书），这样子证书到期后，只要还用这家CA的证书签发一个子证书，APP还是会继续信任。这样比起信任100多个根证书，我只信任一个要安全得多。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QUANTUMULT的配置]]></title>
    <url>%2F2019%2F03%2F18%2FQuantumult%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。 老板由于已知的原因，时隔半年回归。寄语：“Whatever does not kill us makes us stronger.” - Friedrich Nietzsche 这里Quantumul讲的很详细，这里就不多啰嗦了，后续还会更新最新的FQ技术及方法。 Mac：shadowsocksR-NG-R，ClashXIOS：quantumul,shadowrockets,surgeAndroid: SSR,ClashNG,… 配置教程]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的简单配置]]></title>
    <url>%2F2019%2F03%2F14%2Falfred%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景Alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧 获取从官网就可能下载使用Alfred了，但是想用他的完整功能，比如workflow就要激活powerpack了，在天朝这些都不是问题，推荐几个Mac软件搬运工网站： 大名鼎鼎的xclinet 域名很黄的waitsun 未来软件园 等等吧，收藏夹里一堆。 基础功能介绍首先是启动alfred了，一般为避免和spotlight快捷键冲突，会将alfred启动快捷键设置为：double cmd。这样也确实挺方便的 搜索这个是最简单最基础的功能了，alfred自带了一些查询，例如： 只要输入关键字，就可以打开浏览器Google一下你要的内容了，alfred会自动匹配所有和关键字相关的内容（10个）给你选择。你也可以自己设置自定义的搜索规则： Clipboard剪切板功能也是一个很赞的功能，我的使用频率也是最高的之一，一般快捷键设置为：cmd+option+C。会弹出最近你所复制的文本，图片，甚至文件。如果一段文字你需要多次用到，那么这个将会大大提高你的效率。 System这个功能主要是你可以使用alfred的感觉真关机，待机，锁定屏幕等等。 Terminal/shell这个是由于我在Mac上使用的是程序员专用的iTerm命令行工具，然后Alfred可以通过“&gt;”来开启命令行（很好的功能），但是它默认使用的是mac系统自带的terminal，如果你想开启iTerm，那么： Preference - Terminal/shell - Application:custom 1234567891011121314151617181920212223242526272829303132333435363738394041424344//适用于iTerm2on alfred_script(q) if application &quot;iTerm2&quot; is running or application &quot;iTerm&quot; is running then run script &quot; on run &#123;q&#125; tell application \&quot;:Applications:iTerm.app\&quot; activate try select first window set onlywindow to false on error create window with default profile select first window set onlywindow to true end try tell current session of the first window if onlywindow is false then tell split vertically with default profile write text q end tell end if end tell end tell end run &quot; with parameters &#123;q&#125; else run script &quot; on run &#123;q&#125; tell application \&quot;:Applications:iTerm.app\&quot; activate try select first window on error create window with default profile select first window end try tell the first window tell current session to write text q end tell end tell end run &quot; with parameters &#123;q&#125; end ifend alfred_script WorkFlow这个是收费功能，也是alfred可以拥有无限可能的功能，他类似于IOS中的捷径（其实原来也叫workflow，被Apple收编后叫捷径） 下面简单介绍几个有用的workflow： New Filemac上新建文件是个比较蛋痛的事，一般人还新建不来。如果有这个就好办了。该插件默认启动关键字是：new。默认情况下，你可以直接新建 TXT、MD、自定义文件类型这三种类型的文件和目录。其中 TXT、MD 格式也是比较常用的文本格式，插件就将这两种类型的文件直接作为了默认文件类型。真是非常贴心！ TerminalFinder看名字就知道是Finder和Terminal互相切换的，有时候我们在Finder中想开启命令行，还有时候在命令行中打开了一个目录又想在Finder中显示。用这个吧。 有道词典系统自带的词典，查找起来不太方便，alfred的workflow中使用yd关键字就能英汉互查 好用的workflow其实有很多，需要大家去发掘去使用，但是另一方面我们其实也用不到那么多功能，所以还是适合自己的才是最好的。 搜索插件workflow插件是傻瓜式的，直接下载.workflow文件下来后，点击就能安装了。下面给几个下载workflow的网站： Packal alfredflow 还有就是Google了。。。。。 配置最后，如果你有多台mac之间都在用alfred，你想使用一个配置文件，那么你就要使用同步功能了。坑爹的是，aflred默认是不同步的（连iCloud都不支持），它只是把配置文件保存在本地，那么怎么才能同步呢，上图： 说白了也就是自己把配置文件上传到云端，多端同步。 最后，其实这个blog只是我使用的一个简单介绍或者记录，alfred还有很多高级功能没有去涉及，还是希望能帮助到别人吧。生命在于折腾！]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常规配置]]></title>
    <url>%2F2019%2F02%2F28%2Fgit%E7%9A%84%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Markgit的全局和单个仓库的用户名和邮箱的配置 全局 1234git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot;//查询git config --list 某个仓库 12git config user.name &quot;name&quot;git config user.email &quot;email&quot; 未完待续，持续更新。。。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android后期开发的几个方向]]></title>
    <url>%2F2019%2F02%2F25%2FAndroid%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[背景从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。 移动端未来的几个方向动态化目前我们项目已经在尝试走组件化和插件化，前两年，插件化火起来了，为什么火呢，因为可以实现Android不用发布版本就可以热更新，但是插件化有自己的问题，就是兼容性。Android机型太多（马上要出折叠屏了），插件化框架难免要涉及到系统API的hook，兼容性问题就出现了，开发者会莫名其妙碰到各种错误，随着Android版本迭代，插件化这条路越来越不好走，Android P给了开发者一个信号，不能再随便hook系统API了，Google要开始整顿了。然后，另外一个动态化就是Hybrid开发了，利用H5和原生混合开发（目前最为流行的开发方式），例如老牌的Cordova，Facebook的React-Native（通过Jscore进行js解析，使得原生View进行渲染，提供桥机制调用原生的能力）。RN是第一个真正的高性能动态框架，它的出现让Web前端和客户端的界限变得模糊。随之而来的是各个大公司的自研框架，例如阿里巴巴的Weex和美团的Picasso框架，RN只提供了Android和IOS的支持，Weex扩展了思路，提供了Web端的支持，一个是React语法糖，一个Vue语法糖。另外，Google自己在2018年下半年正式推出了自己的跨平台方案—Flutter（前面Blog已经写过），通过Dart编写APP，然后编译成机器码运行在IOS和Android上，对开发者最好的是Hot reload，而且做到了原生跨平台。 移动端机器学习毫无疑问，移动端机器学习从2017年年底就开始火起来了，TensorFlow 也推出了移动端框架，很多应用都开始在移动端部署机器学习模型，例如相机类应用（FaceU）、电商类应用（唯品会）等，包括离线的机器学习。如果深挖这个方向，我觉得十年内不会被淘汰。当然了，难度也不小。 AR和VR从支付宝的 AR抢红包、QQ的AR踢球等玩法被越来越多的人体验，AR走进了人们的视野。对于广告引流玩法来说，AR无疑是能带来巨大收益的。那么开发AR引擎的移动开发者自然成了香饽饽，目前AR主要应用的领域是广告变现，不过很多公司也找到了AR的一些落地场景，如果是研究OpenGL，计算机图形学的移动开发者，可以往AR引擎开发方向发展，非常有前景。 移动端音视频 这个领域最火的就是抖音了，还有各种相机，图片应用等都需要音视频开发领域的专业开发人员，图像处理，滤镜，剪裁等，研究OpenGL，计算机图形学的移动开发者在这个领域也有很大的优势 移动端区块链在人人都知道比特币的时候，背后的区块链技术也得到了大家的拥护，区块链应用目前最多的还是数字钱包，但是未来应该会有更多的落地方式，例如Status。如果有移动开发同学对区块链方向感兴趣的，可以开始研究起来了。如果要学习智能合约开发的同学，我推荐一个非常好的网站：Cryptozombies，绝对是入门 solidity 智能合约开发的精品。 目前移动端的区块链人才还不多，各大公司也没有在招，但是两三年内，应该就会爆发了，现在还在探索落地场景的阶段，也给了对区块链技术感兴趣的移动开发同学学习的时间。改变世界的技术了解一下？ 移动端基础框架UI未来可能都会被动态化技术接管，但是移动基础框架不会。一个APP总要有网络请求，日志处理，ORM，缓存，PUSH等框架，这部分和UI关系不大，但是是组成APP不可或缺的部分。框架其实就是轮子，我们用轮子用的很溜并不代表你的代码能力很溜，而是人间写的轮子很溜，好的轮子就是无论开发者代码能力好坏，写出来的功能和性能都是差不多的，比如Retrofit，OKhttp等。在这些框架基础上P5和P7写的代码不会有多大差别。然后，轮子总要有人写，而且大公司的需求可能开源的轮子不满足，这时候就要自创轮子了。写轮子就需要开发者的知识深度和广度了，需要沉淀和学习。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画总结]]></title>
    <url>%2F2019%2F02%2F16%2FAndroid%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：lottie,SVGA 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。) 动画分类各自特点及区别Android动画主要分为视图动画和属性动画，视图动画只有透明度，旋转，平移，伸缩四种，而属性动画则是只要是对象的属性且有setter该属性的方法就可以对该属性执行一种动态变化效果。视图动画主要是使用Animation，组合动画使用AnimationSet，而属性动画主要是Animator，组合使用AnimatorSet。视图动画主要就是四种操作，对对象的颜色，背景等就无能为力了。相对来说，属性动画会更精细点，能实现更多更好的效果。 视图动画视图动画很早就出现在Android中，主要在android.view.animation包下面，这里可以看到主要是对View进行操作的，里面有很多的类帮助我们实现一些简单动画效果，如对view进行移动，缩放，旋转，淡入淡出等，并且我们可以借助AnimationSet将这些动作组合起来 补间动画（Tween Animation） 名称 原理 对应Animation 子类 平移动画 移动视图位置 TranslateAnimation 缩放动画 放大缩小视图 ScaleAnimation 旋转动画 旋转视图位置 RotateAnimation 透明度动画 改变视图透明度 AlphaAnimation 逐帧动画（Frame Animation） 这个类似动画片，一帧一帧播放，每一帧是一张图片，按顺序去播放一组预先定义好的图片，简单方便，但是容易OOM，占资源 属性动画属性动画在Android3.1的时候才引入到Android中，主要在android.animator包下面。属性动画机制已经不仅仅是针对View来设计了（看包名就知道），也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不在是视觉上的动画效果了。它实际上是一种不断对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性（真的改变了对象属性）。属性动画的工作原理和逻辑： 步骤2中的插值器，默认会有一些系统自带的插值器，如下表，表示的是初始值到结束值的一个变化关系，关系到动画的一个显示效果。 名称 描述 插值器（Interpolator） 值的变化模式（匀速,加速） 估值器（TypeEvaluator） 决定值的具体变化数值 插值器名称 描述 AccelerateDecelerateInterpolator 先加速再减速 AccelerateInterpolator 先加速再一直加速 AnticipateInterpolator 先往后一下，再加速往前 AnticipateOvershootInterpolator 先往后一下，再一直往前超过终点，再往回收一下。 BounceInterpolator 最后会回弹一下 CycleInterpolator 重复几次，感觉就是环形进度条那种，具体我还没试过 DecelerateInterpolator 一直减速 LinearInterpolator 线性匀速 OvershootInterpolator 到了终点之后，超过一点，再往回走。有个参数可以定义，超过的力度。 ValueAnimator 定义：通过不断控制值的变化，再不断手动赋值给对象的属性，从而实现动画效果。如下图： 用法 ObjectAnimatorObjectAnimator继承自ValueAnimator测试Hexo本地是否要保留原文件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SBT环境搭建]]></title>
    <url>%2F2019%2F01%2F30%2FSBT%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景 由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做个记录（凑数）。 步骤 前提必须要装JDK，sbt也是运行在JVM上的，所以需要java的环境，没有环境sbt会提示你先要装JDK，然后就是配置好环境变量了。 下载IDE现在宇宙IDE非IDEA莫属了（VS Code表示不服），前后端主要的平台都支持，AndroidStudio就是基于这个IDE写的。咱也熟。下载完成后下载插件：Scala和Sbt。下载完成后重启IDE，导入Sbt项目后，会自动在右侧多了个sbt编译按钮 下载sbt sdk这里要下载sbt最新版本（好像是1.2.+），配置好环境变量，在命令行测试命令：sbt或者sbt test。这样在user目录下会生成一个.sbt目录。 配置私服访问一般上面三步基本就能配好环境。直接导入代码就可以使用sbt编译了，但是我们的后端很多依赖包是在自己公司搭建的私服上的，所以还需要配置访问私服的密钥和路径。（问人的，这个貌似很多文章都找不到），生成两个文件（一个私服仓库的路径文件，一个授权访问私服的文件）见图：需要放在上面所说的.sbt文件中。 这里还有一个很坑人的地方，导致你编译失败，代码一片红，因为我们在上面的私服仓库路径文件里面配置的第三方依赖包和我们自己仓库的依赖包都会同时下载，但是基于经验判断我们下载自己仓库的包的时候先决条件是需要把第三方包都下载好，这样如果同时下载会导致所有包都下不下来（坑），这时候就需要根据经验先下载一些优先的第三方包，注释掉另外一些路径，等下载完成后再打开这些路径，接着下载所需的私有仓库中的包。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>scala，sbt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin常用操作符]]></title>
    <url>%2F2019%2F01%2F03%2FKotlin%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[操作符？操作符表示这个对象可能为空 12//在变量后面加？，代表这个变量可以为空var name: String? = &quot;zhangsan&quot; 1234//如果str不能转为Int类型，则返回nullfun parseInt(str: String): Int?&#123; //&#125; 12// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？b?.length ?:操作符如果操作符左边表达式不为空用左边表达式结果，为空则用右边的值。类似三元运算符1234val l: Int = if(b!=null) b.length else -1// 除了完整的if表达式，这个还可以用Elvis操作符来表示：val l = b?.length ?: -1// 如果?: 左侧表达式非空，elvis操作符就返回左侧表达式的值，否则返回右侧的值。 注意：当且仅当左侧为空时，才会对右侧表达式求值。 ！！操作符一定是非空的值 12//这会返回一个非空的b值，或者如果b为空，就会抛出空指针异常var l = b!!.length == 与 ===这个类似java中的 == 和 .equals() == 判断值是否相等，=== 判断值及引用是否完全相等。 12345val num: Int = 128;val a:Int? = numval b:Int? = numprintln(a == b) //trueprint(a === b) //false ..符号以及 in 和 !in 操作符..代表从x到y，==包括x和y,这是一个闭区间==运算符，而until则是半闭区间运算符，代表从a到b范围内所有的值，==包括a和不包括b==。in代表在一个区间中，！in代表不在一个区间中。 123456if(i in 1..10)&#123; //等价于 1 &lt;= i &lt;= 10 println(i) &#125;使用until函数，创建一个不包括其结束元素的区间for(i in 1 until 10)&#123;&#125; // i in [1,10) downTo()函数倒叙遍历，区间内循环 1for(i in 4 downTo 1)&#123;&#125; //print(i) -- 4321 step函数可以进行任意数量的迭代 12for (i in 1..4 step 2) print(i) // prints &quot;13&quot;for (i in 4 downTo 1 step 2) print(i) // prints &quot;42&quot; ::符号得到类的Class对象 1startActivity(Intent(this@KotlinActivity, MainActivity::class.java)) @符号限定this的类型 123456789101112class User &#123; inner class State&#123; fun getUser(): User&#123; //返回User return this@User &#125; fun getState(): State&#123; //返回State return this@State &#125; &#125;&#125; 作为标签跳出双层循环123456789101112loop@ for (itemA in arraysA) &#123; var i : Int = 0 for (itemB in arraysB) &#123; i++ if (itemB &gt; 2) &#123; break@loop &#125; println(&quot;itemB:$itemB&quot;) &#125;&#125; ==命名函数自定义标签：== 1234567891011121314fun fun_run()&#123; run &#123; println(&quot;lambda&quot;) &#125; var i: Int = run &#123; return@run 1 &#125; println(&quot;$i&quot;) //匿名函数可以通过自定义标签进行跳转和返回 i = run (outer@&#123; return@outer 2 &#125;) println(i)&#125; 从forEach跳出 12345678910111213141516171819202122fun forEach_label(ints: List&lt;Int&gt;)&#123; var i =2 ints.forEach &#123; //forEach中无法使用continue和break;// if (it == 0) continue //编译错误// if (it == 2) /*break //编译错误 */ print(it) &#125; run outer@&#123; ints.forEach &#123; if (it == 0) return@forEach //相当于在forEach函数中continue,实际上是从匿名函数返回 if (it == 2) return@outer //相当于在forEach函数中使用break,实际上是跳转到outer之外 &#125; &#125; if (i == 3) &#123; //每个函数的名字代表一个函数地址，所以函数自动成为标签 return@forEach_label //等同于return &#125;&#125; as?操作符当使用as转型的时候，可能经常出现ClassCastException。所以，现在可以用==as?安全转型==，当转型不成功的时候，它会返回null。 注意：在使用intent传值的时候，会出现空字符串不能用as强制转型，应该使用as? 1val m: Int? = a as? Int 冒号：用于类的继承，变了的定义 类型和超类型之间的冒号前要有一个空格 实例和类型之间的冒号前不能用空格 12345//定义全局变量时var str: String? = null//类的继承与变量定义class TestActivity&lt;T : Serializable&gt;(str: String) : Activity&#123;&#125; 类型判断符is检查某个实例是否是某个类型，如果判断出属于某个类型，那么判断后的分支中可以直接可当该类型使用，==无需显示转换== 123456fun getStringLength(obj: Any): Int? &#123; //obj在&amp;&amp;右边自动动转换成&quot;String&quot;类型 if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null &#125; $操作符字符串可以包含模板表达式，及一小段代码，会求值并把结果包含到字符串中。模板字符串以美元符号$开头，由一个简单的名字构成： 12val value:Int=5;val str:String=&quot;the value is $value&quot; 标准函数run 、 apply 、 let 、 also 和 with 五个函数均位于 kotlin 包下的 Standard 文件中，其含义和用法比较相似，现分别介绍如下。 run run函数使用的一般结构 12object.run&#123;&#125; run函数的inline+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block() 结构分析run函数实际上可以说是let和with的结合体，run函数只是接受一个lambda函数作为参数，以闭包形式返回，==返回值为最后一行的值或者指定的return的表达式== 例子 1234567891011121314151617181920212223//kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = user.run &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//java public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var5); int result = 1000; String var3 = &quot;result: &quot; + result; System.out.println(var3); &#125; 适用场景适用于let，with函数任何场景，因为run函数是let，with两个函数的结合体，它既弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样省略，直接访问实例的公有属性和方法，另一方面也弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理 run函数使用前后对比 不使用run函数12345678910111213override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; val item = getItem(position)?: return with(item)&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; 使用run函数 123456789101112override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; getItem(position)?.run&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) // 可以看到直接省略了item，并且可以在之前判空 holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; let let函数的一般结构 123456789object.let&#123;it.todo()//在函数体内使用it替代object对象去访问其公有的属性和方法...&#125;//另一种用途 判断object为null的操作object?.let&#123;//表示object不为null的条件下，才会去执行let函数体it.todo()&#125; let函数底层的inline扩展函数+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) 结构分析从源码let函数来看，它是一个只有一个lambda 函数块block作为参数的函数，调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过it指代该对象，返回值为函数块的最后一行或者指定return表达式。 let函数的kotlin和java转化 1234567891011121314151617181920212223 //kotlin fun main(args: Array&lt;String&gt;) &#123; val result = &quot;testLet&quot;.let &#123; println(it.length) 1000 &#125; println(result) &#125;//返回值：7/1000 //java public final class LetFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); String var2 = &quot;testLet&quot;; int var4 = var2.length(); System.out.println(var4); int result = 1000; System.out.println(result); &#125;&#125; let函数适用的场景最常用的场景就是使用let函数处理需要针对一个可以null的对象统一判空处理。 let函数的前后对比 没有使用前： 123mVideoPlayer?.setVideoView(activity.course_video_view)mVideoPlayer?.setControllerView(activity.course_video_controller_view)mVideoPlayer?.setCurtainView(activity.course_video_curtain_view) 使用后： 123456//对对象做了统一的判空处理mVideoPlayer?.let &#123; it.setVideoView(activity.course_video_view) it.setControllerView(activity.course_video_controller_view) it.setCurtainView(activity.course_video_curtain_view)&#125; with with函数的一般结构 12with(object)&#123;&#125; with函数底层的inline扩展函数+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() 结构分析with函数和前面几个函数使用方法略有不同，因为它不是以扩展的形式存在的。它是将某个对象作为函数的参数，==在函数块内可以通过this指代该对象==。返回值为函数块最后一行或者指定的return表达式。 可以看出with函数接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始的样子如下： 1234val result = with(user, &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125;) 但是由于，with函数最后一个参数是一个函数，可以把函数提到圆括号外部，所以最终with函数的调用形式如下：（可以看下kotlin的lambda表达式） 1234val result = with(user) &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; with函数的kotlin和java转化 1234567891011121314151617181920212223//kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = with(user) &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//java public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var4 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var4); int result = 1000; String var3 = &quot;result: &quot; + result; System.out.println(var3); &#125; with函数的适用场景 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBindViewHolder中，数据model的属性映射到UI上 with函数使用前后对比 没有使用： 12345678910111213141516@Overridepublic void onBindViewHolder(ViewHolder holder, int position) &#123; ArticleSnippet item = getItem(position); if (item == null) &#123; return; &#125; holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn)); holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary)); String gradeInfo = &quot;难度：&quot; + item.gradeInfo; String wordCount = &quot;单词数：&quot; + item.length; String reviewNum = &quot;读后感：&quot; + item.numReviews; String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum; holder.tvExtraInfo.setText(extraInfo); ...&#125; 使用了之后： 1234567891011121314override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; val item = getItem(position)?: return with(item)&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) //省略了item，直接调用了实例中的方法 holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; apply apply函数使用的一般结构 123object.apply&#123;//todo&#125; apply函数的inline+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; apply函数的inline结构分析 从结构上来看，apply函数和run函数很像，唯一不同点就是他们各自返回值不同，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回值则是传入对象的本身。 apply函数的kotlin和java转化 12345678910111213141516171819202122232425/kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = user.apply &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//输出：result：kotlin，1，111111（User本身对象被打印出来）//javapublic final class ApplyFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var5); String var3 = &quot;result: &quot; + user; System.out.println(var3); &#125; apply函数使用前后的对比 没有使用： 1234567mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = truemSheetDialogView.course_comment_seek_bar.max = 10mSheetDialogView.course_comment_seek_bar.progress = 0 使用后： 1234567891011//形成了链式调用mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123; course_comment_tv_label.paint.isFakeBoldText = true course_comment_tv_score.paint.isFakeBoldText = true course_comment_tv_cancel.paint.isFakeBoldText = true course_comment_tv_confirm.paint.isFakeBoldText = true course_comment_seek_bar.max = 10 course_comment_seek_bar.progress = 0&#125; 多层级判空问题 12345678910111213if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123; return;&#125;if (mSectionMetaData.questionnaire.userProject != null) &#123; renderAnalysis(); return;&#125;if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123; fetchQuestionData(); return;&#125; -&gt; 使用了apply后可以变为链式调用 1234567891011121314151617mSectionMetaData?.apply&#123; //mSectionMetaData不为空的时候操作mSectionMetaData&#125;?.questionnaire?.apply&#123; //questionnaire不为空的时候操作questionnaire&#125;?.section?.apply&#123; //section不为空的时候操作section&#125;?.sectionArticle?.apply&#123; //sectionArticle不为空的时候操作sectionArticle&#125; also also函数使用的一般结构 123object.also&#123;//todo&#125; also函数的inline+lambda结构 1234@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)//可以看到这个函数是从kotlin1.1开始才有的public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125; also函数的inline结构分析 also函数的结构实际上和let很像，唯一的区别是返回值不一样，let是以闭包的形式返回的，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值，而also函数则返回传入对象本身。这个和apply一样。 also函数的kotlin和java转化 12345678910111213141516171819202122//kotlinfun main(args: Array&lt;String&gt;) &#123; val result = &quot;testLet&quot;.also &#123; println(it.length) 1000 &#125; println(result)&#125;//结果：7/testLet//javapublic final class AlsoFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); String var2 = &quot;testLet&quot;; int var4 = var2.length(); System.out.println(var4); System.out.println(var2); &#125;&#125; 标准函数总结 函数名 定义inline结构 函数体内代指对象 返回值 是否是扩展函数 使用场景 let fun T.let(block: (T) -&gt; R): R = block(this) it 闭包返回 是 适用于处理不为null的操作场景 with fun with(receiver: T, block: T.() -&gt; R): R = receiver.block() this 返回闭包 否 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上 run fun T.run(block: T.() -&gt; R): R = block() this 闭包返回 是 适用于let,with函数任何场景。 apply fun T.apply(block: T.() -&gt; Unit): T { block(); return this } this 返回this 是 also fun T.also(block: (T) -&gt; Unit): T { block(this); return this } it 返回this 是 适用于let函数的任何场景，一般可用于多个扩展函数链式调用]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法（二）]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。 单向链表转置这个问题其实是很常见的一个算法问题，但是如果没弄清楚就会被它给搞晕了，从晕到不晕的过程就是你理解该算法的过程。 算法还是需要理解它，才能真正的去掌握它 下图是一个单向链表转置的初始状态和终止状态。 转置后： 链表首先要知道链表的数据结构是怎么样的，链表首先有自己的值（value），其次它有一个指针指向了下个结点，我们用代码来表示是这样的： 123456789class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value = data &#125;&#125; 从上面代码可以很清楚的看到链表的特点，他是区别于数组的一种数据结构。 链表和数组在数组中，是通过==索引==来访问元素的，很多算法都是利用索引来操作的，所以数组这种数据结构可以快速的查询到数据。链表的优势则是删除/插入数据，因为数组是固定长度的，所以增删都会改变数组的所有元素（下标变化了），而链表是可以动态改变大小的，他只会影响左右相邻的两个结点。另外链表在内存中的存储不是连续的。 算法分析过程先上代码 123456789101112131415public Node reverseList(Node head)&#123; //临时变量 Node pre = null Node next = null while(head != null)&#123; next = head.next // 1 head.next = pre // 2 pre = head //3 head = next. //4 &#125; return pre&#125; 我们来分析下具体过程，其实主要是while循环中四句话。我们逐一来分析，第一轮过程： 首先初始状态： 执行完1：next = head.next后： 执行完2: head.next = pre后：（pre此时是null） 执行完3: pre = head后： 执行完4: head = next后： 第一轮结束，我们看到头结点head在2的位置了，递归操作，我们继续分析第二轮： 执行完1：next = head.next后： 执行完2: head.next = pre后：（pre此时是指向了1）这一步很巧妙将1和2转置了。执行完3: pre = head后： 执行完4: head = next后： 如此，经过5次循环就能将这个单向链表成功转置了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法 (一)]]></title>
    <url>%2F2018%2F12%2F16%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。 常见排序算法快速排序算法原理：分治，前后两个指针交替前进，然后递归，主要步骤是： 取一个数作为基数（一般就选第一个） 将数组中比这个数大的放在它的右边，比基数小的放在它左边 递归两遍的数组 123456789101112131415161718192021222324252627public void quickSort(int[] a,int low,int high)&#123; int i = low; int j = high; int temp = a[low] //比较的数 while(i &lt; j)&#123; while(i&lt;j &amp;&amp; a[j] &gt;= temp)&#123; j--; &#125; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; while(i &lt; j &amp;&amp; a[j] &lt; temp)&#123; i++; &#125; if(i&lt;j)&#123; a[j] = a[i]; j--; &#125; &#125; a[i] = temp; quickSort(a,low,i-1); quickSort(a,i+1;high);&#125; 堆排序原理：堆其实是一个完全二叉树，它的特征是当前结点下标为i，那么它的根结点为i/2，它的左子结点为：2i+1；右子结点为：2i+2。堆排序要经过两步： 将树变为稳定的二叉树（大堆模式），即每个根结点都要大于等于它的子结点。 将根结点和最后一个结点互换，递归以上操作 手写代码：12345678910111213141516171819202122//第一步变为稳定树public void adjustHeap(int[] ,int parent,int length)&#123; int temp = a[parent]; int leftChildIndex = 2*parent + 1; while(leftChildIndex &lt; length)&#123; if (a[leftChildeIndex] &lt; a[leftChildIndex + 1]&#123; leftChildIndxe = leftChildIndex + 1; &#125; if (temp &gt; a[leftChildIndex])&#123; break; &#125; a[parent] = a[leftChildIndex]; parent = leftChildIndex; leftChildIndex = 2*leftChildIndex + 1; &#125; a[parent] = temp;&#125; 冒泡排序原理：内存循环会不停比较两个数的大小，进行换位，完成一轮后，最大的数会排在最后。（注意和选择排序的区别，选择排序是内层循环和外层循环比较）算法时间复杂度：O（n2） 1234567891011121314public static void bubbleSort(int[] a)&#123; int len = a.length; for(int i =0 ;i&lt;len;i++)&#123; for(int j=1;j&lt;len - i -1;j++)&#123;//每一轮最后一个数不用比较 // 内存循环比较相邻两个数 if(a[j] &gt; a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125; 选择排序原理：遍历数组中最小值，放在最左边，再从剩下数组中找最小值，直到排序完成（在要排序的一组数中，选出最小的一个数与第一个位置的数交换位置）算法时间复杂度：O（n2） 123456789101112131415public static void selectSort(int[] a)&#123; int len = a.length; for(int i = 0;i&lt;len;i++)&#123; for(int j = i+1; j&lt; len;j++)&#123; // 和外层第一个元素比较 if(a[j] &gt; a[i])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法，Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDG Shenzhen 2018]]></title>
    <url>%2F2018%2F12%2F09%2FGDG%20Shenzhen%202018%2F</url>
    <content type="text"><![CDATA[关于GDGGDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。 GDG官网 昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。 活动打卡活动地址，关键离我住的地方很近。 更多照片–现场图片直播 心得感想今年的活动收获还比较多，GDE（Google developer expert）将了很多AI，TensorFlow，Google的一些东西，包括很具体的Flutter，Kotlin以及Android的优化等等东西。干活还是比较多的。作为一个Android开发者，对于Android的未来其实一直有关注，blog里面也写了很多，这里就写一些经过这个活动后的感受吧，Google其实已经在开发Android的替代系统了，而且kotlin也迭代到了V1.3版本，这个时候又来了个Flutter（跨平台开发），感觉这些项目都是各自为政，其实看过《硅谷之谜》这本书后也能理解，大公司其实内部为了保持创新活力会鼓励团队或者部门去折腾，类似公司里面的成立小的创业团队，每个团队负责一个项目，如果做好了就会被公司收购，做的不好就被关掉（垃圾Google关掉了多少优秀的服务，看看隔壁百度。。。）。对于我们这些开发者而言，其实还是要靠自己的兴趣去选择，感觉李锐博士说的很好：选择职业要看自己的兴趣，不要太功利，AI很火大家都去AI，市场饱和后还是靠大家的实力，如果已自己的兴趣为出发点，赚钱是一个自然的过程。保持好奇心，紧跟前沿技术，不断去学习。然后，我自己感觉，flutter这个东西还是需要去认真对待的，特别是感受到他的hot reload的特性后，感觉非常爽，还有kotlin也是需要快速去掌握的，目前个人掌握的并不全面。另外，需要移动端结合AI来做些东西，可能会有不一样的发现。下面列出个人比较关注和感兴趣的点： 数据安全，在中国还有很多工作要做 隐藏的歧视，这里其实指的是，在技术发展飞速的今天，很多年轻人已经享受到了技术带来的好处，但是还有些人是没有得到实惠的，这些人在这个时代是弱势群体，但是他们经常会被忽略。 Flutter的优势在众多跨平台框架中是很out standing的 Android WorkManager某些情况下是可以替代Service的，比如在那些不用立即在后台执行操作的场景下 Kotlin的协程概念。这个我比较感兴趣，这个特性是V1.3刚发布的，这个是kotlin中的异步概念的实现，很像Rxjava的链式调用，需要去学习一下，另外kotlin好像也能有在大数据里面。 供web和移动端调用的轻量级TensorFlow，包括tensorflwo.js tensorflow.lite。 中国的AI发展很快，美帝国主义可能要制裁这些公司了。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>GDG</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悖论之共有知识和公共知识]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%82%96%E8%AE%BA%E4%B9%8B%E5%85%B1%E6%9C%89%E7%9F%A5%E8%AF%86%E5%92%8C%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[背景继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。 题目说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩： 大家不能讨论别人眼睛的颜色。 如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。 有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？ 分析首先，根据规则，其实大家都知道在村里有红/蓝两种眼睛的人，但是大家都不知道自己眼睛是什么颜色的。直到来了外乡人说了一句“你们中有人跟我一样是蓝色眼睛的人”，我们来分析下：假设村里只有1个蓝眼睛的人，那么这个人只知道村里都是红眼睛的，那么那个蓝眼睛就是自己了。那么再假设村里有2个蓝色眼睛的人，那么这两个人都知道对方是蓝眼睛的，但是第一天对方没有去自杀，那么理由只有一个村里蓝眼睛的人不止一个，也就是自己也是蓝眼睛，那么这两个人都会第二天自杀；依次类推，有3个蓝眼睛的人，如果第二天没人死，那么就是村里不止两个蓝眼睛的人，也就是自己就是蓝眼睛。。。。那么，红眼睛的人会死吗？答案是不会，因为红眼睛的人不知道自己眼睛的颜色是什么？可能红色，也可能黑色对不对 引申我们来看下，其实外乡人什么信息都没增加，为什么就发生了这种事情呢？这就要从知识分类来说了，知识分两类：共有知识，公共知识。共有知识：大家都知道的知识公共知识：大家都知道大家知道的知识 那么，从上面例子可以看出，大家原来都知道村里有红蓝眼睛的人，这就是共有知道，但是当外乡人把这件事情说出来共有知识就变成了公共知识，大家就都知道大家知道这件事情了。其实现实生活中有很多这样的例子，大家可以去发现，只有去讨论，将自己心里知道的东西说出来，才能变成公共知识，发挥出效果。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>心理学，悖论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悖论系列之分金问题]]></title>
    <url>%2F2018%2F12%2F06%2F%E6%82%96%E8%AE%BA%E4%B9%8B%E4%B8%89%E5%A7%AC%E5%88%86%E9%87%91%2F</url>
    <content type="text"><![CDATA[背景一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。 问题有一期的问题是：从前有一个国王，一天他的三位妃子想玩一个游戏，这个游戏规则是这样的： 有100金币供三个人A B C分 每个人按顺序发言，即提议分配这100金的方案 如果这个人的发言超过半数的人同意，则方案达成，如果没有，提议的人则要被处死。 每个人都很聪明而且人性本恶，每个人都想尽量多的获得更多的金币，如果还能杀死对方，那么则更好。问题是：最终这个金币会怎么分？ 想一想。。。。。。。。。。。。。。。。。初想下：A应该分的最少吧，因为最先提 分析首先，我们来假设A已经死了，只剩下B和C来分这个金币会出现什么情况，这个时候其实很简单了，按照第四条原则：B不管提出什么方案，C都不同意，那么C就能分到100金币，并且杀死了A和B。那么，其实在A死的情况下B也一定死；所以，B要怎么做才能不死呢，答案只有一个：A不能死。这个情况A是知道的，B也知道。那么就是说：无论A提出什么样的方案，B都会同意，这个时候分配方案是A：100/B：0/C：0，那么也有答案是A应该给一块金币B，那么B更加会同意A，如果A死，B一定死而且一毛钱拿不到。 总结我们引申下这个问题，如果来了四个人来分金币，会怎么样呢：M A B C？依然遵循上面的分析过程，M会拿到最多的金币，但是A就是一毛拿不到了，B和C反而会各拿到1个金币（大家想想是不是）：如果M死了，B和C都会一毛拿不到，这个时候M如果给B和C一人一个金币，那么B和C必然赞同，而A为了自己利益最大化，当然是想把M干掉，但是BC同意的话A的意见也没什么作用了。 这个问题很像现在的社会，国家也一样，老大永远提防老二，而老二永远想干掉老大，老大为了压制老二还会去讨好老三老四组成联盟。这个问题其实蛮有趣的，以前没想过这个问题，现在慢慢发现，很多问题其实都来源于人性。这个问题就到此，后面会有其它悖论的题目再分析吧。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>悖论</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter V1.0.0发布]]></title>
    <url>%2F2018%2F12%2F06%2FFlutter1.0%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[flutter是什么Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编写。2018/12/04Google正式发布了它的V1.0.0稳定版本，也就是说移动端的开发有可能会发生革命性的变化。本人第二天看了youtube上的发布会，然后试玩了一下发布会上说的Google三个员工三个月为这场发布会写的Demo app：The history of everything。个人感觉：完全感觉不出是非原生的，动画，过渡非常流畅，而且我还用的是老的Nexus 6P来运行的，这种表现打破了我对跨平台开发的认知，让我相当震撼，也许原生开发真的要被取代了，喊了N多遍的狼来了看来也只是时间问题了。 个人感想当变化来的时候，也许最好的方式是去拥抱变化，而不是墨守成规，扛着原生开发的大旗拉上kotlin小弟一起为Google的保守势力买单。技术现在发展月来越快，技术更新周期越来越短，这也对开发者提出了更高的要求，你需要不断的学习新东西，去适应这个快速发展的世界；但是，每个人的精力都是有限的，怎样在这个信息爆炸的时代学习到保命技能做到以不变应万变，这就需要你的眼光，高度以及眼界了，形而上的东西看着像套路但是归根结底被前人总结的其实就是这些东西，如果你具有了这些“能力”，你就会敏锐的知道在这些快速发展的技术中，哪些是革命性的？哪些是过渡的？集中精力去学习革命性的技术会让你在以后有先发优势，而如果你选择错误，则只能看着刚学的内容马上就out了。 个人总结的几点建议： 不盲目跟风口。如果自己专业领域就是风口，那就是最好，这里说的是不同领域为了去风口而盲目转型，最少要有关联性，而且是你喜欢的。 跟随大公司。这里的大公司指的是掌握核心科技的公司，站在业界前沿的公司如Google，他们发布的技术有可能就是革命性的。 对新技术保持永远的好奇心。还是刚说的要去拥抱变化，而不是抵触。 抓住机会，去更大的平台。大平台的优势不用说了。在技术变革期，大平台是最敏感的。 在技术外，丰富自己的知识库，多看书，多阅历，多和优秀的人沟通。 flutter的特性这里就贴一些文章，看到的都是各种赞不绝口，希望我也能把它收进武器库。Google 要用 Flutter 一统移动、桌面开发江湖？ Flutter 1.0 正式版: Google 的便携 UI 工具包]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>跨平台</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https简介]]></title>
    <url>%2F2018%2F12%2F04%2FHttps%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https协议 Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。 Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。 下面我们来看下加密图解过程： 加密过程解析： 客户端发送https请求，服务端返回给客户端证书（证书中含有服务端随机产生的非对称加密的公钥P）==非对称加密的算法首推RSA，可以去看原理，其实就是求一个大数的质数分解== 客户端验证发送的证书是有有效，是否去信任该证书，并随机产生对称加密的密钥K，使用P对K进行加密。 将加密后的对称加密密钥K传回给服务端，服务端用非对称加密的私钥将其解开，这样服务端和客户端都有了对称加密密钥K了。（这么做的目的是防止在传输过程中K被泄漏） 以后客户端会通过K进行数据加密，而服务端也会用K进行解密 1-2是密钥协商过程，3是加密传输过程，其中密钥协商过程解决了对称加密密钥的传输问题，由于非对称加密比对称加密解析效率低，但是安全的多的特点，因此将非对称加密用来传递对称加密密钥，而用对称加密去加解密数据。这样既保证了对称加密密钥，又保证了数据解析过程中效率。 证书证书应该是第三方认证机构颁发出来的，具有签名的一种信任凭证。而证书是需要购买的：免费的：国内沃通：沃通国外：woturs 其实，国内这家的根证书也是startssl签发的，实际上也是国外的。 参考链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化（一）]]></title>
    <url>%2F2018%2F11%2F30%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Android内存优化（一）在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。 HashMapHashMap内部使用了一个默认容量为16的数组来存储数据，而数组中每个元素又是一个链表的头结点，所以其实HashMap就是一个数组+链表的数据结构。如图： 左边纵向是数组，右边横向为链表。 这个数据结构中每一个都一个Entry类型，那么Entry的数据结构是怎么样的呢： 1234final K key;V value;final int hash;HashMapEntry&lt;K, V&gt; next; 从中我们可以看到Entry中有key，value，hash值以及下一个结点Entry，那么Entry数据是按照什么规则来存储的呢：通过计算元素key的hash值，然后对HashMap中的数组长度（默认16）取余从而得到该元素应该存在哪里，计算公式为==hash(key)%len==,举一个例子： hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置 如图：从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不回覆盖前一个，而是放在链表末尾，从而解决了Hash冲突的问题。（问题1:如果key的hash值取余大于15，那么元素该放在哪里？）。 所以，重点是：我们知道HashMap默认存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap的对象的时候，即使里面没有任何元素，系统也是会分配这么多空间给它的，而且，当我们不断往里面put数据的时候，当达到了一定的容量限制时，HashMap会扩容，而且扩大后的新的空间一定是原来的==两倍==。 扩容条件：HashMap中的数据量&gt;容量*加载因子，默认加载因子是0.75 参见HashMap详解 参见HashMap的实现 只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费。附上hash函数的实现图： 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。 SparseArraySparesArray相比HashMap更省内存，某些条件下性能更好。它的内部规则是通过两个数组来存储数据的，一个存储key，另一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约了内存空间。我们从源码中可以看到key和value分别是用数组表示： 12private int[] mKeys;private Object[] mValues; 从源码中看到，SparesArray只能存储key为int类型的数据，同时，SparesArray在存储和读取数据的时候，使用的是二分查找法： 12345678public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); ... &#125; public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); ... &#125; 也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从==小到大的顺序排列好==，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。 使用场景：虽然SparesArray性能好，但是由于其添加，查找，删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，还有有下降，所以使用也是要看使用场景的： 数据量不大，在千以内（Android开发大部分场景吧） key必须为int类型以上就是使用它的场景了。 ArrayMapArrayMap其实也是一个key-value映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用了两个数组存储数据，一个数组记录key的hash值，另外一个数组记录value值，和SparesArray一样，也会对可以使用二分法进行从小到大的排序，在添加，删除，查找数据的时候都是使用二分法查到相应的index，然后通过index来进行操作，它的使用场景： 数据量不大，千以内 数据结构为Map类型 例子： 1ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;(); 如果我们要兼容api19以下版本，那么导入V4包import android.support.v4.util.ArrayMap;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin之object详解]]></title>
    <url>%2F2018%2F11%2F28%2FKotlin%E4%B9%8Bobject%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。 object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景： 对象声明（Object Decalaration） 伴生对象（Companion Object） 对象表达式（Object Expression）– 上面提到的就是这种 对象声明语法：通过object实现kotlin中的单例例子： 12345object RepositoryManager&#123; fun method()&#123; println(&quot;I&apos;m in object declaration&quot;) &#125;&#125; 即将object代替class关键字，声明一个类，这个类就是单例了 使用： 1234fun main(args: Array&lt;String&gt;) &#123; RepositoryManager.method()//kotlin的调用 RepositoryManager.INSTANCE.method();//java的调用&#125; 像在Java中调用静态方法（kotlin中没有静态方法）一样去调用其中定义的方法。其实，object声明的类最终被编译成：一个类拥有一个静态成员变量来持有对自己的引用，并且这个静态成员的名称是INSTANCE。它等价于java代码： 12345class RepositoryManager&#123; private RepositoryManager()&#123;&#125; public static final RepositoryManager INSTANCE = new RepositoryManager();&#125; 尽管和普通类的声明一样，可以包含属性，方法，初始化代码块以及可以继承其他类或者实现某个接口，但是它不能包含构造器，java中构造器是私有的。 它也可以定义在一个类的内部： 12345678910class ObjectOuter &#123; object Inner&#123; fun method()&#123; println(&quot;I&apos;m in inner class&quot;) &#125; &#125; &#125; fun main(args: Array&lt;String&gt;) &#123; ObjectOuter.Inner.method() &#125; 伴生对象（Companion object）在kotlin中是没有static关键字的，也就意味着没有了静态方法和静态成员。那么在kotlin中如果想表示这种概率，取而代之的是==包级别函数==这里的伴生对象。他们的区别在下面会介绍。 包级别函数是指在kotlin中fun可以不依赖于class，直接新建.kt文件在文件中直接可以写fun方法，调用的时候IDE会自动导入文件急fun的方法名可以在其他类中直接使用。（其实编译后它还是在类中的，只不过类名称是.kt的文件名） 伴生对象的语法形式： 12345class A&#123; companion object 伴生对象名(可以省略)&#123; //define method and field here &#125;&#125; 示例： 1234567891011class ObjectTest &#123; companion object MyObjec&#123; val a = 20 fun method() &#123; println(&quot;I&apos;m in companion object&quot;) &#125; &#125;&#125; 使用： 123456789fun main(args: Array&lt;String&gt;) &#123; //方式一 ObjectTest.MyObject.method() println(ObjectTest.MyObject.a) //方式二（推荐方式） ObjectTest.method() println(ObjectTest.a)&#125; 在定义时如果省略了伴生对象名称，那么编辑器会为其提供默认的名字Companion。在方法二中，我们是直接通过类名称.方法名()的形式调用的，我们在没有生成ObjectTest类对象时，直接调用了其伴生对象中定义的属性和方法，和java中的静态方法很相似。 通过javap命令，让我们看下其生成的字节码： 注意红框中，这个MyObject成员变量的类型，是用$符号连接的，那么说明我们在定义伴生对象的时候，实际上是把它当作了静态内部类来看待的，并且目标类会持有该内部类的一个应用，最终调用的是定义在这个静态内部类中的实例方法。 那么伴生对象和包级别函数的区别是什么呢？我们反编译下kt文件。 可以看出，一个名叫ObjectTest2.kt文件实际上会生成一个名叫ObjectTest2Kt的类，而这个顶级函数是作为这个类的静态方法的形式存在的。所以实际上类中的静态方法和内部类中的实例方法的区别，因为成员内部类中的方法是可以访问外部内定义的方法和成员变量的，哪怕是private的，而静态方法是做不到这一点的。 对象表达式（Object Expression）先来看下java中的匿名内部类： 123456789101112131415161718192021interface Contents &#123; void absMethod();&#125;public class Hello &#123; public Contents contents() &#123; return new Contents() &#123; @Override public void absMethod() &#123; System.out.println(&quot;method invoked...&quot;); &#125; &#125;; &#125; public static void main(String[] args) &#123; Hello hello = new Hello(); hello.contents().absMethod(); //打印method invoked... &#125;&#125; 这里指出两点java中内部类的局限性 如果在匿名内部类中添加了一些方法和属性，那么在外部是无法调用的 12345678910111213141516171819return new Contents() &#123; private int i = 1; public int value() &#123; return i; &#125; @Override public void absMethod() &#123; System.out.println(&quot;method invoked...&quot;); &#125; &#125;; public static void main(String[] args) &#123; Hello hello = new Hello(); hello.contents().absMethod(); hello.value(); //Cannot resolve method &apos;value()&apos; &#125; 当你想使用这个value方式的时候，编译会报错，因为java的多态导致父类型的引用是无法知晓子类添加的方法的。 一个匿名内部类肯定只能实现一个接口或者继承一个类。 在看看kotlin的对象表达式：语法： 1object [ : 接口1,接口2,类型1, 类型2]&#123;&#125; //中括号中的可省略 示例：实现一个接口或者类 1234567891011121314interface AA &#123; fun a()&#125;fun main(args: Array&lt;String&gt;) &#123; val aa = object : AA &#123; override fun a() &#123; println(&quot;a invoked&quot;) &#125; &#125; aa.a()&#125; 不实现任何接口和类，并且在匿名内部类中添加方法 12345678910fun main(args: Array&lt;String&gt;) &#123; val obj = object &#123; fun a() &#123; println(&quot;a invoked&quot;) &#125; &#125; obj.a() //打印：a invoked&#125; 从这个例子看出kotlin中，新添加的方式是可以调用的那么，实现多个接口和类（NB） 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; val cc = object : AA, BB() &#123; override fun a() &#123; &#125; override fun b() &#123; &#125; &#125; cc.a() cc.b()&#125;//注意写法 kotlin官方文档上的一句话：匿名对象只定义局部变量和private成员变量时，才能体现它的真实类型，如果你是将匿名对象作为public函数的返回值或者是public的属性时，你只能将它看作是它的父类，当然你不指定类型时就当Any看待，这时你在匿名对象中添加的方法和属性时不能被访问的。 例子： 12345678910111213141516171819202122232425262728293031323334class MyTest &#123; private val foo = object &#123; fun method() &#123; println(&quot;private&quot;) &#125; &#125; val foo2 = object &#123; fun method() &#123; println(&quot;public&quot;) &#125; &#125; fun m() = object &#123; fun method()&#123; println(&quot;method&quot;) &#125; &#125; fun invoke()&#123; val local = object &#123; fun method()&#123; println(&quot;local&quot;) &#125; &#125; local.method() //编译通过 foo.method() //编译通过 foo2.method() //编译通不过 m().method() //编译通不过 &#125;&#125; 最后：object声明：当第一次访问它时才初始化，是一种懒加载伴生对象：当他对应的类被加载后，它才初始化，类似java中的额静态代码块对象表达式：一旦被执行，就立刻初始化。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么用Kotlin去提高生产力：Kotlin Tips]]></title>
    <url>%2F2018%2F11%2F23%2FKotlin-Tips%2F</url>
    <content type="text"><![CDATA[目录 Tip1-更简洁的字符串 1、三个引号 2、字符串模版 Tip2-Kotlin中大多数控制结构都是表达式 1、语句和表达式 2、if 3、when Tip3-更好调用的函数：显式参数名及默认参数值 1、显式参数名 2、默认参数值 3、@JvmOverloads Tip4-扩展函数和属性 1、扩展函数 2、扩展属性 Tip5-懒初始化bylazy和延迟初始化lateinit 1、by lazy 2、lateinit Tip6-不用再手写findViewById 1、Activity 2、子View或者include标签 3、Fragment Tip7-利用局部函数抽取重复代码 1、局部函数 2、扩展函数 Tip8-使用数据类来快速实现model类 Tip9-用类委托来快速实现装饰器模式 Tip10-Lambda表达式简化OnClickListener Tip11-with函数来简化代码 Tip12-apply函数来简化代码 Tip13-在编译阶段避免掉NullPointerException 1、可空和不可空类型 2、let 3、Elvis操作符 Tip14-运算符重载 Tip15-高阶函数简化代码 Tip16-用Lambda来简化策略模式 Tip1-更简洁的字符串回到目录 三个引号详见案例代码KotlinTip1 Kotlin中的字符串基本Java中的类似，有一点区别是加入了三个引号”””来方便长篇字符的编写。而在Java中，这些都需要转义，先看看java中的式例12345678910111213public void testString1() &#123; String str1 = "abc"; String str2 = "line1\n" + "line2\n" + "line3"; String js = "function myFunction()\n" + "&#123;\n" + " document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";\n" + "&#125;"; System.out.println(str1); System.out.println(str2); System.out.println(js);&#125; kotlin除了有单个双引号的字符串，还对字符串的加强，引入了三个引号，”””中可以包含换行、反斜杠等等特殊字符：12345678910111213141516171819/** kotlin对字符串的加强，三个引号"""中可以包含换行、反斜杠等等特殊字符* */fun testString() &#123; val str1 = "abc" val str2 = """line1\n line2 line3 """ val js = """ function myFunction() &#123; document.getElementById("demo").innerHTML="My First JavaScript Function"; &#125; """.trimIndent() println(str1) println(str2) println(js)&#125; 字符串模版同时，Kotlin中引入了字符串模版，方便字符串的拼接，可以用$符号拼接变量和表达式123456789/** kotlin字符串模版，可以用$符号拼接变量和表达式* */fun testString2() &#123; val strings = arrayListOf("abc", "efd", "gfg") println("First content is $strings") println("First content is $&#123;strings[0]&#125;") println("First content is $&#123;if (strings.size &gt; 0) strings[0] else "null"&#125;")&#125; 值得注意的是，在Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是${‘$’}1234567/** Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是$&#123;'$'&#125;* */fun testString3() &#123; println("First content is \$strings") println("First content is $&#123;'$'&#125;strings")&#125; Tip2-Kotlin中大多数控制结构都是表达式回到目录 首先，需要弄清楚一个概念语句和表达式，然后会介绍控制结构表达式的优点：简洁 语句和表达式是什么？ 表达式有值，并且能作为另一个表达式的一部分使用 语句总是包围着它的代码块中的顶层元素，并且没有自己的值Kotlin与Java的区别 Java中，所有的控制结构都是语句，也就是控制结构都没有值 Kotlin中，除了循环（for、do和do/while）以外，大多数控制结构都是表达式(if/when等) 详见案例代码tip2 Example1：if语句java中，if 是语句，没有值，必须显式的return12345678910/** java中的if语句* */public int max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125;&#125; kotlin中，if 是表达式，不是语句，因为表达式有值，可以作为值return出去123456/** kotlin中，if 是表达式，不是语句，类似于java中的三目运算符a &gt; b ? a : b* */fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; 上面的if中的分支最后一行语句就是该分支的值，会作为函数的返回值。这其实跟java中的三元运算符类似，123456/** java的三元运算符* */public int max2(int a, int b) &#123; return a &gt; b ? a : b;&#125; 上面是java中的三元运算符，kotlin中if是表达式有值，完全可以替代，故kotlin中已没有三元运算符了，用if来替代。上面的max函数还可以简化成下面的形式1234/** kotlin简化版本* */fun max2(a: Int, b: Int) = if (a &gt; b) a else b Example2：when语句Kotlin中的when非常强大，完全可以取代Java中的switch和if/else，同时，when也是表达式，when的每个分支的最后一行为当前分支的值先看一下java中的switch12345678910111213141516/** java中的switch* */public String getPoint(char grade) &#123; switch (grade) &#123; case 'A': return "GOOD"; case 'B': case 'C': return "OK"; case 'D': return "BAD"; default: return "UN_KNOW"; &#125;&#125; java中的switch有太多限制，我们再看看Kotlin怎样去简化的123456789101112/** kotlin中，when是表达式，可以取代Java 中的switch，when的每个分支的最后一行为当前分支的值* */fun getPoint(grade: Char) = when (grade) &#123; 'A' -&gt; "GOOD" 'B', 'C' -&gt; &#123; println("test when") "OK" &#125; 'D' -&gt; "BAD" else -&gt; "UN_KNOW"&#125; 同样的，when语句还可以取代java中的if/else if，其是表达式有值，并且更佳简洁123456789101112131415/** java中的if else* */public String getPoint2(Integer point) &#123; if (point &gt; 100) &#123; return "GOOD"; &#125; else if (point &gt; 60) &#123; return "OK"; &#125; else if (point.hashCode() == 0x100) &#123; //... return "STH"; &#125; else &#123; return "UN_KNOW"; &#125;&#125; 再看看kotlin的版本，使用不带参数的when，只需要6行代码123456789/** kotlin中，when是表达式，可以取代java的if/else，when的每个分支的最后一行为当前分支的值* */fun getPoint2(grade: Int) = when &#123; grade &gt; 90 -&gt; "GOOD" grade &gt; 60 -&gt; "OK" grade.hashCode() == 0x100 -&gt; "STH" else -&gt; "UN_KNOW"&#125; Tip3-更好调用的函数-显式参数名及默认参数值回到目录 显式参数名Kotlin的函数更加好调用，主要是表现在两个方面：1，显式的标示参数名，可以方便代码阅读；2，函数可以有默认参数值，可以大大减少Java中的函数重载。例如现在需要实现一个工具函数，打印列表的内容：详见案例代码KotlinTip312345678910111213141516171819202122232425/** 打印列表的内容* */fun &lt;T&gt; joinToString(collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList() &#123; val list = listOf(2, 4, 0) // 不标明参数名 println(joinToString(list, " - ", "[", "]")) // 显式的标明参数名称 println(joinToString(list, separator = " - ", prefix = "[", postfix = "]"))&#125; 如上面的代码所示，函数joinToString想要打印列表的内容，需要传入四个参数：列表、分隔符、前缀和后缀。由于参数很多，在后续使用该函数的时候不是很直观的知道每个参数是干什么用的，这时候可以显式的标明参数名称，增加代码可读性。 默认参数值同时，定义函数的时候还可以给函数默认的参数，如下所示：1234567891011121314151617181920212223/** 打印列表的内容，带有默认的参数，可以避免java的函数重载* */fun &lt;T&gt; joinToString2(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList3() &#123; val list = listOf(2, 4, 0) println(joinToString2(list, " - ")) println(joinToString2(list, " , ", "["))&#125; 这样有了默认参数后，在使用函数时，如果不传入该参数，默认会使用默认的值，这样可以避免Java中大量的函数重载。 @JvmOverloads在java与kotlin的混合项目中，会发现用kotlin实现的带默认参数的函数，在java中去调用的化就不能利用这个特性了，还是需要给所有参数赋值，像下面java这样：123List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2(arr, "-", "", "");System.out.println(res); 这时候可以在kotlin的函数前添加注解@JvmOverloads，添加注解后翻译为class的时候kotlin会帮你去生成多个函数实现函数重载，kotlin代码如下：12345678910111213141516/** 通过注解@JvmOverloads解决java调用kotlin时不支持默认参数的问题* */@JvmOverloadsfun &lt;T&gt; joinToString2New(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125; 这样以后，java调用kotlin的带默认参数的函数就跟kotlin一样方便了：12345List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2New(arr, "-");System.out.println(res);String res2 = joinToString2New(arr, "-", "=&gt;");System.out.println(res2); Tip4-扩展函数和属性回到目录 扩展函数和扩展属性是Kotlin非常方便实用的一个功能，它可以让我们随意的扩展第三方的库，你如果觉得别人给的SDK的Api不好用，或者不能满足你的需求，这时候你可以用扩展函数完全去自定义。 扩展函数例如String类中，我们想获取最后一个字符，String中没有这样的直接函数，你可以用.后声明这样一个扩展函数：详见案例代码KotlinTip41234567891011/** 扩展函数* */fun String.lastChar(): Char = this.get(this.length - 1)/** 测试* */fun testFunExtension() &#123; val str = "test extension fun"; println(str.lastChar())&#125; 这样定义好lastChar()函数后，之后只需要import进来后，就可以用String类直接调用该函数了，跟调用它自己的方法没有区别。这样可以避免重复代码和一些静态工具类，而且代码更加简洁明了。例如我们可以改造上面tip3中的打印列表内容的函数：12345678910111213141516171819/** 用扩展函数改造Tip3中的列表打印内容函数* */fun &lt;T&gt; Collection&lt;T&gt;.joinToString3(separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;fun printList4() &#123; val list = listOf(2, 4, 0) println(list.joinToString3("/"))&#125; 扩展属性除了扩展函数，还可以扩展属性，例如我想实现String和StringBuilder通过属性去直接获得最后字符：12345678910111213141516171819202122/** 扩展属性 lastChar获取String的最后一个字符* */val String.lastChar: Char get() = get(length - 1)/** 扩展属性 lastChar获取StringBuilder的最后一个字符* */var StringBuilder.lastChar: Char get() = get(length - 1) set(value: Char) &#123; setCharAt(length - 1, value) &#125;/** 测试* */fun testExtension() &#123; val s = "abc" println(s.lastChar) val sb = StringBuilder("abc") println(sb.lastChar)&#125; 定义好扩展属性后，之后只需import完了就跟使用自己的属性一样方便了。 Why？Kotlin为什么能实现扩展函数和属性这样的特性？在Kotlin中要理解一些语法，只要认识到Kotlin语言最后需要编译为class字节码，Java也是编译为class执行，也就是可以大致理解为Kotlin需要转成Java一样的语法结构，Kotlin就是一种强大的语法糖而已，Java不具备的功能Kotlin也不能越界的。 那Kotlin的扩展函数怎么实现的呢？介绍一种万能的办法去理解Kotlin的语法：将Kotlin代码转化成Java语言去理解，步骤如下： 在Android Studio中选择Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode 这样就把Kotlin转化为class字节码了 class码阅读不太友好，点击左上角的Decompile就转化为Java 再介绍一个小窍门，在前期对Kotlin语法不熟悉的时候，可以先用Java写好代码，再利用AndroidStudio工具将Java代码转化为Kotlin代码，步骤如下： 在Android Studio中选中要转换的Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File 我们看看将上面的扩展函数转成Java后的代码123456789101112131415161718192021/** 扩展函数会转化为一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char lastChar(@NotNull String $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char getLastChar(@NotNull StringBuilder $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final void setLastChar(@NotNull StringBuilder $receiver, char value) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); $receiver.setCharAt($receiver.length() - 1, value);&#125; 查看上面的代码可知：对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象，这样把类的实例传入函数以后，函数内部就可以访问到类的公有方法。对于扩展属性也类似，获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象，设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象。函数内部可以访问公有的方法和属性。顶层的扩展函数是static的，不能被override 从上面转换的源码其实可以看到扩展函数和扩展属性适用的地方和缺陷： 扩展函数和扩展属性内只能访问到类的公有方法和属性，私有的和protected是访问不了的 扩展函数不是真的修改了原来的类，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型，案例代码StaticllyExtension.kt 12345678910111213141516171819202122open class C class D : C() fun C.foo() = "c" fun D.foo() = "d" /** https://kotlinlang.org/docs/reference/extensions.html* Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,* but merely make new functions callable with the dot-notation on variables of this type. Extension functions are* dispatched statically.* */fun printFoo(c: C) &#123; println(c.foo())&#125; fun testStatically() &#123; printFoo(C()) // print c printFoo(D()) // also print c&#125; 上面的案例中即使调用printFoo(D())还是打印出c，而不是d。转成java中会看到下面的代码，D类型在调用的时候会强制转换为C类型： 12345678910111213141516171819public static final String foo(@NotNull C $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "c";&#125; public static final String foo(@NotNull D $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "d";&#125; public static final void printFoo(@NotNull C c) &#123; Intrinsics.checkParameterIsNotNull(c, "c"); String var1 = foo(c); System.out.println(var1);&#125;public static final void testStatically() &#123; printFoo(new C()); printFoo((C)(new D()));&#125; 声明扩展函数作为类的成员变量 上面的例子扩展函数是作为顶层函数，如果把扩展函数申明为类的成员变量，即扩展函数的作用域就在类的内部有效，案例代码ExtensionsAsMembers.kt123456789101112131415161718192021222324252627282930313233343536open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // call the extension function &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;fun testAsMembers() &#123; C().caller(D()) // prints "D.foo in C" C1().caller(D()) // prints "D.foo in C1" - dispatch receiver is resolved virtually C().caller(D1()) // prints "D.foo in C" - extension receiver is resolved statically C1().caller(D1()) // prints "D.foo in C1"&#125; 函数caller的类型是D，即使调用C().caller(D1())，打印的结果还是D.foo in C，而不是D1.foo in C，不是运行时来动态决定类型，成员扩展函数申明为open，一旦在子类中被override，就调用不到在父类中的扩展函数，在子类中的作用域内的只能访问到override后的函数，不能像普通函数override那样通过super关键字访问了。 下面再举几个扩展函数的例子，让大家感受一下扩展函数的方便：1234567891011121314151617181920212223242526272829303132333435/** show toast in activity* */fun Activity.toast(msg: String) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()&#125;val Context.inputMethodManager: InputMethodManager? get() = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager/** hide soft input* */fun Context.hideSoftInput(view: View) &#123; inputMethodManager?.hideSoftInputFromWindow(view.windowToken, 0)&#125;/** * screen width in pixels */val Context.screenWidth get() = resources.displayMetrics.widthPixels/** * screen height in pixels */val Context.screenHeight get() = resources.displayMetrics.heightPixels/** * returns dip(dp) dimension value in pixels * @param value dp */fun Context.dip2px(value: Int): Int = (value * resources.displayMetrics.density).toInt() Tip5-懒初始化bylazy和延迟初始化lateinit回到目录 懒初始化by lazy懒初始化是指推迟一个变量的初始化时机，变量在使用的时候才去实例化，这样会更加的高效。因为我们通常会遇到这样的情况，一个变量直到使用时才需要被初始化，或者仅仅是它的初始化依赖于某些无法立即获得的上下文。详见案例代码KotlinTip512345678910/** 懒初始化api实例* */val purchasingApi: PurchasingApi by lazy &#123; val retrofit: Retrofit = Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(MoshiConverterFactory.create()) .build() retrofit.create(PurchasingApi::class.java)&#125; 像上面的代码，retrofit生成的api实例会在首次使用到的时候才去实例化。需要注意的是by lazy一般只能修饰val不变的对象，不能修饰var可变对象。12345678class User(var name: String, var age: Int)/** 懒初始化by lazy* */val user1: User by lazy &#123; User("jack", 15)&#125; 延迟初始化lateinit另外，对于var的变量，如果类型是非空的，是必须初始化的，不然编译不通过，这时候需要用到lateinit延迟初始化，使用的时候再去实例化。12345678/** 延迟初始化lateinit* */lateinit var user2: Userfun testLateInit() &#123; user2 = User("Lily", 14)&#125; by lazy 和 lateinit 的区别 by lazy 修饰val的变量 lateinit 修饰var的变量，且变量是非空的类型 Tip6-不用再手写findViewById回到目录 在Activity中使用在Android的View中，会有很多代码是在声明一个View，然后通过findViewById后从xml中实例化赋值给对应的View。在kotlin中可以完全解放出来了，利用kotlin-android-extensions插件，不用再手写findViewById。步骤如下：详见案例代码KotlinTip6 步骤1，在项目的gradle中 apply plugin: ‘kotlin-android-extensions’ 步骤2，按照原来的习惯书写布局xml文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tip6Tv" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/tip6Img" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/tip6Btn" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 步骤3，在java代码中import对应的布局就可以开始使用了，View不用提前声明，插件会自动根据布局的id生成对应的View成员（其实没有生成属性，原理见下面） 123456789101112131415161718192021222324252627import com.sw.kotlin.tips.R/** 导入插件生成的View* */import kotlinx.android.synthetic.main.activity_tip6.*class KotlinTip6 : Activity() &#123; /* * 自动根据layout的id生成对应的view * */ override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_tip6) tip6Tv.text = "Auto find view for TextView" tip6Img.setImageBitmap(null) tip6Btn.setOnClickListener &#123; test() &#125; &#125; private fun test()&#123; tip6Tv.text = "update" &#125;&#125; 像上面代码这样，Activity里的三个View自动生成了，不用再去声明，然后findViewById，然后转型赋值，是不是减少了很多没必要的代码，让代码非常的干净。 Why？原理是什么？插件帮我们做了什么？要看原理还是将上面的代码转为java语言来理解，参照tips4提供的方式转换为如下的java代码：12345678910111213141516171819202122232425262728293031323334353637383940414243public final class KotlinTip6 extends Activity &#123; private HashMap _$_findViewCache; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setContentView(2131296284); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"Auto find view for TextView"); ((ImageView)this._$_findCachedViewById(id.tip6Img)).setImageBitmap((Bitmap)null); ((Button)this._$_findCachedViewById(id.tip6Btn)).setOnClickListener((OnClickListener)(new OnClickListener() &#123; public final void onClick(View it) &#123; KotlinTip6.this.test(); &#125; &#125;)); &#125; private final void test() &#123; TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence) "update"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; var2 = this.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125;&#125; 如上面的代码所示，在编译阶段，插件会帮我们生成视图缓存，视图由一个Hashmap结构的_$_findViewCache变量缓存，会根据对应的id先从缓存里查找，缓存没命中再去真正调用findViewById查找出来，再存在HashMap中。 子View或者include标签中findViewById子子View或者include标签中，同样可以省略findViewById，但需要主要默认的activity的布局import是不会将这个include的View引入进来123456789101112131415&lt;include layout="@layout/layout_tip6"/&gt;//include layout&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/test_inside_id" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/app_name"/&gt;&lt;/FrameLayout&gt; 需要我们引入对应的View的id，像这样import kotlinx.android.synthetic.main.layout_tip6.*123456//导入插件生成的Viewimport kotlinx.android.synthetic.main.activity_tip6.*//include layout的Viewimport kotlinx.android.synthetic.main.layout_tip6.*test_inside_id.text = "Test include" 在Fragment中findViewById在Fragment中也类似，但有一点需要注意但地方，例子如下：12345678910111213141516171819class Tip6Fragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val view = inflater?.inflate(R.layout.fragment_tip6, container, false) /* * 这时候不能在onCreateView方法里用view，需要在onViewCreate里，原理是插件用了getView来findViewById * */ // tip6Tv.text = "test2" return view &#125; /* * 需要在onViewCreate里，原理是插件用了getView来findViewById * */ override fun onViewCreated(view: View?, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) tip6Tv.text = "test" &#125;&#125; 如上所示，Fragment需要注意，不能在onCreateView方法里用view，不然会出现空指针异常，需要在onViewCreate里，原理是插件用了getView来findViewById，我们看看将上面的代码转成java后的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class Tip6Fragment extends Fragment &#123; private HashMap _$_findViewCache; @Nullable public View onCreateView(@Nullable LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater != null?inflater.inflate(2131296286, container, false):null; return view; &#125; public void onViewCreated(@Nullable View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"test"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; View var10000 = this.getView(); if (var10000 == null) &#123; return null; &#125; var2 = var10000.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125; // $FF: synthetic method public void onDestroyView() &#123; super.onDestroyView(); this._$_clearFindViewByIdCache(); &#125;&#125; 跟Activity中类似，会有一个View的HashMap，关键不同的地方在_$findCachedViewById里面，需要getView获得当前Fragment的View，故在onViewCreated中getView还是空的，原理就好理解了。另外在onDestroyView会调用$_clearFindViewByIdCache方法清掉缓存。 Tip7-利用局部函数抽取重复代码回到目录 局部函数抽取代码Kotlin中提供了函数的嵌套，在函数内部还可以定义新的函数。这样我们可以在函数中嵌套这些提前的函数，来抽取重复代码。如下面的案例所示:详见案例代码KotlinTip71234567891011121314class User(val id: Int, val name: String, val address: String, val email: String)fun saveUser(user: User) &#123; if (user.name.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Name") &#125; if (user.address.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Address") &#125; if (user.email.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Email") &#125; // save to db ...&#125; 上面的代码在判断name、address等是否为空的处理其实很类似。这时候，我们可以利用在函数内部嵌套的声明一个通用的判空函数将相同的代码抽取到一起：123456789101112131415/** 利用局部函数抽取相同的逻辑，去除重复的代码* */fun saveUser2(user: User) &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty $fildName") &#125; &#125; validate(user.name, "Name") validate(user.address, "Address") validate(user.email, "Email") // save to db ...&#125; 扩展函数抽取代码除了利用嵌套函数去抽取，此时，其实也可以用扩展函数来抽取，如下所示：12345678910111213141516171819/** 利用扩展函数抽取逻辑* */fun User.validateAll() &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $id: empty $fildName") &#125; &#125; validate(name, "Name") validate(address, "Address") validate(email, "Email")&#125;fun saveUser3(user: User) &#123; user.validateAll() // save to db ...&#125; Tip8-使用数据类来快速实现model类回到目录 在java中要声明一个model类需要实现很多的代码，首先需要将变量声明为private，然后需要实现get和set方法，还要实现对应的hashcode equals toString方法等，如下所示：详见案例代码Tip81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static class User &#123; private String name; private int age; private int gender; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + ", address='" + address + '\'' + '&#125;'; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; if (gender != user.gender) return false; if (name != null ? !name.equals(user.name) : user.name != null) return false; return address != null ? address.equals(user.address) : user.address == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; result = 31 * result + gender; result = 31 * result + (address != null ? address.hashCode() : 0); return result; &#125;&#125; 这段代码Java需要70行左右，而如果用kotlin，只需要一行代码就可以做到。123456789/** Kotlin会为类的参数自动实现get set方法* */class User(val name: String, val age: Int, val gender: Int, var address: String)/** 用data关键词来声明一个数据类，除了会自动实现get set，还会自动生成equals hashcode toString* */data class User2(val name: String, val age: Int, val gender: Int, var address: String) 对于Kotlin中的类，会为它的参数自动实现get set方法。而如果加上data关键字，还会自动生成equals hashcode toString。原理其实数据类中的大部分代码都是模版代码，Kotlin聪明的将这个模版代码的实现放在了编译器处理的阶段。 Tip9-用类委托来快速实现装饰器模式回到目录 通过继承的实现容易导致脆弱性，例如如果需要修改其他类的一些行为，这时候Java中的一种策略是采用装饰器模式：创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个成员变量。与原始类拥有相同行为的方法不用修改，只需要直接转发给原始类的实例。如下所示：详见案例代码KotlinTip91234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 常见的装饰器模式，为了修改部分的函数，却需要实现所有的接口函数* */class CountingSet&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; &#123; var objectAdded = 0 override val size: Int get() = innerSet.size /* * 需要修改的方法 * */ override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; /* * 需要修改的方法 * */ override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125; override fun contains(element: T): Boolean &#123; return innerSet.contains(element) &#125; override fun containsAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.containsAll(elements) &#125; override fun isEmpty(): Boolean &#123; return innerSet.isEmpty() &#125; override fun clear() &#123; innerSet.clear() &#125; override fun iterator(): MutableIterator&lt;T&gt; &#123; return innerSet.iterator() &#125; override fun remove(element: T): Boolean &#123; return innerSet.remove(element) &#125; override fun removeAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.removeAll(elements) &#125; override fun retainAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.retainAll(elements) &#125;&#125; 如上所示，想要修改HashSet的某些行为函数add和addAll，需要实现MutableCollection接口的所有方法，将这些方法转发给innerSet去具体的实现。虽然只需要修改其中的两个方法，其他代码都是模版代码。只要是重复的模版代码，Kotlin这种全新的语法糖就会想办法将它放在编译阶段再去生成。这时候可以用到类委托by关键字，如下所示：1234567891011121314151617/** 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了* */class CountingSet2&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123; var objectAdded = 0 override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125;&#125; 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了，通过类委托将10行代码就可以实现上面接近100行的功能，简洁明了，去掉了模版代码。 Tip10-Lambda表达式简化OnClickListener回到目录 详见案例代码KotlinTip10lambda表达式可以简化我们的代码。以Android中常见的OnClickListener来说明，在Java中我们一般这样设置：1234567TextView textView = new TextView(context);textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // handle click &#125;&#125;); Java中需要声明一个匿名内部类去处理，这种情况可以用lambda表达式来简化。 lambda表达式一般长这样 { x:Int, y:Int -&gt; x+y } 参数 -&gt; 表达式 并且始终在大括号中 it作为默认参数名 lambda捕捉，当捕捉final变量时，它的值和lambda代码一起存储 非final变量，它的值被封装在一个特殊的包装器中，这个包装器的引用会和lambda代码一起存储 我们来看看Kotlin中的例子：12345678910111213141516171819val textView = TextView(context)/** 传统方式* */textView.setOnClickListener(object : android.view.View.OnClickListener &#123; override fun onClick(v: android.view.View?) &#123; // handle click &#125;&#125;)/** lambda的方式* */textView.setOnClickListener(&#123; v -&gt; &#123; // handle click &#125;&#125;) 当lambda的参数没有使用时可以省略，省略的时候用it来替代123456/** lambda的参数如果没有使用可以省略，省略的时候用it来替代* */textView.setOnClickListener(&#123; // handle click&#125;) lambda在参数的最后一个的情况可以将之提出去123456/** lambda在参数的最后一个的情况可以将之提出去* */textView.setOnClickListener() &#123; // handle click&#125; lambda提出去之后，函数如果没有其他参数括号可以省略123456/** lambda提出去之后，函数如果没有其他参数括号可以省略* */textView.setOnClickListener &#123; // handle click&#125; 我们再看看如果自己去实现一个带lambda参数的函数应该怎么去定义：1234567891011121314151617181920212223242526interface OnClickListener &#123; fun onClick()&#125;class View &#123; var listener: OnClickListener? = null; /* * 传统方式 * */ fun setOnClickListener(listener: OnClickListener) &#123; this.listener = listener &#125; fun doSth() &#123; // some case: listener?.onClick() &#125; /* * 声明lambda方式，listener: () -&gt; Unit * */ fun setOnClickListener(listener: () -&gt; Unit) &#123; &#125;&#125; 在函数参数中需要声明lambda的类型后，再调用该函数的时候就可以传入一个lambda表达式了。 Tip11-with函数来简化代码回到目录 with 函数原型： 1inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() with函数并不是扩展函数，返回值是最后一行，可以直接调用对象的方法 Kotlin中可以用with语句来省略同一个变量的多次声明，例如下面的函数详见案例代码KotlinTip11123456789101112/**打印字母表函数，在函数内result变量在好几处有使用到* */fun alphabet(): String &#123; val result = StringBuilder() result.append("START\n") for (letter in 'A'..'Z') &#123; result.append(letter) &#125; result.append("\nEND") return result.toString()&#125; 在上面的函数中，result变量出现了5次，如果用with语句，可以将这5次都不用再出现了，我们来一步一步地看是怎么实现的：1234567891011121314/** 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了* */fun alphabet2(): String &#123; val result = StringBuilder() return with(result) &#123; this.append("START\n") for (letter in 'A'..'Z') &#123; this.append(letter) &#125; this.append("\nEND") this.toString() &#125;&#125; 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了，而且这个this是可以省略的 1234567891011121314/** 通过with语句，将result参数作为参数，在内部this也可以省略掉* */fun alphabet3(): String &#123; val result = StringBuilder() return with(result) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 在内部this省略掉后，现在只有一个result了，这个其实也是没必要的，于是出现了下面的最终版本：12345678910111213/** 通过with语句，可以直接将对象传入，省掉对象的声明* */fun alphabet4(): String &#123; return with(StringBuilder()) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 像上面这样，我们可以把同一个变量的显式调用从5次变为0次，发现Kotlin的魅力了吧。 Tip12-apply函数来简化代码回到目录 apply 函数原型： 1inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 除了用上面的with可以简化同一个变量的多次声明，还可以用apply关键字，我们来改造一下tip11中的函数：详见案例代码KotlinTip1212345678910/** 用apply语句简化代码，在apply的大括号里可以访问类的公有属性和方法* */fun alphabet5() = StringBuilder().apply &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND")&#125;.toString() 像上面这样的，通过apply后，在apply的大括号里可以访问类的公有属性和方法。这在对应类的初始化是非常方便的，例如下面的例子12345678910111213141516171819202122/** 用apply语句简化类的初始化，在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁* */fun testApply(context: Context) &#123; var imgView = ImageView(context).apply &#123; setBackgroundColor(0) setImageBitmap(null) &#125; var textView = TextView(context).apply &#123; text = "content" textSize = 20.0f setPadding(10, 0, 0, 0) &#125; var user = User().apply &#123; age = 15 name = "Jack" val a = address address = "bbb" &#125;&#125; 在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁 Tip13-在编译阶段避免掉NullPointerException回到目录 可空类型和不可空类型NullPointerException是Java程序员非常头痛的一个问题，我们知道Java 中分受检异常和非受检异常，NullPointerException是非受检异常，也就是说NullPointerException不需要显示的去catch住，往往在运行期间，程序就可能报出一个NullPointerException然后crash掉，Kotlin作为一门高效安全的语言，它尝试在编译阶段就把空指针问题显式的检测出来，把问题留在了编译阶段，让程序更加健壮。详见案例代码KotlinTip13 Kotlin中类型分为可空类型和不可空类型，通过？代表可空，不带？代表不可为空 123456789101112131415161718192021fun testNullType() &#123; val a: String = "aa" /* * a是非空类型，下面的给a赋值为null将会编译不通过 * */ // a = null a.length /* * ？声明是可空类型，可以赋值为null * */ var b: String? = "bb" b = null /* * b是可空类型，直接访问可空类型将编译不通过，需要通过?.或者!!.来访问 * */ // b.length b?.length b!!.length&#125; 对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过 对于一个可空类型：通过？声明，在访问该类型的时候直接访问不能编译通过，需要通过?.或者!!. ?. 代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性 !!. 代表着如果该类型为空的话就抛出NullPointerException，如果不为空就去访问对应的方法或者属性，所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出NullPointerException。而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了：12345/** 不推荐这样的写法：链式的连续用!!.* */val user = User()user!!.name!!.subSequence(0,5)!!.length 对应一个可空类型，每次对它的访问都需要带上?.判断12345678val user: User? = User() /* * 每次访问都用用?.判断 * */ user?.name user?.age user?.toString() 但这样多了很多代码，kotlin做了一些优化，12345678/** 或者提前判断是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了* */if (user != null) &#123; user.name user.age user.toString()&#125; 通过if提前判断类型是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了。 let语句简化对可空对象对访问 let 函数原型： 1inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) let函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。 上面的代码还可以用?.let语句进行，如下所示：12345678/** 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作* */user?.let &#123; it.name it.age it.toString()&#125; 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作 Elvis操作符 ?: 简化对空值的处理如果值可能为空，对空值的处理可能会比较麻烦，像下面这样：123456789101112131415161718/** 对空值的处理* */fun testElvis(input: String?, user: User?) &#123; val a: Int? if (input == null) &#123; a = -1 &#125; else &#123; a = input?.length &#125; if (user == null) &#123; var newOne = User() newOne.save() &#125; else &#123; user.save() &#125;&#125; Elvis操作符?:能够简化上面的操作，?:符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟?.let正好相反，例如我们可以用两行代码来简化上面从操作：1234567/** * Elvis操作符 ?: 简化对空值的处理 */fun testElvis2(input: String?, user: User?) &#123; val b = input?.length ?: -1; user?.save() ?: User().save()&#125; Tip14-运算符重载回到目录 Kotlin支持对运算符的重载，这对于对一些对象的操作更加灵活直观。 使用operator来修饰plus\minus函数 可重载的二元算术符 A * B times A / B div A % B mod A + B plus A - B minus 以下面对坐标点Point的案例说明怎么去重载运算符：详见案例代码KotlinTip14123456789101112131415161718192021class Point(val x: Int, val y: Int) &#123; /* * plus函数重载对Point对象的加法运算符 * */ operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125; /* * minus函数重载对Point对象的减法运算符 * */ operator fun minus(other: Point): Point &#123; return Point(x - other.x, y - other.y) &#125; override fun toString(): String &#123; return "[x:$x, y:$y]" &#125;&#125; 如上所示，通过plus函数重载对Point对象的加法运算符，通过minus函数重载对Point对象的减法运算符，然后就可以用+、-号对两个对象进行操作了：1234567fun testOperator() &#123; val point1 = Point(10, 10) val point2 = Point(4, 4) val point3 = point1 + point2 println(point3) println(point1 - point2)&#125; Tip15-高阶函数简化代码回到目录 高阶函数：以另一个函数作为参数或者返回值的函数 函数类型 (Int, String) -&gt; Unit 参数类型-&gt;返回类型 Unit不能省略 1234567891011121314val list = listOf(2, 5, 10)/** 传入函数来过滤* */println(list.filter &#123; it &gt; 4 &#125;) /** 定义函数类型* */val sum = &#123; x: Int, y: Int -&gt; x + y &#125;val action = &#123; println(42) &#125;val sum2: (Int, Int) -&gt; Int = &#123; x: Int, y: Int -&gt; x + y &#125;val action2: () -&gt; Unit = &#123; println(42) &#125; 函数作为参数函数作为参数，即高阶函数中，函数的参数可以是一个函数类型，例如要定义一个函数，该函数根据传入的操作函数来对2和3做相应的处理。详见案例代码KotlinTip15 123456789101112/** 定义对2和3的操作函数* */fun twoAndThree(operator: (Int, Int) -&gt; Int) &#123; val result = operator(2, 3) println("Result:$result")&#125;fun test03() &#123; twoAndThree &#123; a, b -&gt; a + b &#125; twoAndThree &#123; a, b -&gt; a * b &#125;&#125; operator是函数类型，函数的具体类型为(Int, Int) -&gt; Int，即输入两个Int返回一个Int值。定义完了后就可以像上面这样使用了。再举一个例子，实现String类的字符过滤：123456789101112131415/** 函数作为参数，实现String类的字符过滤* */fun String.filter(predicate: (Char) -&gt; Boolean): String &#123; val sb = StringBuilder() for (index in 0 until length) &#123; val element = get(index) if (predicate(element)) sb.append(element) &#125; return sb.toString()&#125;fun test04() &#123; println("12eafsfsfdbzzsa".filter &#123; it in 'a'..'f' &#125;)&#125; 像上面这样predicate是函数类型，它会根据传入的char来判断得到一个Boolean值。 函数作为返回值函数作为返回值也非常实用，例如我们的需求是根据不同的快递类型返回不同计价公式，普通快递和高级快递的计价规则不一样，这时候我们可以将计价规则函数作为返回值： 1234567891011121314151617181920enum class Delivery &#123; STANDARD, EXPEDITED&#125;/** 根据不同的运输类型返回不同的快递方式* */fun getShippingCostCalculator(delivery: Delivery): (Int) -&gt; Double &#123; if (delivery == Delivery.EXPEDITED) &#123; return &#123; 6 + 2.1 * it &#125; &#125; return &#123; 1.3 * it &#125;&#125;fun test05() &#123; val calculator1 = getShippingCostCalculator(Delivery.EXPEDITED) val calculator2 = getShippingCostCalculator(Delivery.STANDARD) println("Ex costs $&#123;calculator1(5)&#125;") println("St costs $&#123;calculator2(5)&#125;")&#125; 如果是普通快递，采用1.3 it的规则计算价格，如果是高级快递按照6 + 2.1 it计算价格，根据不同的类型返回不同的计价函数。 Tip16-用Lambda来简化策略模式回到目录 策略模式是常见的模式之一，java的例子如下。详见案例代码Tip1612345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 定义策略接口 */ public interface Strategy &#123; void doSth(); &#125; /** * A策略 */ public static class AStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do A Strategy"); &#125; &#125; /** * B策略 */ public static class BStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do B Strategy"); &#125; &#125; /** * 策略实施者 */ public static class Worker &#123; private Strategy strategy; public Worker(Strategy strategy) &#123; this.strategy = strategy; &#125; public void work() &#123; System.out.println("START"); if (strategy != null) &#123; strategy.doSth(); &#125; System.out.println("END"); &#125; &#125; 如上面的例子所示，有A、B两种策略，Worker根据不同的策略做不同的工作，使用策略时：1234Worker worker1 = new Worker(new AStrategy());Worker worker2 = new Worker(new BStrategy());worker1.work();worker2.work(); 在java中实现这种策略模式难免需要先定义好策略的接口，然后根据接口实现不同的策略，在Kotlin中完全可以用用Lambda来简化策略模式，上面的例子用Kotlin实现：1234567891011121314151617181920212223242526/** * 策略实施者 * @param strategy lambda类型的策略 */class Worker(private val strategy: () -&gt; Unit) &#123; fun work() &#123; println("START") strategy.invoke() println("END") &#125;&#125;/** 测试* */fun testStrategy() &#123; val worker1 = Worker(&#123; println("Do A Strategy") &#125;) val bStrategy = &#123; println("Do B Strategy") &#125; val worker2 = Worker(bStrategy) worker1.work() worker2.work()&#125; 不需要先定义策略的接口，直接把策略以lambda表达式的形式传进来就行了。 参考文档 《Kotlin in Action》 https://kotlinlang.org/docs/reference/ https://savvyapps.com/blog/kotlin-tips-android-development]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒冬将至，Android的出路]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%AF%92%E5%86%AC%E5%B7%B2%E8%87%B3%EF%BC%8CAndroid%E7%9A%84%E5%87%BA%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。 Android开发的天花板很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。 再说职业上，确实Android应用开发很难升任CTO，一般的CTO主要是后端，这主要是两个原因：后端的技术栈很早就成熟了，我8年前转做Android开发时，那帮30多岁的Java开发就已经很厉害了，随着时间的推移，后端技术大牛远比Android大牛的人数要多，也更厉害，他们做技术经理时，我们都还在搬砖； 后端确实可以统筹全局，在公司业务上属于重要地位。 不过我们忽略了最重要的一点，如果我们是做后端的，一定能做到CTO吗？我想也是很难的，所以不要眼睛只盯着高处，先想想自己能达到什么程度，站在半山腰就说山下面的风景不开阔本身也不合理啊。 是否要转行Android不热门了，很多Android开发已经转行了，有的正走在转行的路上，还有的迟疑不决，到底要不要转呢？我们来分析下。 转什么好每个人的自身情况不同，转的方向也会有所区别，转人工智能相关开发肯定是最好的，毕竟风口上的猪也能飞，跟着风口无可厚非。只可惜人工智能相关对学历和算法要求很高，最起码得是个硕士吧，而且这只是低配。那么大多数Android开发可以转的方向主要有前端、后端和Python等等。我大概说一下： 转前端，这个是我认为最好转的一个方向，前端的理念很多都和Android类似，也可以作为Android的延伸，向大前端发展，如果对界面感兴趣的可以转前端试试。 转后端，后端这个就是完全的转行了，看似Java大家都会，但是后端的技术栈可不是只有Java，各种框架绝对叫你头大，很多人强调后端技术深，各种处理高并发看似十分有技术含量，不过这只是为数不多的公司在做。如果想要稳定的可以转后端试试。 转Python，Python最近真是很火，因为他跟人工智能发生了关联，其实大部分学Python的没有搞什么人工智能相关，基本都是在搞爬虫。追求浪潮的可以转Python试试。 不要轻易转行，要转就早点转转行有两种我认为是正常的，一种是行业消失或者没落了，个人无法施展才华。另一种是兴趣不在本行，因此转一个自己感兴趣的。而现在大部分转行纯属是为了跟风，为了那点钱，而忽略了长期的发展。我们来看看下面的图。 从图中可以看出，大部分人在35岁前是在加速期，35岁后是上升或者衰落期。以Android开发转前端来说，假设一个Android高级A同学转行前端会变为前端初级，这时从事前端的人都在加速提高，A同学要想赶超前面的拥有同样加速度的人是不可能办到的，这就导致他在转行前期极为被动，A同学还要保证在35岁前成为前端专家或者Leader才有可能在35岁后不进入衰落期，当然这时A同学的Android基本也就荒废了，很难成为专家。如果还想要在技术领域走的更远，就不要轻易的进行转行，如果想要转越早越好，越快越好，因为其他的竞争者都在加速提高，没人会停下等你的。 转行大部分都不是质变一个开发的质变可以理解为在一个领域的大幅提升，或者是不相关领域的跨界，举个例子：可以在Android领域由高级质变为了专家，或者是由一个高级开发升到了Leader，再或者跨界开始做了一些技术相关的培训、演讲、出书等等而被人所熟知。凡是能帮助35岁后进入上升期的都可以看做是一次质变，而转行很少是质变，更多的是倒退回到原点重新出发，形象点来说，就是换了个不同的砖头接着搬砖而已（高技术含量的除外）。因此我们更应该去追求质变，而不是平行或者倒退，一次倒退可以承受，多次倒退就很难在35岁后进入上升期。 如何提升竞争力选择一个细分领域Android现在细分的领域非常多，前面说到的有应用开发、逆向安全、音视频、车联网、物联网、手机开发、SDK开发和智能电视盒子开发等等，在这些领域中选择一个并不断深入。比如音视频，在8年前我刚入门Android时，音视频就是闷声发大财了（PC端），工资高的令人乍舌，现在在移动端，音视频更是青出于蓝，是一个非常好的选择，如果想要入门可以看看何俊林《Android音视频开发》。 尽量学习半衰期长的知识知识半衰期指的是：随着知识更新周期变短，知识裂变速度加快，一个知识落伍的周期。知识半衰期长的职业都是越老越值钱的，比如英语老师和外科医生，知识更新慢并且几乎不会落伍。这一点我们程序员是绝对比不了的，我们的大部分知识半衰期是比较短的，一个框架短短几年可能就会被淘汰，这也导致程序员需要不断的学习新知识，而我们每个人的时间和精力是有限的，那么根据知识半衰期，有策略的进行学习就变得尤为重要。（这个观点很有吸引力） 上面的半衰期图不完全准确，但是却值得参考，如果你是其他的技术领域也可以参考这个半衰期图。这个图不是告诉我们不要去学RN和小程序，而是结合自身工作尽量学习半衰期长的知识。 做减法，尽量专精一门技术现在的社会，技术分工越来越细，越细就意味着大部分企业（小作坊除外）需要专精的人才（最好是精通一门通多门）。你会发现身边脱颖而出的技术人大多都是靠一门技术，却很少看到会一堆技术却都不精通的冒出来。好比在武侠的世界，高手对决都在同一个时间段拿出看家武学，如果看家武学都不精，分分钟被虐，剩下的武学也无需拿出来献丑了。联想到现实版本就是去大公司面试Android，结果Android技术了解不深，被各种虐，剩下的前端技术、后端技术、Python什么的，面试官也没兴趣了解了。 所以并不是你会的技术越多越好，一定要做好减法，先专精一门，然后再去学别的技术。（值得借鉴） 说说最近Android火热的技术Android相关的火热技术最近几年也是频出，没事就在刷屏，我来说说对这些火热技术的看法。 Kotlin，从知识的半衰期来看，这门语言非常值得学习，不过想要普及还是非常难，因为Kotlin还没有表现出非用它不可的竞争力，另外很多企业使用的成本比较高，大多数领导都是不求有功但求无过，不会下力气推广。 Flutter，从知识的半衰期来看，这个框架存在的时间相对不会长，目前也就一些有技术储备的公司去试验去尝试，如果自己公司技术储备不够，就贸然当小白鼠显然不是很明智。 这两个技术都建议大家来学习，但不要指望它们会给你增加什么太大竞争力，李四1周能学会，张三同样也能。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>规划</tag>
        <tag>半衰期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之CSS入门]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[详解css中的display属性（行内元素和块级元素） 首先，所有主流浏览器都支持display属性。其次，display属性规定了元素应该生成的框的类型。默认值：inline 我们常用的display属性有： inline block inlien-block none 把display设置成none就不会保留元素本该显示的空间（元素直接不显示），但是visibility：hidden会保留。那么其他三个有什么区别呢？看下下面css代码： 1234567891011&lt;body&gt;&lt;span class=&quot;inline&quot;&gt;inline&lt;/span&gt;inline &lt;span class=&quot;block&quot;&gt;block&lt;/span&gt;block &lt;span class=&quot;inline-block&quot;&gt;inline-block&lt;/span&gt; inline-block&lt;/body&gt; 点此看效果 inline特性我们发现内联对象inline给它设置属性height和width是没用的，致使它变宽变大的原因是： 内部元素的宽高‘+padding’。观察inline对象的前后元素我们会发现inline不单独占一行，其他元素会紧跟其后。 block特性 而块对象‘block’是可以设置宽高的，但是它的实际宽高是本身宽高+’padding‘。观察block的前后元素，我们会发现block会独占一行。 如果，我们即希望div有宽高，又不希望它独占一行要怎么办？ inline-block这个时候我们就需要’inline-block‘属性了，我们看下显示效果，就会发现： inline-block即具有block的宽高特性又具有inline的同行元素特性。 也就是说，当我们想让一个元素即不独占一行，又可以设置其宽高属性的时候，我们就可以选择inline-block了。 行内元素特点 和其他元素都在一行上； 元素的高度，宽度，行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素特点 每个块级元素都是从新的一行开始，并且其后的元素也另起一行； 元素的高度，宽度，行高及顶部和底部边距都是可以设置的； 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素一致），除非设定一个宽度。 在html中，span,a,lable,input,img,strong和em就是典型的行内元素。div,p,h1,form,ul,li就是块级元素。 块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 更多CSS display请参考]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
        <tag>微信</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程中的TCP和UDP通信方式简介]]></title>
    <url>%2F2018%2F11%2F03%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code） TCP方式和UDP的区别 TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现 UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现 ### 网络协议简介通过上图知道不管是TCP还是UDP都是互联网络协议中的一层—传输层协议。 图中简单对网络协议做了分层，金典的网络协议是四层，这里给了不同的四层。 最底层的以太网协议规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信，但是以太网协议不能解决多个局域网如何互通，这由IP协议解决（IP协议可以连接多个局域网） IP协议定义了一套自己的地址规则，成为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息（路由器就是基于IP协议，局域网之间靠路由器连接）。 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入很多根网线，路由器内部有一张路由表，规定了A段IP地址走出口一，B段IP地址走出口二。…通过这套指路牌，实现了数据包的转发。 IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要靠TCP协议了。 TCP协议具体的TCP协议可能是一本书的内容，这里管中窥豹一下。简单来说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 原来，我们只是简单知道TCP协议的七次==连接==，三挥四别，这里我们来完整了解下他其中的原理。 TCP数据包大小以太网数据包（pakage）的大小是固定的，最初是1518字节，后来增加到了1522字节。其中，1500字节是负载（payload），22字节是头信息（head）。IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少20字节，所以IP数据包的负载最多1480字节，TCP数据包在IP数据包的负载里面，TCP的头也要占20字节，因此TCP数据包最大负载1460字节。由于，IP和TCP协议往往还有额外的头信心，所以TCP实际负载为1400字节左右，下图会清晰的表明这种关系： 因此，一条1500字节的信息需要两个TCP数据包来承载发送。==HTTP/2协议==的一大改进就是压缩了HTTP协议的头信息，使得一个HTTP请求可以放在一个TCP数据包里面，而不是分成多个，这样就提高了传输速度。 TCP数据包的编号（SEQ）一个包1400字节，那么发送一个10M大小的数据包，需要发送7100多个包，发送的时候，TCP协议会给每个包编号，一边接收方按照顺序还原，万一发生丢包，也可以知道丢失的是哪个包。一般第一个包编号是随机的。假设我们叫第一个包编号为1号包，这个包负载100字节，那么可以推算出下一个包的编号应该是101，就是说，每个数据包都可以得到两个编号：一个自身的编号，及下一个数据包的编号。几首方由此知道，应该按照什么顺序将他们还原成原始文件。（可以用抓包工具抓来看） TCP数据包的组装收到TCP数据包以后，由操作系统来完成组装操作，应用程序是不会直接处理TCP数据包的，而是处理由他封装的例如HTTP协议的数据包。对应用程序来说，不用关心数据通信的细节，应用程序需要的数据放在了TCP数据包里面，有自己的格式（比如常见的HTTP协议），TCP不能标识原始文件大小，这个只能由应用层协议来规定，如HTTP头COntent-length，表示了信息体的大小。对于操作系统来说，就是持续的接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据，一旦组装好TCP数据包，就把他们交给引用程序（怎么组装呢？？），TCP数据包里面有个端口（port）就是用来指定转交给监听该端口的应用程序。 如上图：系统根据TCP数据包中端口，将组装好的数据转交给相应的应用程序。如21端口是FTP服务器，25端口是SMTP（邮件协议）服务，80是Web服务器（常用的Http请求）。这些一般都是在服务端的。 慢启动和ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。==TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。==（NB）。Linux 内核里面设定了（常量==TCP_INIT_CWND==），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 期待要收到下一个数据包的编号。 接收方的接收窗口剩余容量 （图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。） 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 数据包的遗失处理丢包时有发生，TCP的可靠性是怎么保证的呢？简单来说：由于每一数据包都带有编号，如有下一个数据包没收到，那么ACK的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。==这会导致大量重复内容的 ACK==。如果发送方发现收到了==三个==连续重复的ACK，或者超时没收到任何ACK，就会确认丢包了，及5号包丢了，从而再次发送这个包，通过这种机制，TCP保证了不会有数据包丢失。==（好像TCP会丢包的）== 。下图比较形象说明了这个例子： （图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。） TCP连接 Java的TCP实现（Socket）123456789101112131415161718192021public void client() throws Exception &#123; // InetAddress.getLocalHost()为客户端请求连接的主机号，此处设置为本地主机，服务进程的端口号是8090 // 主机号和端口号唯一确定了唯一主机上面的唯一进程。 Socket socket = new Socket(InetAddress.getLocalHost(), 8090); // socket.getOutputStream()获得输出流，通过输出流像主机发送数据。 OutputStream os = socket.getOutputStream(); os.write("黑猫呼叫白猫收到请回复!".getBytes()); // 关闭数据输出，如果不关闭的话服务端并不知道数据传输已经结束还会一直等待。 socket.shutdownOutput(); // 接收server端发送的数据 InputStream is = socket.getInputStream(); int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; is.close(); os.close(); socket.close(); &#125; 123456789101112131415161718192021222324public void server() throws Exception &#123; // 给服务端一个端口号8090使得客户端可以连接。 ServerSocket ss = new ServerSocket(8090); // 接受客户端的连接 Socket socket = ss.accept(); // 获得客户端的输入流 InputStream is = socket.getInputStream(); // 输出client端发送的数据 int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; OutputStream os = socket.getOutputStream(); // 通过输出流向客户端发送数据。 os.write("黑猫这里是白猫，我已收到你的呼叫!".getBytes()); os.close(); // socket.shutdownOutput(); is.close(); socket.close(); ss.close(); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+Github搭建个人Blog]]></title>
    <url>%2F2018%2F10%2F24%2FHEXO%2BGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog%2F</url>
    <content type="text"><![CDATA[HEXO背景hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面 超快部署 支持MarkDown 一键部署 丰富的插件 下面以我的Blog为例，记录搭建过程。 环境准备 安装NodeJs 123456789//mac下安装node很简单，使用mac下的包管理工具brew命令就可以了$ brew install node$ brew install npm//brew一般被安装在/usr/local/bin 目录下面//验证是否安装成功$ node -v 安装HEXO 1$ npm install hexo-cli -g 运行 装上Hexo后就可以在本地跑服务了，执行一下命令（HEXO的常见命令） 1234567$ hexo clean// 生成静态网页$ hexo g / hexo generator// 开启服务$ hexo s / hexo server运行：localhost：4000 托管托管就是将你生成的静态网页保存在服务器上，别人可以通过域名去访问（当然需要在hexo上去配置）. 一般是在github上免费托管，也可以自己去买个小鸡，既可以搭个小机场，也可以托管博客. 如果要部署到github上，首先要有GitHub账号（没有的可以不用看了），然后在仓库建一个”github账号.github.io” 名字一定要一样 添加部署插件hexo-deployer-git 1$ npm install hexo-deployer-git --save 添加git源 1234567// 编辑根目录.config.ymlvim .config.ymldeploy: type: git repo: &lt;repository url&gt; branch: [branch] branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 添加源后就可以部署了 1$ hexo d 配置全局配置关于hexo的配置都在根目录下的.config_yml下面，而关于主题的配置都在/theme/**/.config_yml下面，详细配置可以查看官方文档 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言 theme -&gt; 主题配置（主题名字 /theme目录下） 坑：进行配置时，需要在冒号:后加一个英文空格 主题配置Hexo 中有很多主题，可以在官网查看。主题现在比较流行的是Next — hexo-theme-next。 下载：推荐去官方看最新下载。 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 设置主要是在theme/next/_config.yml文件。然后去找官方或者别人的方案修改即可。 发布文章 使用命令：1$ hexo new test 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 直接将写好的markdown文件放在_posts文件下面即可，在markdown下添加头部 1234---title: categories: []--- 使用命令查看效果 12$ hexo g$ hexo s 主题美化主题美化借鉴了一些前人的集思广益，参考了网上许多文章教程，本博客就是实践出来的，感谢！ 这里mark一些借鉴连接，供大家详参！ Hexo主题美化 干货 Hexo官网]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android存储]]></title>
    <url>%2F2018%2F10%2F22%2FAndroid%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[Android存储路径先来看一张大图： 内部存储 Environment.getDataDirectory().getParentFile();也就是根目录，一般就是指/data/data目录下的数据，需要root之后可以看见 /data/app 该文件存放着系统中安装的第三方应用apk Android的应用安装就是将应用安装包拷贝到/data/app目录下面，每个包本质是一个zip压缩文件。为了提升启动效率，Android会将解压的dex提取出来，缓存在/data/dalvik-cache目录下 api 路径 getDataDirectory() /data getDownloadCacheDirectory() /cache getRootDirectory() /system /data/data 该文件夹存放存储包==私有数据==，对于设备中每一个安装的App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除data/data目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类： 地址 说明 api data/data/包名/cache 存放缓存信息 context.getCacheDir() data/data/包名/database APP数据库信息 context.getDataDir() / context.getDatabasePath(name) data/data/包名/files 存放APP的文件信息 context.getFilesDir() 外部存储每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。 获取外部存储路径及状态 Environment.getExternalStorageState() Environment.getExternalStorageDirectory() 公共目录 Android在外部存储上提供了十个公共目录来存储对应的文件，通过api：Environment.getExternalStoragePublicDirectory(type)来访问 名称 地址 DIRECTORY_MUSIC /storage/emulated/0/Music DIRECTORY_PODCASTS /storage/emulated/0/Podcasts DIRECTORY_RINGTONES /storage/emulated/0/Ringtones DIRECTORY_ALARMS /storage/emulated/0/Alarms DIRECTORY_NOTIFICATIONS /storage/emulated/0/Notifications DIRECTORY_PICTURES /storage/emulated/0/Pictures DIRECTORY_MOVIES /storage/emulated/0/Movies DIRECTORY_DOWNLOADS /storage/emulated/0/Downloads DIRECTORY_DCIM /storage/emulated/0/Dcim DIRECTORY_DOCUMENTS /storage/emulated/0/Documents 3. 私有目录 Android2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。==与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。====和内部存储一样，会在 SD 卡的 Android/data ++目录下生成对应包名的文件夹++== 地址 api /storage/emulated/0/Android/data/应用包名/files context.getExternalFilesDir(type) /storage/emulated/0/Android/data/应用包名/cache context.getExternalCacheDir() /storage/emulated/0/Android/obb/应用包名 context.getObbDir() Android其它目录 /system/app 和 /data/app 的区别 /data/app 里软件权限没全开，/system/app 里的软件获取了所有权限 /data/app 可以应用卸载，/system/app 只能 root 后删除 /data/app 文件夹大小随便，/system/app 文件夹有大小限制 卸载/system/app 目录下的文件并不会增加系统空间，即可用 ROM 空间]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维的误区-幸存者偏见]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%80%9D%E7%BB%B4%E7%9A%84%E8%AF%AF%E5%8C%BA-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81%20%2F</url>
    <content type="text"><![CDATA[何为“幸存者偏见” “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。 &emsp;&emsp;&emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下： 有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？ 不同领域中的“幸存者偏见”西赛罗的那个故事，属于宗教领域的“幸存者偏见”。除了宗教领域，还有很多领域（甚至可以说，所有的领域）都会存在这类偏见。下面，俺挑选几个领域来举例。 IT 领域——创业的“银弹” &emsp;&emsp;&emsp;作为 IT 从业人员，俺经常在某些 IT 网站上看到某某公司的创业事迹。如果你也跟俺一样，估计这方面的故事也看了不少。 &emsp;&emsp;&emsp;不知你有没有发现，那些广为流传的创业案例，都是【成功】案例。越成功的，越具有传奇色彩，被宣传的次数就越多（比如乔布斯、盖茨）。相反，那些创业【失败】的案例，（相比而言）被提及的次数非常非常少。 &emsp;&emsp;&emsp;这会产生啥问题捏？ &emsp;&emsp;&emsp;假设某个有志青年想要创业，他看了很多创业成功的案例，这些案例都提到某些共同的因素。于是捏，此人就误以为这些共同的因素是“银弹”——只要具备这些银弹，创业必定成功。这就如同西赛罗的那个故事——只看到存活的祈祷者，就误以为“祈祷”是存活的【充分条件】。 成功学领域——虚假的“充分条件” &emsp;&emsp;&emsp;说完“创业”，很自然就联想到“成功学”。那些鼓吹“成功学”的文章/书籍，通常存在很多谬误，其中一个谬误是——号称“某某方法论”是成功的【充分条件】。换句话说，只要具备了该方法论，就一定可以获得成功。 &emsp;&emsp;&emsp;为啥俺说这是一个谬误捏？因为这些鼓吹成功学的文章/书籍，通常都【没有】去检验：该方法论是否也出现在失败者身上。只要有一个失败者也采用了该方法论，就足以说明——这个方法论【不是】成功的充分条件。比如说，很多成功学的理论提到了“勤奋”是成功的充分条件。但其实捏，勤奋而没有成功的，大有人在。 投资领域——仅凭运气的“股神” 最近半年，天朝股市迎来新一轮的牛市行情。前几天有读者建议俺聊聊股市的话题，所以今天顺便拿投资领域来说事儿。似乎在每一个国家的股市中，都有那么几个人被誉为“股神”。如果碰到牛市，被冠以“股神”的人还会再多出好几倍。（暂且【不】考虑“弄虚作假、谎报战绩”的情况）假设这些获得股神称号的人，都在实际操作过程中获得远高于大盘的收益率，他们有资格获得“股神”的称号吗？为了说明这个例子，俺转载某篇文章的其中一段（此文写于1984年）。 我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。 “幸存者偏见”导致的问题 错误的认知 这个最好理解了——由于“错误的认知”会导致你对“沉默证据”的忽视，所以你对该领域的认知是不完全的。 错误的归因 在【只看到】“显式样本”的情况下，你可能会产生一些错误的归因。“幸存者偏见”导致的“错误归因”会有很多种。俺这里仅举几个例子。 因果倒置 想必大伙儿都看过举重比赛。对于举重运动员，很多人都有一个错误的观点——以为这些运动员是在练习举重之后，才导致身材变得矮壮。但实际上捏，举重队在一开始筛选运动员的时候，就把那些身材细长的忽略掉了（这些身材细长的候选人，就是“沉默的样本”）。换句话说，是因为他们身材矮壮，才有可能被选中去参加举重培训，而不是因为参加举重培训导致身材如此——这就是【因果倒置】。 牵强的归因（无中生有） 假设某个赌徒去赌场玩“押大小”（此游戏的胜负概率皆为 50%），连续赢了10次。对于大型赌场，每天来玩的人足够多，那么一段时间之后，总会出现某个赌徒玩“押大小”连续赢10次（甚至更多次）。从概率学的角度讲，这是很普通的。但是对该赌徒而言，如果他陷入了“幸存者偏见”这个误区，他就会企图给这个现象找到一个解释（进行“归因”）。假如此人是个宗教信徒，他/她可能会断言——有神明相助。这就属于“牵强的归因”——把【随机事件】看作是有其它原因，并企图在随机性之外寻找一个解释。 错误的决策 还以刚才赌徒的例子来说事儿。假设这个赌徒是宗教信徒，并且误以为自己连续赢10次是神明相助，那么他/她就会获得一种【虚假的信心】，并在这个“虚假信心”的支持下继续玩，甚至还会加大赌注/筹码。最后的结局很可能是——彻底输光。这就是“幸存者偏见”导致的“错误决策”。如果你比较喜欢琢磨，可以把这个赌场的例子替换成天朝的牛市，你会发现其中有某些相通之处。 如何对付“幸存者偏见”？ 意识到“沉默证据”的存在 这是最起码的一点——你首先要能意识到“沉默证据”的存在。这说起来容易，做起来很难——你需要形成这样一种思维习惯：每当看到“显式的证据”，你都要在内心反问：是否存在与之对应的“隐式证据”？ 找到不同类型、不同层次的“沉默证据” 在前一条的基础上，你如果能找到“沉默的证据/隐式的证据”，自然就会获得更全面的认知。有必要提醒一下：“隐式的证据”有时候不止一种类型。碰到这种情况，不是每个人都能想到所有的类型。前面提到的“天朝舆论”的例子。那些思考问题不够深入的同学，通常只意识到“网管审查/删贴”导致的“沉默证据”，而忽略了更隐蔽的“沉默证据”——那些连上网条件都没有的人，是无法在网上表达不满的。 决定一个样本会成为“隐式样本”or“显式样本”，有两种可能：情况A至少有一个原因在起作用（比如前面提到“莎草纸的例子”，气候是原因之一）情况B根本就【没有任何原因】（比如前面提到的“抛硬币的猩猩”），仅仅是随机性决定了某个样本会成为“显式” or “隐式”。对此种情况，如果你非要去找出一个原因，就会出现前面提到的“牵强的归因”。 如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。具体该如何排除捏？在本文的最后，咱们重新回到本文开头提到的那篇巴菲特演讲。在说完“猩猩抛硬币”的游戏之后，巴菲特又说了如下一段话。通过这段话，你可以借鉴一下——如何规避“随机因素”的干扰。 然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；(b)如果经过20天的竞赛，只剩下215只赢家；(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。 于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。 科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。 除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。 在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。 我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>好文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下全局翻墙]]></title>
    <url>%2F2018%2F10%2F20%2FMac%E4%B8%8B%E7%9A%84%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mac下全局翻墙 路由翻墙 ssr + .bash_profile 使用工具，类似profixer，surge等 使用iterm的，环境变量也可以使用.bash的(需要在.zsh中去设置环境变量走.bash_profile)也可以在.zshrc中 由于ss或者ssr只是支持了socks5的代理，也就是所有的都走socks5协议，而浏览器本身是支持socks5的（当然还有http，https，ftp等），但是如果你想mac上装的客户端，比如telegram也能通过ssr达到科学上网就想多了，但是这些软件，还比如AS都可以手动去设置代理的（socks5），一般ssr默认的设置如下： 123ip：127.0.0.1# http走的是1087端口port：1086 方法2设置步骤 vimb(vim .bash_profile) 修改文件（添加下面代码） source .bash_profile 验证：curl www.google.com 12345# proxyproxy=socks5://127.0.0.1:1086export http_proxy=$proxyexport https_proxy=$proxyexport ftp_proxy=$proxy 通过上面设置就能在命令行中发现已经可以科学上网了，目前还有两个蛋痛的地方没解决： profixer在mac上装不了了，一直弹窗。权限都给了 使用Google Drive同步文件用不了，只有将ssr设置全局才可以，MD。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云集成IM]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1IM%E9%9B%86%E6%88%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面 集成集成其实很简单，网易提供了两种方式，jar和gradle，毫无疑问gradle 12345678// 基础功能 (必需)netease_basesdk : &apos;com.netease.nimlib:basesdk:5.1.1&apos;,// 音视频需要netease_avchat : &apos;com.netease.nimlib:avchat:5.1.1&apos;,// 音视频需要netease_nrtc : &apos;com.netease.nimlib:nrtc:5.1.1&apos;,// 全文检索服务需要netease_lucene : &apos;com.netease.nimlib:lucene:5.1.1&apos;, 其中第一个是早就集成了的，自带IM功能，第二第三则是音视频需要的，第四个是需要做聊天记录搜索要用到的 APPID申请 权限 初始化 前两个看官方文档就可以了，初始化一般就是在主APP的Aplication中进行，代码如下 1234567891011// 注册通知消息过滤器registerIMMessageFilter();// 初始化消息提醒NIMClient.toggleNotification(true);// 注册网络通话来电enableAVChat();//初始化IM UI组件NimUIKit.init(this); 官方文档和demo中也有说明，需要使用到哪种能力就去初始化哪些，比如该版本还用到了IM的自定义消息，那么也必须在这里进行注册 注意：以上的初始化只能在主线程中进行，为此，云信提供了一个API：NIMUtil.isMainProcess(this) 123NIMClient.getService(MsgService.class).registerCustomAttachmentParser(new CustomAttachParse()); NimUIKit.registerMsgItemViewHolder(DiagnosisMsg.class, MsgViewHolderDiagnosis.class); IM消息监听 123456// 注册IM消息监听 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, true);// 反注册 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, false); 相关概念 注册登陆：集成网易云后，需要将本地用户与网易云id关联，每一个用户在网易云有一个唯一的accid和token，对于登陆相当于用户名及密码，对于业务比如：视频/IM则相当与电话号码，你需要和别人通信的时候必须知道对方的accid。 用户信息托管：由于本地用户在网易云有一个id关联，那么当要用到网易云的一些能力的时候，我们希望用户的一些基础信息（头像，昵称）是要与本地后端保持一致的。 消息锚点：其实就是一个消息对象，它携带了一些时间或者其他信息，方便搜索。 上面两点都是本地后端处理的，前段需要处理的则是，在登陆系统成功后，需要手动调用网易登陆api去帮助用户登陆到网易云，并且监听用户的登陆状态。 123456789101112131415161718192021222324252627282930313233public void nimLogin(User user) &#123; LoginInfo info = new LoginInfo(user.accid, user.token); // config... RequestCallback&lt;LoginInfo&gt; callback = new RequestCallback&lt;LoginInfo&gt;() &#123; @Override public void onSuccess(LoginInfo param) &#123; Logger.d(&quot;login nim success&quot;); &#125; @Override public void onFailed(int code) &#123; Logger.d(&quot;login nim failed :&quot; + code); &#125; @Override public void onException(Throwable exception) &#123; Logger.e(exception, &quot;login nim failed&quot;); &#125; &#125;; AbortableFuture&lt;LoginInfo&gt; request = NIMClient.getService(AuthService.class).login(info); request.setCallback(callback); &#125; @Override public void observeNimOnlineStatus(User user) &#123; NIMClient.getService(AuthServiceObserver.class).observeOnlineStatus( (Observer&lt;StatusCode&gt;) status -&gt; &#123; Log.i(&quot;nim&quot;, &quot;User status changed to: &quot; + status); if (status.shouldReLogin()) &#123; new Handler().postDelayed(() -&gt; nimLogin(user), 5000); &#125; &#125;, true); &#125; IM相关界面由于lib_neteaseui库提供了界面能力，所以自然自定义界面的话需要集成他的界面，这里有两种方式 集成现有类（比如p2pmessage）,只需要修改layout，并且传递需要的参数即可。 继承SDK中的UI并实现ModuleProxy代理类中方法 开启单聊很简单直接看代码 1IMMessageActivity.start(getContext(), entity.accid, customization, null, IMMessageActivity.class); 其中，entity.accid代表了对方的号码。 消息面板设置 面板类：MessageListPanelEx，这里面封装了发送消息面板的所有功能 抽屉：基类BaseAction，比如拍照，相片或者自定义类型都是通过这个基类来实现的。 IM面板layout：nim_message_activity_text_layout 设置用户托管信息： 12// 设置网易云用户资料（IM中的头像，昵称等）NimUserManager.setUserBasicInfo(user.patientName,user.imgUrl); 消息设置 消息屏蔽： 1234//屏蔽所有消息NIMClient.toggleNotification(false);//屏蔽某个用户消息NIMClinet.getService(FriendService.class).setMessageNotify(account,checkState) 消息接收 12345678910/** * IM消息监听 */ com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt; messageObserver = new com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt;() &#123; @Override public void onEvent(List&lt;IMMessage&gt; imMessages) &#123; Logger.d(&quot;im message received&quot;); &#125; &#125;; 自定义消息 自定义消息比较复杂，参见代码。具体步骤如下： 定义消息 1234567/** * 需要多端统一 */public interface CustomAttachmentType &#123; int diagnosisMsg = 1001;&#125; 自定义消息的基础类 1234567891011121314151617181920public abstract class CustomAttachment implements MsgAttachment &#123; protected int type; CustomAttachment(int type) &#123; this.type = type; &#125; public void fromJson(JsonObject data) &#123; if (data != null) &#123; parseData(data); &#125; &#125; @Override public String toJson(boolean send) &#123; return CustomAttachParse.packData(type, packData()); &#125; public int getType() &#123; return type; &#125; protected abstract void parseData(JsonObject data); protected abstract JsonObject packData();&#125; 自定义消息结构类（用于组装自定义数据） 1public class DiagnosisMsg extends CustomAttachment 自定义消息解析类（用于显示自定义消息） 1public class CustomAttachParse implements MsgAttachmentParser 参见官方文档 其他 注册账号accid网易云强制小写 网易云消息从后端还是本地拉取 1messageListPanel = new MessageListPanelEx(container, rootView, anchor, false, remote); 其中最后一个参数remote = true表示从云端拉取数据 IM聊天点击头像事件layout：MsgAdapter中layout.nim_message_item 点击事件：NimUIKitImpl.setSessionListener]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的常用命令行]]></title>
    <url>%2F2018%2F10%2F19%2FMac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看IP123$curl ip.gs$ifconfig 关于文件操作由于mac下面不能使用右键新建文件，所以需要使用一些工具，如workflow，或者直接命令行 123456789101112# 查看文件如果没有则创建新文件touch filename# 新建文件夹mkdir filename# 删除文件或者目录rm -rf filename# 查看文件详细信息stat filename# 查看目录结果，需要装treenpm install treetree -L 1 vim常规操作 操作命令 效果 i 在光标处插入，进入编辑模式 dd 剪切光标所在的一行内容 yy 复制光标所在的一行内容 D 删除光标右边的所有内容 gg 将光标快速移动到文件首 G 将光标快速移动到文件尾 0 将光标快速移动到行首 $ 将光标快速移动到行尾 退出命令 效果 :w 保存 :q 未保存直接退出（如果没有修改，用下面的命令） :q！ 强制退出 :wq 保存退出 :wq 强制保存退出]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用心得]]></title>
    <url>%2F2018%2F10%2F18%2Fgit%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[git reset1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用1git reset HEAD &lt;file&gt; 将某个文件从暂存区拿出来。 2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用1git reset -soft/--mix/--hard &lt;commite id&gt; 会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。git reset命令的使用 选项 git reset的影响 选项 HEAD 索引（暂存区） 工作目录（源代码） –soft 是 否 否 –mix 是 是 否 –hard 是 是 是 HEAD：表示当前git指针指向的位置索引：表示add之后去到的暂存区工作目录：表示代码文件的改动提交C1 –&gt; 提交C2总结就是：soft后git指针会指向C1的提交，而C2修改的文件还是add状态，修改内容不会丢失，对现有的版本改动最小；mix后（git reset默认操作）git指针会指向C1提交，C2修改的文件不是add状态（需要重新add）不在暂存区，文件修改内容不丢失；hard后git指针指向C1提交，C2修改文件不在暂存区，文件修改丢失，完全恢复到C1提交的状态. hard慎用 或者一行一行源码分析清楚+AbstractQueuedSynchronizer+-二-12git reset HEAD~git reset HEAD~1 如果你提交了多个commit，那么可以通过修改HEAD～之后的数字，如撤销前3次的commit 1git reset HEAD~3 下面是一个很有用的后悔药12# 查询所有git的提交记录，包括详细commite idgit reflog 下图为git reflog的界面 这里面记录了你本地仓库中相关切换和更改的详细描述清单，你可以通过： 12# 可以通过以下命令回到任何一个位置git reset HEAD@&#123;n&#125; git add语法 语法 描述 git add -A stages All git add . stages new and modified, without deleted git add -u stages modified and deleted, without new git merge合并现在最简单的merge模式就是fast-farward merge了，就是从master拉出的分支develop后，master没有再做任何修改，所有的代码都在develop分支上提交，等到最后要合并develop到master上时，可以使用如下命令： 1234# 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop git tag打标签标签可以针对某一时间点的版本做标记，常用于版本发布。 1.列出标签 1234# 在控制台打印出当前仓库的所有标签git tag# 搜索符合模式的标签git tag -l ‘v0.1.*’ 2.打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。 123456# 创建轻量标签git tag v0.1.2-light# 创建附注标签git tag -a v0.1.2 -m &quot;0.1.2版本&quot;# 针对某个提交打标签git tag v1.0 &lt;commite id&gt; 3.切换标签 1git show v0.1.2 4.删除标签 123456# 删除本地标签git tag -d v0.1.2# 删除远程标签git push origin --delete tag v1.0# 或者(已验证)git push origin :refs/tags/V1.2.0 5.标签发布 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： 1234# 将v0.1.2标签提交到git服务器git push origin v0.1.2# 将本地所有标签一次性提交到git服务器git push origin –-tags git stash该命令用来保存当前分支上还没commite的修改，使当前分支保持clean状态（git status） 使用场景:执行git stash后，你在dev分支没有提交的修改暂时被“藏”了起来，看起来dev分支是干净的。但是，请一定注意，你还在dev分支！因为你需要切换到master分支去修改bug，因此此时需要切换到master分支（如果不执行git stash就切换到master分支是不行的：git会报告当前dev分支还存在未提交的修改，比如先提交才允许你切换分支，而出于各种原因，你还不能现在提交dev分支的内容（一般也就先提交了，大不了再切回来改就是哦），这就是git stash存在的价值）。 切换到stash分支后的恢复命令12345678# 恢复并删除stash内容git stash pop# 查看现场git stash list# 保存现场git stash git分支管理 master:主分支，当前分支上的代码随时可以直接发布，并且只能通过Pull Request从其他分支进行合并，而不能直接push修改。当开发告一段落，产生了新的可供发布的代码时，master分支通过Pull Request更新了代码，同时，每一次更新必须添加对应版本号的标签TAG。 develop:开发分支，保存当前最新开发成果的分支，即当一个新功能开发完毕需要先合并到develop分支，这个分支的代码会进行每日的代码持续集成(Daily Build)。所有的开发任务都是从这个分支Checkout新的特性分支进行开发。 feature:特性分支，当开发新的功能时，从develop分支Checkout新的feature分支，这个分支的代码最终要合并回develop分支或者废弃掉(例如预研功能效果不好时)。feature分支最好以功能为单位。 hotfix:紧急修复分支，唯一从master分支派生的分支，当生产环境中发现了异常或者缺陷的时候，从master分支上指定的TAG版本Checkout hotfix分支进行紧急修复工作，当修复完成之后，必须同时合并到master分支和develop分支。合并完代码之后删除hotfix分支。 新建分支(已feature为例) 12345678# 切换本地分支到develop分支git checkout develop# 拉取远程Git仓库中的最新的develop分支的代码git pull# 创建本地特性分支featuregit checkout -b feature# 推送本地特性分支到远程Git仓库（即创建远程特性分支），-u为追踪远程分支git push -u origin feature 已feature分支为例开发合并全流程 12345# 开发代码。以下两步的作用是保证你本地的feature分支的代码为最新，因为有可能你是和别人合作开发的该功能，如果你刚更新过或者你是一个人在开发则可以省略此操作# 切换到本地feature分支git checkout feature# 拉取远程分支代码，--rebase最好加上git pull --rebase 123456789# 合并代码# 切换到本地develop分支git checkout develop# 拉取最新的远程origin/develop分支代码，因为可能已经有人提交了代码git pull --rebase# 从本地feature-login分支合并代码，--no-ff为禁止fast-farward模式git merge --no-ff feature-login# 推送到远程分支git push 1234567# 代码已经合并完，可以删除本地特性分支和远程特性分支# 删除本地feature-login特性分支git branch -d feature-login# 删除远程origin/feature-login特性分支（废除，实验无效）git branch -r -d origin/feature-login#在v1.7.0 之后，可以使用这种语法删除远程分支(同删除标签tag类似)git push origin --delete &lt;branch name&gt; 本地根据tag创建分支12345# 根据tag创建分支git branch &lt;new-branch-name&gt; &lt;tag-name&gt;git branch v2.2-fixbug V2.2#将新分支推送到远程仓库git push origin v2.2-fixbug git pushpush到远程分支有https和ssh两种方式，https每次push都会要求输入用户名和密码，而ssh只要在远端注册了ssh key则不需要。另外，ssh可以上传大文件，https貌似不行。12# 这个会把本地当前分支的内容push到远端的demo分支，如果远端没有该分支则自动创建git push -u origin demo 1234# 生成ssh key,该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：ssh-keygen# 可以查看远程分支情况git remote -v git reset第一小节有类似操作。 本地代码回滚 1234# 回滚到commit-id，讲commit-id之后提交的commit都去除git reset --hard commit-id# 将最近3次的提交回滚git reset --hard HEAD~3 远程代码回滚。应用场景：app已经发布了，发现有问题需要回滚到某个commit，再重新发布。这时需要先将本地分支退回到某个commit，删除远程分支，再重新push本地分支。操作步骤（还没检验） 1234567891011121314# 1git checkout the_branch# 2git pull# 3 备份一下这个分支当前的情况(本地新建分支？)git branch the_branch_backup# 4 把the_branch本地回滚到the_commit_idgit reset --hard the_commit_id# 5 删除远程 the_branch（可以删除远程分支）git push origin :the_branch# 6 用回滚后的本地分支重新建立远程分支git push origin the_branch# 7 如果前面都成功了，删除这个备份分支git push origin :the_branch_backup git remote多源操作，一般是一个源，但是多源也很有用1234567891011121314151617# 如果想关联另一个远端仓库（加一个源）git remote add &lt;origin name&gt; git@gitlab.com:demo/demo.git# 显示全部源git remote / git remote -v# renamegit remote rename &lt;origin name&gt; &lt;origin new name&gt;# deletedgit remote rm &lt;origin name&gt;# 查看指定源的全部信息git remote show &lt;origin name&gt;# 修改远程仓库地址git remote set-url origin &lt;origin url&gt; git commit合并某个分支上的某个commit或者多个commit到master分支上123dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature] 比如，feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做： 123# 示例git checkout mastergit cherry-pick 62ecb3 在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。(未实验，要实验一下) 1234# 首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：git checkout -bnewbranch 62ecb3# 然后，rebase这个新分支的commit到master（--ontomaster）。76cada^ 指明你想从哪个特定的commit开始。git rebase --ontomaster 76cada^ git rebase12345678910111213```### git detached HEAD在一些情况下，会出现detached HEAD的情况，（后面分析下原因）。detached head即游离的HEAD，HEAD指向了未知的分支，即不在所有已知的分支范围内。解决办法：```git$ git branch* (HEAD detached at origin/master) dev master HEAD指向了一个未知的分支，可用git checkout -b基于当前分支创建一个新的临时分支保留代码，合并到合适的分支后删除12345678910111213$ git checkout -b tempSwitched to a new branch &apos;temp&apos;$ git branch dev master* temp$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.$ git merge tempAlready up-to-date.$ git branch -d tempDeleted branch temp (was 3e74a7a). git clean -d -fx “{文件名}”在开发中碰到本地修改了一个文件，远程分支对应文件也有修改。后面忘记先pull代码直接commit了，然后想push到远端仓库，发现会报一个错误如下： git冲突please move or remove before you can merge 解决方法就是： 12//默认会把这个文件强制更新为远程文件git clean -d -fx &quot;&#123;文件名&#125;&quot;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaGuide之各种锁]]></title>
    <url>%2F2018%2F01%2F05%2FJavaGuide%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81%2F</url>
    <content type="text"><![CDATA[背景多线程的本质其实就是各种线程对静态资源的合理使用问题，怎么能最大限度发挥CPU性能执行任务。锁这种概念就是解决多个线程抢占资源问题的办法，当A线程使用资源时起时不希望B线程也去使用，因为如果同时操作静态资源会导致读写不一致等问题。 各种锁的分类以下的分类都是站在不同角度对锁这种概念的分类，相互之间并没有必然的关系。 乐观锁和悲观锁这种分类是针对线程要不要锁住同步资源来划分的。 悲观锁：悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，取保数据不会被别的线程修改。Java中synchronized和Lock都是悲观锁，在操作资源前加锁，在释放资源后解锁。 乐观锁：乐观锁则认为自己在使用数据的时候不会有其它线程去修改数据，所以不会添加锁，只是在要更新数据的时候去判断之前又没有别的线程更新了这个数据。如果这个数据没有被更新则当前线程将自己修改的数据成功写入，如果数据已经被其它线程更新，则根据不同的实现方式执行不同操作（报错或者自动重试）。Java中乐观锁是通过使用无锁编程来实现，最常见的是CAS算法，原子类就是典型的乐观锁。 CAS算法其实就是CompareAndSet()方法，是一种解决线程之间抢占资源导致线程不安全的方法。它是一种无锁化（不是显示的加锁，例如sycn，lock等）来实现多线程之间变量的同步保障线程安全的算法。后面会单独讲CAS。 自旋锁和适应性自旋锁首先介绍自旋锁的概念阻塞或者唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间，如果同步代码块中的内容过于简单，状态转换耗费的时间又可能比用户代码执行的时间还要长。在许多场景中，同步资源被某个线程锁定的时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让性能下降很多。如果物理及其有多个处理器，能够让两个或者两个以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU执行时间（这里会涉及线程的一些方法，例如sleep，wait，yield等），看看这个资源是不是很快就会被释放。而为了让请求锁的线程“等一等”，我们需要让当前线程自旋，如果在自旋完成后，持有同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞或者重新被唤醒之类的，而是直接获取资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间短，自旋等待的效果就很好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有限制，如果自旋超过了限定的次数（默认是10次，可以更改）没有成功获取到锁，就应当挂起线程。 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。自适应自旋锁其实就是自旋的时间（次数，循环次数）不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者来决定（怎么决定）。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋邓艾持续相对更长的时间，如果对于某个锁，自旋很少成功获得过，那么以后再尝试获取这个锁时将可能不自旋，直接阻塞线程，避免浪费处理器资源。 在自旋锁中，另有三种常见的锁形式：TicketLock，CLHlock和MSlock。（TODO查查资料） 无锁/偏向锁/轻量级锁/重量级锁这四种锁是指锁的状态，专门针对synchronized的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaGuide之volatile]]></title>
    <url>%2F2018%2F01%2F04%2FJavaGuide%E4%B9%8Bvolatile%2F</url>
    <content type="text"><![CDATA[背景Java中并发程序正确地执行，必须要保证原子性、可见性以及有序性，只要有一个没有被保证，就有可能会导致程序运行不正确。 原子性：一个操作或者多个操作要么全部执行完成且执行过程中不被中断，要么就不执行。 可见性：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其它线程能够立即看到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 volatile其实就是解决上面“可见性”的关键字，它可以看作是轻量级的Synchronized，它保证了共享变量的可见性。为什么会存在可见性这种问题呢？下面看下Java的内存模型。 Java内存模型（JMM） Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量（这些变量都是从主内存中拷贝来的）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行（提高效率），不同线程之间也无法直接访问对方工作内存中的变量，线程间变量传递均需要通过主内存来完成。 为什么会定义这种内存模型呢？（因为CPU的计算能力很强大，相对内存的速度比较慢，为了跟上CPU的处理速度所以优化了内存处理的速度） 基于上面描述的JMM定义的规则，我们不难想到有可能存在线程A获取到的值是线程B更新主内存之前的值。这个问题其实就是线程之间的可见性问题，一个线程修改的状态对另外一个线程是可见的。也就是线程修改的结果，另一个线程马上就能看到。这个时候如果用volatile修饰变量，就会具有可见性，任何线程对该变量的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存中重新读取最新数据，而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主内存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值。 注意：不是说被volatile修饰的变量并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中（这个就涉及到volatile是怎么实现的问题了） volatile的可见性直接上代码：项目地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class VolatileDemo implements Runnable &#123; private static boolean flag = true; //private static volatile flag = true; @Override public void run() &#123; while (flag) &#123; &#125; System.out.println(Thread.currentThread().getName() + "执行完毕"); //获取当前正在运行的线程 ThreadGroup currentGroup = Thread.currentThread().getThreadGroup(); int noThreads = currentGroup.activeCount(); Thread[] lstThreads = new Thread[noThreads]; currentGroup.enumerate(lstThreads); for (int i = 0; i &lt; noThreads; i++) System.out.println("线程号：" + i + " = " + lstThreads[i].getName()); &#125; public static void main(String[] args) throws InterruptedException &#123; VolatileDemo aVolatile = new VolatileDemo(); new Thread(aVolatile, "thread A").start(); System.out.println("main 线程正在运行"); Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; String value = sc.next(); if (value.equals("1")) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; aVolatile.stopThread(); &#125; &#125;, "thread B").start(); break; &#125; &#125; System.out.println("主线程退出了！"); //获取当前正在运行的线程 ThreadGroup currentGroup = Thread.currentThread().getThreadGroup(); int noThreads = currentGroup.activeCount(); Thread[] lstThreads = new Thread[noThreads]; currentGroup.enumerate(lstThreads); for (int i = 0; i &lt; noThreads; i++) System.out.println("线程号：" + i + " = " + lstThreads[i].getName()); System.out.println("----------------------------------------"); &#125; private void stopThread() &#123; flag = false; &#125;&#125; 这段代码中，flag是一个在几个线程中需要切换的变量，当没有被volatile修饰时，我们来看下执行结果是什么： 梳理一下运行过程： 主线程开始运行，并开启了Thread A（执行死循环） 当输入“1”时，主线程中开启了新线程Thread B，线程B只做了一件事情，将flag设置为false Thread B执行完run()方法就会结速并被销毁 输出当前还存活的线程（主线程，线程A，还有一个是监控线程，B线程由于执行完被销毁了） 奇怪，为什么Thread B明明修改了flag的值，为啥Thread A没有退出循环呢。其实，这里就是volatile的使用场景了。代码还是上面代码，我们先来看看flag被volatile修饰后的执行结果： 梳理一下运行过程： 主线程开始运行，并开启了Thread A（执行死循环） 当输入“1”时，主线程中开启了新线程Thread B，线程B只做了一件事情，将flag设置为false 输出当前还存活的线程（主线程，线程A，还有一个是监控线程，线程B），其中线程B多运行几次有时候有，有时候没有，这个是由于打印的时候线程B的run方法有可能执行完，也可能没有执行完。 由于flag被设置为false，flag又是被volatile修饰，所以会强制A线程去刷新工作线程，从主内存中重新读区flag的值，然后退出死循环，打印当前存活线程。 总结： 可以看到上述代码中flag是否被volatile修饰导致结果完全不一样。没有被volatile修饰时，虽然线程B修改了flag=false值，但是线程A读取的还是缓存在工作线程中的flag=true的值，有可能等线程B去更新主线程的flag值时，线程A或者其它线程再次去主内存中拷贝flag这个值时，结果就时对的，但是这种结果是不确定的。 而被volatile修饰时，线程B修改了flag的值，对线程A而言是直接可见的，线程A会清空缓存，然后去主内存拷贝最新的flag值，触发正确的逻辑。 volatile保证有序性针对原子操作其实还有Atomic相关类，后面再说。其实volatile不光是解决可见性，其实还有禁止重排序问题。volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 1234567//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 简单来说，由于flag变量为volatile修饰，那么在进行指令重排序的过程中，不会将语句3放到语句1语句2前面，也不会放到语句4和语句5后面。但是1和2，4和5的顺序是不保证的。并且，volatile关键字能保证，执行到3时，1和2一定是执行完毕的，且1和2的执行结果对3，4，5是可见的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>原理</tag>
      </tags>
  </entry>
</search>
