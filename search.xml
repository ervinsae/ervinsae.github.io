<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[寒冬将至，Android的出路]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%AF%92%E5%86%AC%E5%B7%B2%E8%87%B3%EF%BC%8CAndroid%E7%9A%84%E5%87%BA%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。 Android开发的天花板很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。 再说职业上，确实Android应用开发很难升任CTO，一般的CTO主要是后端，这主要是两个原因：后端的技术栈很早就成熟了，我8年前转做Android开发时，那帮30多岁的Java开发就已经很厉害了，随着时间的推移，后端技术大牛远比Android大牛的人数要多，也更厉害，他们做技术经理时，我们都还在搬砖； 后端确实可以统筹全局，在公司业务上属于重要地位。 不过我们忽略了最重要的一点，如果我们是做后端的，一定能做到CTO吗？我想也是很难的，所以不要眼睛只盯着高处，先想想自己能达到什么程度，站在半山腰就说山下面的风景不开阔本身也不合理啊。 是否要转行Android不热门了，很多Android开发已经转行了，有的正走在转行的路上，还有的迟疑不决，到底要不要转呢？我们来分析下。 转什么好每个人的自身情况不同，转的方向也会有所区别，转人工智能相关开发肯定是最好的，毕竟风口上的猪也能飞，跟着风口无可厚非。只可惜人工智能相关对学历和算法要求很高，最起码得是个硕士吧，而且这只是低配。那么大多数Android开发可以转的方向主要有前端、后端和Python等等。我大概说一下： 转前端，这个是我认为最好转的一个方向，前端的理念很多都和Android类似，也可以作为Android的延伸，向大前端发展，如果对界面感兴趣的可以转前端试试。 转后端，后端这个就是完全的转行了，看似Java大家都会，但是后端的技术栈可不是只有Java，各种框架绝对叫你头大，很多人强调后端技术深，各种处理高并发看似十分有技术含量，不过这只是为数不多的公司在做。如果想要稳定的可以转后端试试。 转Python，Python最近真是很火，因为他跟人工智能发生了关联，其实大部分学Python的没有搞什么人工智能相关，基本都是在搞爬虫。追求浪潮的可以转Python试试。 不要轻易转行，要转就早点转转行有两种我认为是正常的，一种是行业消失或者没落了，个人无法施展才华。另一种是兴趣不在本行，因此转一个自己感兴趣的。而现在大部分转行纯属是为了跟风，为了那点钱，而忽略了长期的发展。我们来看看下面的图。 从图中可以看出，大部分人在35岁前是在加速期，35岁后是上升或者衰落期。以Android开发转前端来说，假设一个Android高级A同学转行前端会变为前端初级，这时从事前端的人都在加速提高，A同学要想赶超前面的拥有同样加速度的人是不可能办到的，这就导致他在转行前期极为被动，A同学还要保证在35岁前成为前端专家或者Leader才有可能在35岁后不进入衰落期，当然这时A同学的Android基本也就荒废了，很难成为专家。如果还想要在技术领域走的更远，就不要轻易的进行转行，如果想要转越早越好，越快越好，因为其他的竞争者都在加速提高，没人会停下等你的。 转行大部分都不是质变一个开发的质变可以理解为在一个领域的大幅提升，或者是不相关领域的跨界，举个例子：可以在Android领域由高级质变为了专家，或者是由一个高级开发升到了Leader，再或者跨界开始做了一些技术相关的培训、演讲、出书等等而被人所熟知。凡是能帮助35岁后进入上升期的都可以看做是一次质变，而转行很少是质变，更多的是倒退回到原点重新出发，形象点来说，就是换了个不同的砖头接着搬砖而已（高技术含量的除外）。因此我们更应该去追求质变，而不是平行或者倒退，一次倒退可以承受，多次倒退就很难在35岁后进入上升期。 如何提升竞争力选择一个细分领域Android现在细分的领域非常多，前面说到的有应用开发、逆向安全、音视频、车联网、物联网、手机开发、SDK开发和智能电视盒子开发等等，在这些领域中选择一个并不断深入。比如音视频，在8年前我刚入门Android时，音视频就是闷声发大财了（PC端），工资高的令人乍舌，现在在移动端，音视频更是青出于蓝，是一个非常好的选择，如果想要入门可以看看何俊林《Android音视频开发》。 尽量学习半衰期长的知识知识半衰期指的是：随着知识更新周期变短，知识裂变速度加快，一个知识落伍的周期。知识半衰期长的职业都是越老越值钱的，比如英语老师和外科医生，知识更新慢并且几乎不会落伍。这一点我们程序员是绝对比不了的，我们的大部分知识半衰期是比较短的，一个框架短短几年可能就会被淘汰，这也导致程序员需要不断的学习新知识，而我们每个人的时间和精力是有限的，那么根据知识半衰期，有策略的进行学习就变得尤为重要。（这个观点很有吸引力） 上面的半衰期图不完全准确，但是却值得参考，如果你是其他的技术领域也可以参考这个半衰期图。这个图不是告诉我们不要去学RN和小程序，而是结合自身工作尽量学习半衰期长的知识。 做减法，尽量专精一门技术现在的社会，技术分工越来越细，越细就意味着大部分企业（小作坊除外）需要专精的人才（最好是精通一门通多门）。你会发现身边脱颖而出的技术人大多都是靠一门技术，却很少看到会一堆技术却都不精通的冒出来。好比在武侠的世界，高手对决都在同一个时间段拿出看家武学，如果看家武学都不精，分分钟被虐，剩下的武学也无需拿出来献丑了。联想到现实版本就是去大公司面试Android，结果Android技术了解不深，被各种虐，剩下的前端技术、后端技术、Python什么的，面试官也没兴趣了解了。 所以并不是你会的技术越多越好，一定要做好减法，先专精一门，然后再去学别的技术。（值得借鉴） 说说最近Android火热的技术Android相关的火热技术最近几年也是频出，没事就在刷屏，我来说说对这些火热技术的看法。 Kotlin，从知识的半衰期来看，这门语言非常值得学习，不过想要普及还是非常难，因为Kotlin还没有表现出非用它不可的竞争力，另外很多企业使用的成本比较高，大多数领导都是不求有功但求无过，不会下力气推广。 Flutter，从知识的半衰期来看，这个框架存在的时间相对不会长，目前也就一些有技术储备的公司去试验去尝试，如果自己公司技术储备不够，就贸然当小白鼠显然不是很明智。 这两个技术都建议大家来学习，但不要指望它们会给你增加什么太大竞争力，李四1周能学会，张三同样也能。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>规划</tag>
        <tag>半衰期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之CSS入门]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[详解css中的display属性（行内元素和块级元素） 首先，所有主流浏览器都支持display属性。其次，display属性规定了元素应该生成的框的类型。默认值：inline 我们常用的display属性有： inline block inlien-block none 把display设置成none就不会保留元素本该显示的空间（元素直接不显示），但是visibility：hidden会保留。那么其他三个有什么区别呢？看下下面css代码： 1234567891011&lt;body&gt;&lt;span class=&quot;inline&quot;&gt;inline&lt;/span&gt;inline &lt;span class=&quot;block&quot;&gt;block&lt;/span&gt;block &lt;span class=&quot;inline-block&quot;&gt;inline-block&lt;/span&gt; inline-block&lt;/body&gt; 点此看效果 inline特性我们发现内联对象inline给它设置属性height和width是没用的，致使它变宽变大的原因是： 内部元素的宽高‘+padding’。观察inline对象的前后元素我们会发现inline不单独占一行，其他元素会紧跟其后。 block特性 而块对象‘block’是可以设置宽高的，但是它的实际宽高是本身宽高+’padding‘。观察block的前后元素，我们会发现block会独占一行。 如果，我们即希望div有宽高，又不希望它独占一行要怎么办？ inline-block这个时候我们就需要’inline-block‘属性了，我们看下显示效果，就会发现： inline-block即具有block的宽高特性又具有inline的同行元素特性。 也就是说，当我们想让一个元素即不独占一行，又可以设置其宽高属性的时候，我们就可以选择inline-block了。 行内元素特点 和其他元素都在一行上； 元素的高度，宽度，行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素特点 每个块级元素都是从新的一行开始，并且其后的元素也另起一行； 元素的高度，宽度，行高及顶部和底部边距都是可以设置的； 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素一致），除非设定一个宽度。 在html中，span,a,lable,input,img,strong和em就是典型的行内元素。div,p,h1,form,ul,li就是块级元素。 块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 更多CSS display请参考]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>CSS</tag>
        <tag>小程序</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程中的TCP和UDP通信方式简介]]></title>
    <url>%2F2018%2F11%2F03%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code） TCP方式和UDP的区别 TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现 UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现 网络协议简介通过上图知道不管是TCP还是UDP都是互联网络协议中的一层—传输层协议。 图中简单对网络协议做了分层，金典的网络协议是四层，这里给了不同的四层。 最底层的以太网协议规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信，但是以太网协议不能解决多个局域网如何互通，这由IP协议解决（IP协议可以连接多个局域网） IP协议定义了一套自己的地址规则，成为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息（路由器就是基于IP协议，局域网之间靠路由器连接）。 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入很多根网线，路由器内部有一张路由表，规定了A段IP地址走出口一，B段IP地址走出口二。…通过这套指路牌，实现了数据包的转发。 IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要靠TCP协议了。 TCP协议具体的TCP协议可能是一本书的内容，这里管中窥豹一下。简单来说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 原来，我们只是简单知道TCP协议的七次==连接==，三挥四别，这里我们来完整了解下他其中的原理。 TCP数据包大小以太网数据包（pakage）的大小是固定的，最初是1518字节，后来增加到了1522字节。其中，1500字节是负载（payload），22字节是头信息（head）。IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少20字节，所以IP数据包的负载最多1480字节，TCP数据包在IP数据包的负载里面，TCP的头也要占20字节，因此TCP数据包最大负载1460字节。由于，IP和TCP协议往往还有额外的头信心，所以TCP实际负载为1400字节左右，下图会清晰的表明这种关系： 因此，一条1500字节的信息需要两个TCP数据包来承载发送。==HTTP/2协议==的一大改进就是压缩了HTTP协议的头信息，使得一个HTTP请求可以放在一个TCP数据包里面，而不是分成多个，这样就提高了传输速度。 TCP数据包的编号（SEQ）一个包1400字节，那么发送一个10M大小的数据包，需要发送7100多个包，发送的时候，TCP协议会给每个包编号，一边接收方按照顺序还原，万一发生丢包，也可以知道丢失的是哪个包。一般第一个包编号是随机的。假设我们叫第一个包编号为1号包，这个包负载100字节，那么可以推算出下一个包的编号应该是101，就是说，每个数据包都可以得到两个编号：一个自身的编号，及下一个数据包的编号。几首方由此知道，应该按照什么顺序将他们还原成原始文件。（可以用抓包工具抓来看） TCP数据包的组装收到TCP数据包以后，由操作系统来完成组装操作，应用程序是不会直接处理TCP数据包的，而是处理由他封装的例如HTTP协议的数据包。对应用程序来说，不用关心数据通信的细节，应用程序需要的数据放在了TCP数据包里面，有自己的格式（比如常见的HTTP协议），TCP不能标识原始文件大小，这个只能由应用层协议来规定，如HTTP头COntent-length，表示了信息体的大小。对于操作系统来说，就是持续的接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据，一旦组装好TCP数据包，就把他们交给引用程序（怎么组装呢？？），TCP数据包里面有个端口（port）就是用来指定转交给监听该端口的应用程序。 如上图：系统根据TCP数据包中端口，将组装好的数据转交给相应的应用程序。如21端口是FTP服务器，25端口是SMTP（邮件协议）服务，80是Web服务器（常用的Http请求）。这些一般都是在服务端的。 慢启动和ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。==TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。==（NB）。Linux 内核里面设定了（常量==TCP_INIT_CWND==），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 期待要收到下一个数据包的编号。 接收方的接收窗口剩余容量 （图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。） 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 数据包的遗失处理丢包时有发生，TCP的可靠性是怎么保证的呢？简单来说：由于每一数据包都带有编号，如有下一个数据包没收到，那么ACK的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。==这会导致大量重复内容的 ACK==。如果发送方发现收到了==三个==连续重复的ACK，或者超时没收到任何ACK，就会确认丢包了，及5号包丢了，从而再次发送这个包，通过这种机制，TCP保证了不会有数据包丢失。==（好像TCP会丢包的）== 。下图比较形象说明了这个例子： （图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。） TCP连接 Java的TCP实现（Socket）123456789101112131415161718192021public void client() throws Exception &#123; // InetAddress.getLocalHost()为客户端请求连接的主机号，此处设置为本地主机，服务进程的端口号是8090 // 主机号和端口号唯一确定了唯一主机上面的唯一进程。 Socket socket = new Socket(InetAddress.getLocalHost(), 8090); // socket.getOutputStream()获得输出流，通过输出流像主机发送数据。 OutputStream os = socket.getOutputStream(); os.write("黑猫呼叫白猫收到请回复!".getBytes()); // 关闭数据输出，如果不关闭的话服务端并不知道数据传输已经结束还会一直等待。 socket.shutdownOutput(); // 接收server端发送的数据 InputStream is = socket.getInputStream(); int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; is.close(); os.close(); socket.close(); &#125; 123456789101112131415161718192021222324public void server() throws Exception &#123; // 给服务端一个端口号8090使得客户端可以连接。 ServerSocket ss = new ServerSocket(8090); // 接受客户端的连接 Socket socket = ss.accept(); // 获得客户端的输入流 InputStream is = socket.getInputStream(); // 输出client端发送的数据 int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; OutputStream os = socket.getOutputStream(); // 通过输出流向客户端发送数据。 os.write("黑猫这里是白猫，我已收到你的呼叫!".getBytes()); os.close(); // socket.shutdownOutput(); is.close(); socket.close(); ss.close(); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+Github搭建个人Blog]]></title>
    <url>%2F2018%2F10%2F24%2FHEXO%2BGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog%2F</url>
    <content type="text"><![CDATA[HEXO背景hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面 超快部署 支持MarkDown 一键部署 丰富的插件 下面以我的Blog为例，记录搭建过程。 环境准备 安装NodeJs 123456789//mac下安装node很简单，使用mac下的包管理工具brew命令就可以了$ brew install node$ brew install npm//brew一般被安装在/usr/local/bin 目录下面//验证是否安装成功$ node -v 安装HEXO 1$ npm install hexo-cli -g 运行 装上Hexo后就可以在本地跑服务了，执行一下命令（HEXO的常见命令） 1234567$ hexo clean// 生成静态网页$ hexo g / hexo generator// 开启服务$ hexo s / hexo server运行：localhost：4000 托管托管就是将你生成的静态网页保存在服务器上，别人可以通过域名去访问（当然需要在hexo上去配置）. 一般是在github上免费托管，也可以自己去买个小鸡，既可以搭个小机场，也可以托管博客. 如果要部署到github上，首先要有GitHub账号（没有的可以不用看了），然后在仓库建一个”github账号.github.io” 名字一定要一样 添加部署插件hexo-deployer-git 1$ npm install hexo-deployer-git --save 添加git源 1234567// 编辑根目录.config.ymlvim .config.ymldeploy: type: git repo: &lt;repository url&gt; branch: [branch] branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 添加源后就可以部署了 1$ hexo d 配置全局配置关于hexo的配置都在根目录下的.config_yml下面，而关于主题的配置都在/theme/**/.config_yml下面，详细配置可以查看官方文档 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言 theme -&gt; 主题配置（主题名字 /theme目录下） 坑：进行配置时，需要在冒号:后加一个英文空格 主题配置Hexo 中有很多主题，可以在官网查看。主题现在比较流行的是Next — hexo-theme-next。 下载：推荐去官方看最新下载。 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 设置主要是在theme/next/_config.yml文件。然后去找官方或者别人的方案修改即可。 发布文章 使用命令：1$ hexo new test 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 直接将写好的markdown文件放在_posts文件下面即可，在markdown下添加头部 1234---title: categories: []--- 使用命令查看效果 12$ hexo g$ hexo s 主题美化主题美化借鉴了一些前人的集思广益，参考了网上许多文章教程，本博客就是实践出来的，感谢！ 这里mark一些借鉴连接，供大家详参！ Hexo主题美化 干货 Hexo官网]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android存储]]></title>
    <url>%2F2018%2F10%2F22%2FAndroid%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[Android存储路径先来看一张大图： 内部存储 Environment.getDataDirectory().getParentFile();也就是根目录，一般就是指/data/data目录下的数据，需要root之后可以看见 /data/app 该文件存放着系统中安装的第三方应用apk Android的应用安装就是将应用安装包拷贝到/data/app目录下面，每个包本质是一个zip压缩文件。为了提升启动效率，Android会将解压的dex提取出来，缓存在/data/dalvik-cache目录下 api 路径 getDataDirectory() /data getDownloadCacheDirectory() /cache getRootDirectory() /system /data/data 该文件夹存放存储包==私有数据==，对于设备中每一个安装的App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除data/data目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类： 地址 说明 api data/data/包名/cache 存放缓存信息 context.getCacheDir() data/data/包名/database APP数据库信息 context.getDataDir() / context.getDatabasePath(name) data/data/包名/files 存放APP的文件信息 context.getFilesDir() 外部存储每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。 获取外部存储路径及状态 Environment.getExternalStorageState() Environment.getExternalStorageDirectory() 公共目录 Android在外部存储上提供了十个公共目录来存储对应的文件，通过api：Environment.getExternalStoragePublicDirectory(type)来访问 名称 地址 DIRECTORY_MUSIC /storage/emulated/0/Music DIRECTORY_PODCASTS /storage/emulated/0/Podcasts DIRECTORY_RINGTONES /storage/emulated/0/Ringtones DIRECTORY_ALARMS /storage/emulated/0/Alarms DIRECTORY_NOTIFICATIONS /storage/emulated/0/Notifications DIRECTORY_PICTURES /storage/emulated/0/Pictures DIRECTORY_MOVIES /storage/emulated/0/Movies DIRECTORY_DOWNLOADS /storage/emulated/0/Downloads DIRECTORY_DCIM /storage/emulated/0/Dcim DIRECTORY_DOCUMENTS /storage/emulated/0/Documents 3. 私有目录 Android2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。==与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。====和内部存储一样，会在 SD 卡的 Android/data ++目录下生成对应包名的文件夹++== 地址 api /storage/emulated/0/Android/data/应用包名/files context.getExternalFilesDir(type) /storage/emulated/0/Android/data/应用包名/cache context.getExternalCacheDir() /storage/emulated/0/Android/obb/应用包名 context.getObbDir() Android其它目录 /system/app 和 /data/app 的区别 /data/app 里软件权限没全开，/system/app 里的软件获取了所有权限 /data/app 可以应用卸载，/system/app 只能 root 后删除 /data/app 文件夹大小随便，/system/app 文件夹有大小限制 卸载/system/app 目录下的文件并不会增加系统空间，即可用 ROM 空间]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维的误区-幸存者偏见]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%80%9D%E7%BB%B4%E7%9A%84%E8%AF%AF%E5%8C%BA-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81%20%2F</url>
    <content type="text"><![CDATA[何为“幸存者偏见” “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。 &emsp;&emsp;&emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下： 有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？ 不同领域中的“幸存者偏见”西赛罗的那个故事，属于宗教领域的“幸存者偏见”。除了宗教领域，还有很多领域（甚至可以说，所有的领域）都会存在这类偏见。下面，俺挑选几个领域来举例。 IT 领域——创业的“银弹” &emsp;&emsp;&emsp;作为 IT 从业人员，俺经常在某些 IT 网站上看到某某公司的创业事迹。如果你也跟俺一样，估计这方面的故事也看了不少。 &emsp;&emsp;&emsp;不知你有没有发现，那些广为流传的创业案例，都是【成功】案例。越成功的，越具有传奇色彩，被宣传的次数就越多（比如乔布斯、盖茨）。相反，那些创业【失败】的案例，（相比而言）被提及的次数非常非常少。 &emsp;&emsp;&emsp;这会产生啥问题捏？ &emsp;&emsp;&emsp;假设某个有志青年想要创业，他看了很多创业成功的案例，这些案例都提到某些共同的因素。于是捏，此人就误以为这些共同的因素是“银弹”——只要具备这些银弹，创业必定成功。这就如同西赛罗的那个故事——只看到存活的祈祷者，就误以为“祈祷”是存活的【充分条件】。 成功学领域——虚假的“充分条件” &emsp;&emsp;&emsp;说完“创业”，很自然就联想到“成功学”。那些鼓吹“成功学”的文章/书籍，通常存在很多谬误，其中一个谬误是——号称“某某方法论”是成功的【充分条件】。换句话说，只要具备了该方法论，就一定可以获得成功。 &emsp;&emsp;&emsp;为啥俺说这是一个谬误捏？因为这些鼓吹成功学的文章/书籍，通常都【没有】去检验：该方法论是否也出现在失败者身上。只要有一个失败者也采用了该方法论，就足以说明——这个方法论【不是】成功的充分条件。比如说，很多成功学的理论提到了“勤奋”是成功的充分条件。但其实捏，勤奋而没有成功的，大有人在。 投资领域——仅凭运气的“股神” 最近半年，天朝股市迎来新一轮的牛市行情。前几天有读者建议俺聊聊股市的话题，所以今天顺便拿投资领域来说事儿。似乎在每一个国家的股市中，都有那么几个人被誉为“股神”。如果碰到牛市，被冠以“股神”的人还会再多出好几倍。（暂且【不】考虑“弄虚作假、谎报战绩”的情况）假设这些获得股神称号的人，都在实际操作过程中获得远高于大盘的收益率，他们有资格获得“股神”的称号吗？为了说明这个例子，俺转载某篇文章的其中一段（此文写于1984年）。 我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。 “幸存者偏见”导致的问题 错误的认知 这个最好理解了——由于“错误的认知”会导致你对“沉默证据”的忽视，所以你对该领域的认知是不完全的。 错误的归因 在【只看到】“显式样本”的情况下，你可能会产生一些错误的归因。“幸存者偏见”导致的“错误归因”会有很多种。俺这里仅举几个例子。 因果倒置 想必大伙儿都看过举重比赛。对于举重运动员，很多人都有一个错误的观点——以为这些运动员是在练习举重之后，才导致身材变得矮壮。但实际上捏，举重队在一开始筛选运动员的时候，就把那些身材细长的忽略掉了（这些身材细长的候选人，就是“沉默的样本”）。换句话说，是因为他们身材矮壮，才有可能被选中去参加举重培训，而不是因为参加举重培训导致身材如此——这就是【因果倒置】。 牵强的归因（无中生有） 假设某个赌徒去赌场玩“押大小”（此游戏的胜负概率皆为 50%），连续赢了10次。对于大型赌场，每天来玩的人足够多，那么一段时间之后，总会出现某个赌徒玩“押大小”连续赢10次（甚至更多次）。从概率学的角度讲，这是很普通的。但是对该赌徒而言，如果他陷入了“幸存者偏见”这个误区，他就会企图给这个现象找到一个解释（进行“归因”）。假如此人是个宗教信徒，他/她可能会断言——有神明相助。这就属于“牵强的归因”——把【随机事件】看作是有其它原因，并企图在随机性之外寻找一个解释。 错误的决策 还以刚才赌徒的例子来说事儿。假设这个赌徒是宗教信徒，并且误以为自己连续赢10次是神明相助，那么他/她就会获得一种【虚假的信心】，并在这个“虚假信心”的支持下继续玩，甚至还会加大赌注/筹码。最后的结局很可能是——彻底输光。这就是“幸存者偏见”导致的“错误决策”。如果你比较喜欢琢磨，可以把这个赌场的例子替换成天朝的牛市，你会发现其中有某些相通之处。 如何对付“幸存者偏见”？ 意识到“沉默证据”的存在 这是最起码的一点——你首先要能意识到“沉默证据”的存在。这说起来容易，做起来很难——你需要形成这样一种思维习惯：每当看到“显式的证据”，你都要在内心反问：是否存在与之对应的“隐式证据”？ 找到不同类型、不同层次的“沉默证据” 在前一条的基础上，你如果能找到“沉默的证据/隐式的证据”，自然就会获得更全面的认知。有必要提醒一下：“隐式的证据”有时候不止一种类型。碰到这种情况，不是每个人都能想到所有的类型。前面提到的“天朝舆论”的例子。那些思考问题不够深入的同学，通常只意识到“网管审查/删贴”导致的“沉默证据”，而忽略了更隐蔽的“沉默证据”——那些连上网条件都没有的人，是无法在网上表达不满的。 决定一个样本会成为“隐式样本”or“显式样本”，有两种可能：情况A至少有一个原因在起作用（比如前面提到“莎草纸的例子”，气候是原因之一）情况B根本就【没有任何原因】（比如前面提到的“抛硬币的猩猩”），仅仅是随机性决定了某个样本会成为“显式” or “隐式”。对此种情况，如果你非要去找出一个原因，就会出现前面提到的“牵强的归因”。 如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。具体该如何排除捏？在本文的最后，咱们重新回到本文开头提到的那篇巴菲特演讲。在说完“猩猩抛硬币”的游戏之后，巴菲特又说了如下一段话。通过这段话，你可以借鉴一下——如何规避“随机因素”的干扰。 然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；(b)如果经过20天的竞赛，只剩下215只赢家；(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。 于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。 科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。 除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。 在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。 我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>好文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下全局翻墙]]></title>
    <url>%2F2018%2F10%2F20%2FMac%E4%B8%8B%E7%9A%84%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mac下全局翻墙 路由翻墙 ssr + .bash_profile 使用工具，类似profixer，surge等 使用iterm的，环境变量也可以使用.bash的(需要在.zsh中去设置环境变量走.bash_profile)也可以在.zshrc中 由于ss或者ssr只是支持了socks5的代理，也就是所有的都走socks5协议，而浏览器本身是支持socks5的（当然还有http，https，ftp等），但是如果你想mac上装的客户端，比如telegram也能通过ssr达到科学上网就想多了，但是这些软件，还比如AS都可以手动去设置代理的（socks5），一般ssr默认的设置如下： 123ip：127.0.0.1# http走的是1087端口port：1086 方法2设置步骤 vimb(vim .bash_profile) 修改文件（添加下面代码） source .bash_profile 验证：curl www.google.com 12345# proxyproxy=socks5://127.0.0.1:1086export http_proxy=$proxyexport https_proxy=$proxyexport ftp_proxy=$proxy 通过上面设置就能在命令行中发现已经可以科学上网了，目前还有两个蛋痛的地方没解决： profixer在mac上装不了了，一直弹窗。权限都给了 使用Google Drive同步文件用不了，只有将ssr设置全局才可以，MD。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云集成IM]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1IM%E9%9B%86%E6%88%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面 集成集成其实很简单，网易提供了两种方式，jar和gradle，毫无疑问gradle 12345678// 基础功能 (必需)netease_basesdk : &apos;com.netease.nimlib:basesdk:5.1.1&apos;,// 音视频需要netease_avchat : &apos;com.netease.nimlib:avchat:5.1.1&apos;,// 音视频需要netease_nrtc : &apos;com.netease.nimlib:nrtc:5.1.1&apos;,// 全文检索服务需要netease_lucene : &apos;com.netease.nimlib:lucene:5.1.1&apos;, 其中第一个是早就集成了的，自带IM功能，第二第三则是音视频需要的，第四个是需要做聊天记录搜索要用到的 APPID申请 权限 初始化 前两个看官方文档就可以了，初始化一般就是在主APP的Aplication中进行，代码如下 1234567891011// 注册通知消息过滤器registerIMMessageFilter();// 初始化消息提醒NIMClient.toggleNotification(true);// 注册网络通话来电enableAVChat();//初始化IM UI组件NimUIKit.init(this); 官方文档和demo中也有说明，需要使用到哪种能力就去初始化哪些，比如该版本还用到了IM的自定义消息，那么也必须在这里进行注册 注意：以上的初始化只能在主线程中进行，为此，云信提供了一个API：NIMUtil.isMainProcess(this) 123NIMClient.getService(MsgService.class).registerCustomAttachmentParser(new CustomAttachParse()); NimUIKit.registerMsgItemViewHolder(DiagnosisMsg.class, MsgViewHolderDiagnosis.class); IM消息监听 123456// 注册IM消息监听 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, true);// 反注册 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, false); 相关概念 注册登陆：集成网易云后，需要将本地用户与网易云id关联，每一个用户在网易云有一个唯一的accid和token，对于登陆相当于用户名及密码，对于业务比如：视频/IM则相当与电话号码，你需要和别人通信的时候必须知道对方的accid。 用户信息托管：由于本地用户在网易云有一个id关联，那么当要用到网易云的一些能力的时候，我们希望用户的一些基础信息（头像，昵称）是要与本地后端保持一致的。 消息锚点：其实就是一个消息对象，它携带了一些时间或者其他信息，方便搜索。 上面两点都是本地后端处理的，前段需要处理的则是，在登陆系统成功后，需要手动调用网易登陆api去帮助用户登陆到网易云，并且监听用户的登陆状态。 123456789101112131415161718192021222324252627282930313233public void nimLogin(User user) &#123; LoginInfo info = new LoginInfo(user.accid, user.token); // config... RequestCallback&lt;LoginInfo&gt; callback = new RequestCallback&lt;LoginInfo&gt;() &#123; @Override public void onSuccess(LoginInfo param) &#123; Logger.d(&quot;login nim success&quot;); &#125; @Override public void onFailed(int code) &#123; Logger.d(&quot;login nim failed :&quot; + code); &#125; @Override public void onException(Throwable exception) &#123; Logger.e(exception, &quot;login nim failed&quot;); &#125; &#125;; AbortableFuture&lt;LoginInfo&gt; request = NIMClient.getService(AuthService.class).login(info); request.setCallback(callback); &#125; @Override public void observeNimOnlineStatus(User user) &#123; NIMClient.getService(AuthServiceObserver.class).observeOnlineStatus( (Observer&lt;StatusCode&gt;) status -&gt; &#123; Log.i(&quot;nim&quot;, &quot;User status changed to: &quot; + status); if (status.shouldReLogin()) &#123; new Handler().postDelayed(() -&gt; nimLogin(user), 5000); &#125; &#125;, true); &#125; IM相关界面由于lib_neteaseui库提供了界面能力，所以自然自定义界面的话需要集成他的界面，这里有两种方式 集成现有类（比如p2pmessage）,只需要修改layout，并且传递需要的参数即可。 继承SDK中的UI并实现ModuleProxy代理类中方法 开启单聊很简单直接看代码 1IMMessageActivity.start(getContext(), entity.accid, customization, null, IMMessageActivity.class); 其中，entity.accid代表了对方的号码。 消息面板设置 面板类：MessageListPanelEx，这里面封装了发送消息面板的所有功能 抽屉：基类BaseAction，比如拍照，相片或者自定义类型都是通过这个基类来实现的。 IM面板layout：nim_message_activity_text_layout 设置用户托管信息： 12// 设置网易云用户资料（IM中的头像，昵称等）NimUserManager.setUserBasicInfo(user.patientName,user.imgUrl); 消息设置 消息屏蔽： 1234//屏蔽所有消息NIMClient.toggleNotification(false);//屏蔽某个用户消息NIMClinet.getService(FriendService.class).setMessageNotify(account,checkState) 消息接收 12345678910/** * IM消息监听 */ com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt; messageObserver = new com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt;() &#123; @Override public void onEvent(List&lt;IMMessage&gt; imMessages) &#123; Logger.d(&quot;im message received&quot;); &#125; &#125;; 自定义消息 自定义消息比较复杂，参见代码。具体步骤如下： 定义消息 1234567/** * 需要多端统一 */public interface CustomAttachmentType &#123; int diagnosisMsg = 1001;&#125; 自定义消息的基础类 1234567891011121314151617181920public abstract class CustomAttachment implements MsgAttachment &#123; protected int type; CustomAttachment(int type) &#123; this.type = type; &#125; public void fromJson(JsonObject data) &#123; if (data != null) &#123; parseData(data); &#125; &#125; @Override public String toJson(boolean send) &#123; return CustomAttachParse.packData(type, packData()); &#125; public int getType() &#123; return type; &#125; protected abstract void parseData(JsonObject data); protected abstract JsonObject packData();&#125; 自定义消息结构类（用于组装自定义数据） 1public class DiagnosisMsg extends CustomAttachment 自定义消息解析类（用于显示自定义消息） 1public class CustomAttachParse implements MsgAttachmentParser 参见官方文档 其他 注册账号accid网易云强制小写 网易云消息从后端还是本地拉取 1messageListPanel = new MessageListPanelEx(container, rootView, anchor, false, remote); 其中最后一个参数remote = true表示从云端拉取数据 IM聊天点击头像事件layout：MsgAdapter中layout.nim_message_item 点击事件：NimUIKitImpl.setSessionListener]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的常用命令行]]></title>
    <url>%2F2018%2F10%2F19%2FMac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看IP123$curl ip.gs$ifconfig 关于文件操作由于mac下面不能使用右键新建文件，所以需要使用一些工具，如workflow，或者直接命令行 123456789101112# 查看文件如果没有则创建新文件touch filename# 新建文件夹mkdir filename# 删除文件或者目录rm -rf filename# 查看文件详细信息stat filename# 查看目录结果，需要装treenpm install treetree -L 1 vim常规操作 操作命令 效果 i 在光标处插入，进入编辑模式 dd 剪切光标所在的一行内容 yy 复制光标所在的一行内容 D 删除光标右边的所有内容 gg 将光标快速移动到文件首 G 将光标快速移动到文件尾 0 将光标快速移动到行首 $ 将光标快速移动到行尾 退出命令 效果 :w 保存 :q 未保存直接退出（如果没有修改，用下面的命令） :q！ 强制退出 :wq 保存退出 :wq 强制保存退出]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用心得]]></title>
    <url>%2F2018%2F10%2F18%2Fgit%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1. 具体1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用1git reset HEAD &lt;file&gt; 将某个文件从暂存区拿出来。 2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用1git reset -soft/--mix/--hard &lt;commite id&gt; 会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。12# 查询所有git的提交记录，包括详细commite idgit reflog 2. git add语法 语法 描述 git add -A stages All git add . stages new and modified, without deleted git add -u stages modified and deleted, without new 3. git merge合并现在最简单的merge模式就是fast-farward merge了，就是从master拉出的分支develop后，master没有再做任何修改，所有的代码都在develop分支上提交，等到最后要合并develop到master上时，可以使用如下命令： 1234# 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop 4. git tag打标签标签可以针对某一时间点的版本做标记，常用于版本发布。 1.列出标签 1234# 在控制台打印出当前仓库的所有标签git tag# 搜索符合模式的标签git tag -l ‘v0.1.*’ 2.打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。 123456# 创建轻量标签git tag v0.1.2-light# 创建附注标签git tag -a v0.1.2 -m &quot;0.1.2版本&quot;# 针对某个提交打标签git tag v1.0 &lt;commite id&gt; 3.切换标签 1git show v0.1.2 4.删除标签 1234# 删除本地标签git tag -d v0.1.2# 删除远程标签git push origin --delete tag v1.0 5.标签发布 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： 1234# 将v0.1.2标签提交到git服务器git push origin v0.1.2# 将本地所有标签一次性提交到git服务器git push origin –tags 5. git stash该命令用来保存当前分支上还没commite的修改，使当前分支保持clean状态（git status） 使用场景:执行git stash后，你在dev分支没有提交的修改暂时被“藏”了起来，看起来dev分支是干净的。但是，请一定注意，你还在dev分支！因为你需要切换到master分支去修改bug，因此此时需要切换到master分支（如果不执行git stash就切换到master分支是不行的：git会报告当前dev分支还存在未提交的修改，比如先提交才允许你切换分支，而出于各种原因，你还不能现在提交dev分支的内容（一般也就先提交了，大不了再切回来改就是哦），这就是git stash存在的价值）。 切换到stash分支后的恢复命令12345678# 恢复并删除stash内容git stash pop# 查看现场git stash list# 保存现场git stash 6. git分支管理 master:主分支，当前分支上的代码随时可以直接发布，并且只能通过Pull Request从其他分支进行合并，而不能直接push修改。当开发告一段落，产生了新的可供发布的代码时，master分支通过Pull Request更新了代码，同时，每一次更新必须添加对应版本号的标签TAG。 develop:开发分支，保存当前最新开发成果的分支，即当一个新功能开发完毕需要先合并到develop分支，这个分支的代码会进行每日的代码持续集成(Daily Build)。所有的开发任务都是从这个分支Checkout新的特性分支进行开发。 feature:特性分支，当开发新的功能时，从develop分支Checkout新的feature分支，这个分支的代码最终要合并回develop分支或者废弃掉(例如预研功能效果不好时)。feature分支最好以功能为单位。 hotfix:紧急修复分支，唯一从master分支派生的分支，当生产环境中发现了异常或者缺陷的时候，从master分支上指定的TAG版本Checkout hotfix分支进行紧急修复工作，当修复完成之后，必须同时合并到master分支和develop分支。合并完代码之后删除hotfix分支。 新建分支(已feature为例) 12345678# 切换本地分支到develop分支git checkout develop# 拉取远程Git仓库中的最新的develop分支的代码git pull# 创建本地特性分支featuregit checkout -b feature# 推送本地特性分支到远程Git仓库（即创建远程特性分支），-u为追踪远程分支git push -u origin feature 已feature分支为例开发合并全流程 12345# 开发代码。以下两步的作用是保证你本地的feature分支的代码为最新，因为有可能你是和别人合作开发的该功能，如果你刚更新过或者你是一个人在开发则可以省略此操作# 切换到本地feature分支git checkout feature# 拉取远程分支代码，--rebase最好加上git pull --rebase 123456789# 合并代码# 切换到本地develop分支git checkout develop# 拉取最新的远程origin/develop分支代码，因为可能已经有人提交了代码git pull --rebase# 从本地feature-login分支合并代码，--no-ff为禁止fast-farward模式git merge --no-ff feature-login# 推送到远程分支git push 1234567# 代码已经合并完，可以删除本地特性分支和远程特性分支# 删除本地feature-login特性分支git branch -d feature-login# 删除远程origin/feature-login特性分支（废除，实验无效）git branch -r -d origin/feature-login#在v1.7.0 之后，可以使用这种语法删除远程分支(同删除标签tag类似)git push origin --delete &lt;branch name&gt; 7.git pushpush到远程分支有https和ssh两种方式，https每次push都会要求输入用户名和密码，而ssh只要在远端注册了ssh key则不需要。另外，ssh可以上传大文件，https貌似不行。12# 这个会把本地当前分支的内容push到远端的demo分支，如果远端没有该分支则自动创建git push -u origin demo 1234# 生成ssh key,该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：ssh-keygen# 可以查看远程分支情况git remote -v 8.git reset第一小节有类似操作。 本地代码回滚 1234# 回滚到commit-id，讲commit-id之后提交的commit都去除git reset --hard commit-id# 将最近3次的提交回滚git reset --hard HEAD~3 远程代码回滚。应用场景：app已经发布了，发现有问题需要回滚到某个commit，再重新发布。这时需要先将本地分支退回到某个commit，删除远程分支，再重新push本地分支。操作步骤（还没检验） 1234567891011121314# 1git checkout the_branch# 2git pull# 3 备份一下这个分支当前的情况(本地新建分支？)git branch the_branch_backup# 4 把the_branch本地回滚到the_commit_idgit reset --hard the_commit_id# 5 删除远程 the_branch（可以删除远程分支）git push origin :the_branch# 6 用回滚后的本地分支重新建立远程分支git push origin the_branch# 7 如果前面都成功了，删除这个备份分支git push origin :the_branch_backup 9.git remote多源操作，一般是一个源，但是多源也很有用1234567891011121314151617# 如果想关联另一个远端仓库（加一个源）git remote add &lt;origin name&gt; git@gitlab.com:demo/demo.git# 显示全部源git remote / git remote -v# renamegit remote rename &lt;origin name&gt; &lt;origin new name&gt;# deletedgit remote rm &lt;origin name&gt;# 查看指定源的全部信息git remote show &lt;origin name&gt;# 修改远程仓库地址git remote set-url origin &lt;origin url&gt; 10.git commit合并某个分支上的某个commit或者多个commit到master分支上123dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature] 比如，feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做： 123# 示例git checkout mastergit cherry-pick 62ecb3 在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。(未实验，要实验一下) 1234# 首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：git checkout -bnewbranch 62ecb3# 然后，rebase这个新分支的commit到master（--ontomaster）。76cada^ 指明你想从哪个特定的commit开始。git rebase --ontomaster 76cada^ 11.git rebase12345678910111213```### 12.git detached HEAD在一些情况下，会出现detached HEAD的情况，（后面分析下原因）。detached head即游离的HEAD，HEAD指向了未知的分支，即不在所有已知的分支范围内。解决办法：```git$ git branch* (HEAD detached at origin/master) dev master HEAD指向了一个未知的分支，可用git checkout -b基于当前分支创建一个新的临时分支保留代码，合并到合适的分支后删除12345678910111213$ git checkout -b tempSwitched to a new branch &apos;temp&apos;$ git branch dev master* temp$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.$ git merge tempAlready up-to-date.$ git branch -d tempDeleted branch temp (was 3e74a7a).]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
</search>
