<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot初解]]></title>
    <url>%2F2019%2F12%2F25%2FSpring%20Boot%E5%88%9D%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot是什么从本质上来说，Springboot是一个专注于框架的框架。Spring Boot就是对各种框架的整合，让他们集成在一起更加简单。目前ssm框架还是比较常用的，其中ss指的无非就是Spring和SpringMVC，我们可以简单的认为“Spring Boot &gt;= Spring + SpringMVC”。Spring Boot的配置极其简单，可以让你不用或者只需要很少的配置就可以快速运行项目。 Spirng Boot的优缺点优点 快速构建项目 对主流开发框架的无配置集成 spring-boot-starter-web启动器自动依赖其它组件，减少了maven配置 项目可以独立运行，无需外部依赖Servlet容器（自带一个Tomcat） 内嵌离各种servlet容器，Tomcat，Jetty等，现在不用打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行了（java -jar **.jar）,所有的依赖都在一个jar包内。 提供运行时的应用监控 极大提高开发部署效率（还是因为配置简单） 与云计算天然集成 缺点 Spring Boot作为一个微框架，离微服务的实现还是有距离的。没有提供相应的服务发现和注册的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际URI的规范化工作。 快速入门上面提到使用Spring boot可以让你不用或者只需要很少的配置就可以让项目快速运行，说的就是使用代码注解来取代xml配置。其实从Spring3开始就已经提供java配置方式，使用java配置方式可以更好的理解你配置的Bean，如今Spring4更是推荐使用java配置方式，java配置方式可以完全替代xml配置，下面看两个最基本的注解 @Configuration 和 @BeanSpring的Java配置方式时通过@Configuration和@Bean来实现的 @configuration作用与类上，相当于一个xml配置文件 @Bean作用与方法上，相当于xml中的 例子 这是一个简单模拟从数据库取User数据的Dao类（注意代码，它没有使用过任何注解，也就是说UserDao目前没有交给Spring容器管理） 123456789public class UserDao &#123; public List&lt;String&gt; queryUserList() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add("User " + i); &#125; return list; &#125;&#125; 这是一个常见的service，通过注入UserDao，使用UserDao的方法获取用户数据 1234567891011121314@Servicepublic class UserService &#123; @Autowired UserDao userDao; public void getUserList() &#123; List&lt;String&gt; list = userDao.queryUserList(); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 从这里就开始和Spring不一样了，这个类使用了两个新的注解，其中@Configuration表明该类相当于Spring的一个xml配置文件，@Bean将一开始的UserDao配置给Spring管理 1234567@Configuration// 通过注解来表明该类是一个Spring的配置，相当于一个xml文件public class SpringConfig &#123; @Bean// 这里要注意,方法名"getUserDao"将作为UserDao在容器中的id public UserDao getUserDao() &#123; return new UserDao(); &#125;&#125; 接下来就时获取Spring容器，从容器中拿到UserService，并调用其获取用户数据的方法，代码如下： 1234567public class Test &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext acac = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = (UserService) acac.getBean("userService"); userService.getUserList(); &#125;&#125; Spring 第一个Hello world]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环]]></title>
    <url>%2F2019%2F12%2F16%2FJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。 事件循环首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？ 关于执行中的线程： 主线程：也就是js引擎执行的线程，这个线程只有一个，页面渲染，函数处理都在这个主线程上执行。 工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取，网络请求灯异步事件。 如图： 从上图我们可以看出，js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行，在执行代码过程中，如果遇到一些异步代码（比如setTimeout，ajax，promise.then以及用户点击等操作），那么浏览器就会将这些代码放到另一个线程（工作线程）中执行，在前端由浏览器底层执行，在node端由libuv执行，这个线程的执行不阻塞主线程的执行，主线程执行栈中剩余的代码。 当工作线程里的代码执行完成后（比如setTimeout时间都了，ajax请求的到了响应），该线程就会将它的回调函数放在任务队列中（又称为事件队列，消息队列）中等待执行，而当主线程执行完栈中的所有代码后，它会检查任务队列是否有任务要执行，如果有任务要执行的话，那么久将该任务放到执行任务栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。跟大部分框架的消息队列其实本质原理都是一样的。下面我们来具体分析这套机制的运行过程。 任务队列那么，问题来了。如果任务队列中，有很多个任务的话，那么要先执行哪个任务呢？js是有两个任务队列的，一个叫做Macrotask Queue（Task Queue）大任务，一个叫Microtask Queue小任务。 Macrotask常见的任务： setTimeout setInterval setImmediate I/O 用户交互操作，UI渲染 Micraotask常见任务： Promise process.nextTick(nodejs) Object.observe（不推荐使用) 重点来了事件循环执行流程如下：主线程在执行主流程 检查Macrotask队列是否为空，若不为空，则进行下一步，若为空，则跳到第3步； 从Macrotask队列中取队首（在队列时间最长）的任务进去执行栈中执行，执行完后进入下一步； 检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到第一步（开始新的事件循环）； 从Microtask队列中取队首（在队列中时间最长）的任务进去事件队列执行，执行完后，跳到第3步中，在执行过程中新增的microtask任务会在当前事件循环周期内执行，而新增的macrotask任务只能等到下一个事件循环才能执行。 来看一段代码 1234567891011121314151617181920212223242526272829303132333435console.log(1)setTimeout(function() &#123; //settimeout1 console.log(2)&#125;, 0);const intervalId = setInterval(function() &#123; //setinterval1 console.log(3)&#125;, 0)setTimeout(function() &#123; //settimeout2 console.log(10) new Promise(function(resolve) &#123; //promise1 console.log(11) resolve() &#125;) .then(function() &#123; console.log(12) &#125;) .then(function() &#123; console.log(13) clearInterval(intervalId) &#125;)&#125;, 0);//promise2Promise.resolve() .then(function() &#123; console.log(7) &#125;) .then(function() &#123; console.log(8) &#125;)console.log(9) 运行结果 1,9,7,8,2,3,10,11,12,13 运行结果分析 第一次事件循环： console.log(1)被执行，输出1 settimeout1执行，加入macrotask队列 setinterval2执行，加入macrotask队列 settimeout2执行，加入macrotask队列 promise2执行，它的两个then函数加入microtask队列 console.log(9)执行，输出9 根据事件循环定义，接下来会执行新增的microtask任务，（上面标记的：在执行过程中新增的microtask任务会在当前事件循环周期内执行），按照进入队列的顺序，执行console.log(7)和console.log(8),输出7和8，microtask队列为空，回到第1步，进入下一个事件循环，此时macrotask队列为：settimeout1，setinterval1,settimeout2。 第二次事件循环： 从macrotask队列里面取出队首元素：settimeout1并执行，输出2，microtask队列为空，回到第1步，进行下一个事件循环，此时macrotask队列为：setinterval1，settimeout2。 第三次事件循环： 从macrotask队列里取位于队首元素：setiverval1并执行，输出3，然后又将新生成的setinterval1（间隔生产）加入macrotask队列，mincrotask队列为空，回道第1步，进入下一个事件循环，此时macrotask队列为：settimeout2，setinterval1。 第四次事件循环 从macrotask对列中取出队首元素：settimeout2并执行，输出10，并且执行new promise内的函数（new promise内的函数式同步操作，并不是异步操作），输出11，并且将它的两个then函数加入到microtask队列中，再从microtask队列中（当前事件循环周期内执行）取队首的任务执行，直到队列为空。因此，两个新增的microtask任务按照顺序执行，输出12和13，并且将setinterval1清空（不会再产生setiterval1的事件）。 结束 此时，mac和mic队列都为空，浏览器会一直检查队列是否为空，等待新的任务加入队列。在第一次循环中，为什么不是macrotask先执行呢？因为按照流程的话，不是应该先检查macrotask队列是否为空，再检查microtask队列吗。 原因：因为一开始js主线程中跑的任务就是macrotask任务，而根据事件循环流程，一次事件循环只会执行一个macrotask任务，因此，执行完主线程的代码后，它就去从microtask队列中取首任务来执行了。 注意：由于在执行microtask任务的时候，只有当microtask队列为空的时候，它才会进入下一个事件循环，因此，如果它源源不断地产生新的microtask任务，就会导致主线程一直在执行microtask任务，而没有办法执行macrotask任务，这样我们就无法进行UI渲染/IO操作/ajax请求了，因此，我们应该避免这种情况发生，在nodejs中process.necttick就可以设置最大的调用次数，以此来防止阻塞主线程。 定时器问题由上，我们来引入一个新的问题，定时器的问题。定时器是否真实可靠呢？比如我执行一个命令：settimeout（task,100）,他是否就能准确的在100ms后执行呢，如果知道上面运行机制就知道答案是否定的。 看个例子：12345678910111213const s = new Date().getSeconds();setTimeout(function() &#123; // 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行 console.log("Ran after " + (new Date().getSeconds() - s) + " seconds");&#125;, 500);while(true) &#123; if(new Date().getSeconds() - s &gt;= 2) &#123; console.log("Good, looped for 2 seconds"); break; &#125;&#125; 主线程跑了2s后才结束while循环，这才去执行macrotask中的settimeout回调任务。其实，你执行setTimeout（task,100）后只是确保这个任务会在100ms进入macrotask队列，但并不意味着他能立刻运行，可能当前主线程正在进行一个耗时的操作，也可能目前microtask队列有很多个任务，所以用setTimeout作为倒计时其实不会保证准确。 阻塞和非阻塞关于 js 阻塞还是非阻塞的问题，我觉得可以这么理解，不够在这之前，我们先理解下同步、异步、阻塞还是非阻塞的解释，在网上看到一段描述的非常好，引用下： 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。（轮询）异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗最蠢）异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 理解 Node.js 事件循环]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（三）]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[行程（2019-06-03）京都行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下： 这里竖着的带有颜色的竖条代表了各种线路（普通/快速/特快），横着的表示这条线路会停靠的站名。我们坐地铁从九盯木到淡路，然后坐阪急线到乌丸。这里还是要感叹一下，日本的地铁很准时，所以你要上对车，GoogleMap也是利器，标明了每一趟车的到站时间，分秒不差。经过大概1个多小时的车程终于到Kyoto了。 京都给人的感觉更像是大城市，大阪是一种生活的城市。 清水寺来了京都，checkin酒店后，就抓紧时间去附近景点了，防止后面没有时间，选定了不远的清水寺，出发！日本的公交车很贴心（对残障人士），靠站后，整个上车一侧的车身会倾斜下来靠近地面，大家跟容易上车（老年人），而且日本的公交车是前门下车，后门上车的（我觉得很合理）。 游客众多，天气也比较热，但是新鲜感让一切都变得那么美好 正门，其实日本的各种神社，就是类似中国的寺庙 从清水寺回程，我们选择了步行，这个选择我觉得非常正确，可以沿路看到普通的日本人的生活方式和街道等，套用一朋友的话，走在日本的街道上就像是小时候看的日本漫画一样。感觉，整齐，有序。 未完待续。。。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（二）]]></title>
    <url>%2F2019%2F07%2F04%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[行程（2019-06-02）高津宫住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。 貌似日本人结婚也会来这里祈福或者直接就在这里举行仪式 一个老大的墓碑 日式微缩版的小桥流水人家 典型的日本神社⛩️，门很有特色，然后也有神兽，不知道是狐狸还是狗 神兽 初来乍到，感觉什么都很新鲜，一路上用手机记录下沿途的风景，拍的有点多，后来去了京东清水寺，伏见稻荷神社发现高津宫就是小case，不过这个神社是日本人自己会来的（看见很多日本人来这里祭拜，投币拍手👏然后双手合十祈福），而那些都是游客去的，各有特色吧。 黑门市场来大阪怎么可能不吃小吃，吃小吃怎么可能不来黑门市场（小吃一条街），我们大概吃了5，6种小吃，由于是吃货，吃完才发现没有拍照。评分很高的章鱼小丸子我倒是不感冒，不过和牛倒是值得一试，特别是网上查的这家店（黑门市场几乎也都是中国人，大众点评很流行） 黑门市场 和牛（贵呀） 来一片，就是这家店的牛肉还有食客证。拍照 大丸百货吃完就是shopping了，来到了心斋桥附近的大丸百货，途径道顿掘 天公不作美，下雨了。 道顿掘怎么可能少得了这个标志呢，哈哈，感觉他跑很久了 好了，购物的就不看了，附一张老婆要的阿尔滨吧，后面的每天在补blog。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本游记（一）]]></title>
    <url>%2F2019%2F06%2F27%2F%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。 行程（2019-06-01）此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。 出发我们是从香港出发的，为了赶上12点多的飞机，早上起了个大早去深圳湾过关 坐了个商务车直达香港机场 接着就是托运行李等飞机啦。。。。。省略一万字，怀着不那么激动的心情终于降落到了关西机场 接着就是入境啦 入境就是填个单证明你来这里是要回去的，要有在日本酒店地址/电话，还要提供返程机票等，入境后有个小插曲，我有两个行李箱，然后出去后发现只有一个了，小的行李箱被我丢在里面了，然后只能用蹩脚的英语跟边境人员解释，最终还是顺利拿回来了。我们在大阪住的是在airbnb上订的名宿，在大阪市区，离周围的什么黑门市场，心斋桥，道顿掘都比较近。 大阪出了机场就是地铁了站（火车站），日本的地铁火车系统很发达，刚去的话坐车肯定是一脸懵逼，因为他们那边地铁站和火车站是一起的，各种运营线路，各种坐车套餐（我到现在还有些不清楚）。下面是关西机场的JR和南海电铁 我们去住的地方在难波附近，离的最近的地铁站叫九丁目，顺便说一句，国外Google Map是真好用，特别是日本的地铁火车很准时而且每趟车停的站是不一样的，它有普通，快速，特快之类的，上错车的概率是很大的，所以基本靠问和Google Map，google map完全就是神器。我们坐了南海电铁大概一个半小时到了地铁站 一出站就两个小姐姐现场表演，驻足看了下很Hi，但是太累了，而且也要尽快找到住的地方，所以没有多留，直接Google Map导航去民宿。 终于找到了 住的地方（好小啊，不过，五脏俱全） 晚上9点到民宿，还没吃饭，就下去附近逛逛觅食，诶，找到一家 图太多了，后面再讲吧！]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熵]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%86%B5%2F</url>
    <content type="text"><![CDATA[什么是熵为了理解熵，必须讲一点物理学。 19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。 后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。 能量的状态熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？ 物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。 上图中，能量转化会新生成大量的状态，那么状态多意味着什么呢？ 熵的另外一种解释状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：能量转换会让系统的混乱度增加，熵就是系统的混乱度。 熵的英文名为Entropy，我觉得这个翻译的人（胡刚复教授于1923年根据热温商之意首次把entropie译为“熵”）确实很牛逼，翻译的名字很好听。熵低则混乱度低，熵高则混乱度高。 转换的能量越大，创造出来的新状态就会越多，因此高能量系统不如低能量系统稳定，因为前者的熵较大。而且，凡是运动的系统都会有能量转换，热力学第二定律就是在说，所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。 举个例子： 冰块是分子的有序排列，能量释放后，变成液体水，分子排列变得无序。那么冰这个系统里的熵就比较低，而水这个系统的熵比较高。 熵：一种新的世界观熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。为什么”世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。 这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。 工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。 我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。我们需要能量，让世界变得有秩序，但这样是有代价的。物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。 感想人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。（能量守恒定律告诉我们地球的能量肯定是固定的，那么当人类能利用完地球上所有的能量（不一定能利用完），而假设没有外部能量输入，则这个时候的熵如果大到一定程度是不是就是人类悲剧的开始，比如核弹，病毒等。另外一种可能，为了一部分地区的有序和稳定，牺牲了另外一部分地区的有序和生态，而目前好像就是如此，人类破坏了其它生物的家园而将自己的家园建设的越来越好）。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>热力学第二定律</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin之集合操作符]]></title>
    <url>%2F2019%2F03%2F28%2FKotlin%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。 成员引用Kotlin中允许你去将表达式当作参数传递，你也可以直接传递函数，跟Java8一样，如果你把函数转化为一个值的话，可以用成员引用 val getAge = Person::age 这个表达式叫做 成员引用 。它为创建一个直接调用方法或访问属性的函数值提供了一种简短的语法。双冒号将类名从你需要引用的成员（方法或属性）名中分隔出来。它所做的事情跟下面其实是一样的，但是更简洁（少了一个中间变量）： val getAge = { person: Person -&gt; person.age } 这个成员引用是lambda中的知识点，还有很多用法，需要去理解。 maxBy找出这个集合中根据某个字段排序最大的值，可以仔细观察下面代码，它们的结果和意思完全一样。 123456789101112/** * list操作符之maxby */fun listOperatorMaxBy()&#123;//当lambda表达式是最后一个参数的时候可以不要（），直接用&#123;&#125; val people = listOf(Person2("Bob",24), Person2("Alice",42)) println(people.maxBy &#123; it.age &#125;) println(people.maxBy &#123; person2 -&gt; person2.age &#125;) people.maxBy(Person2::age)&#125; transform/joinString12345678910111213/** * list操作符之transform/joinToString */fun listOperatorTransform()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42)) val names = people.joinToString(separator = "，",postfix = ": ",transform = &#123;p: Person2 -&gt; p.name&#125;) val names1 = people.joinToString("","","",1) &#123; p -&gt; p.name &#125; println(names) //Bob，Alice: println(names1) //Bob&#125; filter根据条件过滤操作123456789101112131415161718/** * list操作符之filter */fun listOperatorFilter()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) //但是要注意，这份代码为每个人重复了最大年龄的查找步骤。所以，如果集合中有100个人，最大年龄的搜索将会执行100次！ people.filter &#123; it.age == people.maxBy(Person2::age)!!.age &#125; //people.filter &#123; it.age == people.maxBy&#123;person2 -&gt; person2.age&#125;!!.age &#125; //只计算了一次最大值 var maxAge = people.maxBy(Person2::age)?.age people.filter &#123; it.age == maxAge &#125;&#125; all，any，count，find等1234567891011121314151617181920212223242526/*** * list操作符all，any * list是否包含了所有这个条件 */fun listOperatorAllAny()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) val conditions = &#123;p: Person2 -&gt; p.age &gt; 25&#125; //全部匹配条件 people.all(conditions) // false people.all &#123; p:Person2 -&gt; p.age &gt; 23 &#125; // true //有一个匹配条件的 people.any(conditions) // true //有多少个符合条件的 people.count(conditions) // 2 // 查找哪个是符合条件的(如果有多个元素，函数将返回第一个匹配的元素。 // 如果没有满足的元素，函数返回 null 。 find 的一个同义词是 firstOrNull 。 // 如果如能够更加清晰的表达你对想法，你可以使用) people.find &#123; p:Person2 -&gt; p.age &gt; 23 &#125; //Alice,Ervin people.firstOrNull(conditions)&#125; groupBy分组操作符，想象一下，你需要根据你某些特性来将所有元素分割成不同的组。例如，你想把年龄相同的人放在一组。把这个特性直接作为一个参数进行传递非常方便！ 12345678910111213141516/** * list操作符groupBy */fun listOperatorGroupBy()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42), Person2("Ervin",34), Person2("Anny",34)) people.groupBy &#123; it.age &#125; //每一组都被保存成一个列表。所以结果的类型为 Map&lt;Int, List&lt;Person&gt;&gt; 。 // 你可以使用像 mapKeys 和 mapValues 这样的函数对这个映射做更多的修改。 print(people.groupBy &#123; it.age &#125;[34])&#125; groupBy之后返回结果是一个Map集合，最后print(people.groupBy { it.age }[34])中[34]其实是输出以34为key的Person。 map和flatMap这两个操作符在RxJava中是使用频率很高的操作符，map是对一个基本类型做一个转换，例如string -&gt; int，而flagMap则是将上游的observerable变为另外一个observerable。Kotlin中，map其实也是类型转换的意思，flatmap则是将集合中每个元素映射（map），然后把多个列表合并成一个。最终，其实它是一个集合 flatMap 函数做了两件事：首先它根据作为参数而给定的函数把每一个元素都变换（或映射）到一个集合中。然后它把多个列表合并为一个。有一个处理字符串的案例很好的解析了这个概念 123456789101112/** * list操作符flatMap */fun listOperatorMap()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) print(people.map &#123; it.name + "'s" &#125;) //[Bob's, Alice's, Ervin's] print(people.flatMap &#123; it.name.toList() &#125;) //[B, o, b, A, l, i, c, e, E, r, v, i, n]&#125; sequence 集合的序列操作，这个是很有用的东西。一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择，举个例子： NOTE 注意 一般来说，无论何时，你在大型集合中有链式操作时，请使用序列。在8.2一节，我们将会讨论为什么在Kotlin中，常规集合的延迟操作是高效的，尽管它会创建中间的集合。但是如果集合包含大量的元素，中间的元素重拍耗时巨大，所以延迟计算更 加可取。 1234567891011121314151617181920212223242526/** * list的序列操作 * * 一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择 */fun listOperatorSequence()&#123; val people = listOf(Person2("Bob",24), Person2("Alice",42),Person2("Ervin",34)) //集合的链式调用 /** * Kotlin标准库参考（文档）指出， filter 和 map 都返回一个列表。这意味着这个链式调用将会创建两个列表：一个保存 filter 函数的结果，另一个存储 map 函数的结果。 * 当原来的列表只有包含两个元素时，这不会有问题。但是如果你有百万个元素时，这会变得非常低效。 为了把它变得更加高效，你可以转换这个操作。 */ people.map(Person2::name).filter &#123; it.contains('A') &#125; //序列的操作 /** * 没有保存元素的中间集合，对于元素比较大的集合来说，性能会有客观的改善 */ people.asSequence() //初始集合转化为序列 .map(Person2::name) .filter &#123; it.contains('A') &#125; .toList() //序列转化为集合&#125; 集合本身的操作是实时的，而序列的操作是懒加载式的，下面会详细说明序列的中间操作和最终操作 序列的中间和最终操作 看一个例子 123456789101112131415161718192021/** * list的序列操作之不同点 */fun listOperatorSequence1()&#123; //sequence的操作 //map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; print( "map($it) " ); it * it &#125; .filter &#123; print( "filter($it) " ); it % 2 == 0 &#125; .toList()//最终操作 //集合本身操作 //map(1) map(2) map(3) map(4) filter(1) filter(4) filter(9) filter(16) listOf( 1 , 2 , 3 , 4 ) .map &#123; print( "map($it) " ); it * it &#125; .filter &#123; print( "filter($it) " ); it % 2 == 0 &#125;&#125; 注意看sequence结果：map和filter是交替进行的，每个元素都是先map再filter，这证明了sequence是延迟计算的。而集合本身则是所有元素先map（中间集合），再用中间集合去filter。sequence中没有最后的toList（最终操作），则什么都不会输出。 最终操作导致所有的延迟计算都被执行了。 还有一个更重要的事要注意，在这个例子中，计算的执行顺序。原始的方法首先将会对每个元素调用 map 函数，然后对结果序列中的每个元素调用 filter 函数。这就是 map 和 filter 在集合上如何工作的。但序列并不是这样的。对于序列来说，所有的操作都会逐个应用于每个元素：处理完第一个元素（映射，然后过滤），然后处理第二个，以此类推。 这个方法意味着如果过早获取结果，某些元素根本不会被变换。我们来看一个有 map 和 find 操作的例子。首先，你把一个数映射为它的平方，之后你查找当中第一个大于３的元素（find操作符的作用）： 1234567fun listOperatorSequence2()&#123; print(listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; it * it &#125; .find &#123; it &gt; 3 &#125;)&#125; 如果同样的操作应用于一个集合而不是序列，那么首先会计算 map 的结果，变换初始集合中所有的元素。第二步，在中间集合中发现一个满足预言的元素。使用序列，惰性方法意味着你可以提阿偶偶处理某些元素。下图解释了（使用集合）提前和延迟（使用序列）方式执行这份代码的不同点。 集合提前计算对整个集合运行每一个操作，惰性求值则逐个计算（元素多的时候效率高，性能好） 再看一个例子啊： 123456789101112131415161718192021222324252627fun listOperatorSequence2()&#123; println(listOf( 1 , 2 , 3 , 4 ) .asSequence() .map &#123; it * it &#125; .find &#123; it &gt; 3 &#125;) val people = listOf(Person2("Bob",24), Person2("Alice",42), Person2("Ervin",34), Person2("Dan",34) ) /** * 先filter有助于减少变换的总次数， * 如果先进行 map ，每个元素都会进行变换。 * 但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。 */ //先map再过滤 println(people.asSequence().map(Person2::name).filter&#123; it.length &lt; 4&#125;.toList()) //println(people.asSequence().map&#123; person: Person2 -&gt; person.name&#125;.filter &#123; it.length &lt; 4 &#125;.toList()) //先过滤再映射 println(people.asSequence().filter&#123;it.name.length &lt; 4&#125;.map(Person2::name).toList())&#125; 先filter有助于减少变换的总次数。如果先进行 map ，每个元素都会进行变换。但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。 流 vs 序列 如果你熟悉Java 8的流，你将会看到，（Kotlin的）序列是完全一样的概念。由于Java 8的流在使用旧版本的Java搭建的平台中无法使用，比如Android，所以Kotlin提供了它自己的轮子。如果你把Java 8作为目标平台，流会给你带来一个很大的好处。但是，Kotlin的集合与序列并未实现在多个CPU上并行执行流操作（ map() 或者 filter() ）的能力。你可以基于你面向的Java版本和你的具体要求来选择流和序列。 实例代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Https证书详解]]></title>
    <url>%2F2019%2F03%2F21%2FAndroid%20Https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。 TLSTLS是基于 X.509 认证，他假定所有的数字证书都是由一个层次化的数字证书认证机构发出，即 CA。另外值得一提的是 TLS 是独立于 HTTP 的，任何应用层的协议都可以基于 TLS 建立安全的传输通道，如 SSH 协议。 CAHttps通信过程中需要交换服务器的公钥，但是怎么确保公钥就是服务器的公钥呢，就需要引入了一个第三方，也就是上面所说的 CA(Certificate Authority)。CA 用自己的私钥签发数字证书，数字证书中包含A的公钥。然后 B 可以用 CA 的根证书中的公钥来解密 CA 签发的证书，从而拿到合法的公钥。那么又引入了一个问题，如何保证 CA 的公钥是合法的呢。答案就是现代主流的浏览器会内置 CA 的证书。我们可以在浏览器中看到Https网站的证书信息： 中间证书当然，现在大多数CA不直接签署服务器证书，而是签署中间CA，然后用中间CA来签署服务器证书。这样根证书可以离线存储来确保安全，即使中间证书出了问题，可以用根证书重新签署中间证书。上图中第三级就是中间证书了。 Android配置HttpsAndroid 使用的是 Java 的 API。那么 Https 使用的 Socket 必然都是通过SSLSocketFactory 创建的 SSLSocket，当然自己实现了 TLS 协议除外。目前Android使用的网络通信基本都是Okhttp了，OK默认就支持Https，当你不配置的时候，它默认是支持在Android内部默认安装的100多个证书，在Android设置中可以看到这些内置根证书（会自动更新）。 如果你的后端证书是购买的那么基本就是这些内置根证书中的一种了，你可以不需要任何改动，直接就可以从Http过渡到Https（直接修改BaseURL），但是如果后端使用的是自制证书，那么你就必须要配置了（如果不配置会报证书锚点找不到的错误）。 SSLSocketFactory 创建SSL的工厂类，默认是这样实现的： 123456789 private synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, null, null); return defaultSslSocketFactory = sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); // The system has no TLS. Just give up. &#125;&#125; TrustManager 上文说了，SSL 握手开始后，会校验服务器的证书，那么其实就是通过 X509ExtendedTrustManager 做校验的，更一般性的说是 X509TrustManager : 1234567891011121314/** * The trust manager for X509 certificates to be used to perform authentication * for secure sockets. */public interface X509TrustManager extends TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException; public X509Certificate[] getAcceptedIssuers();&#125; 那么最后校验服务器证书的过程会落到 checkServerTrusted 这个函数，如果校验没通过会抛出 CertificateException 。很多博客说，配置 SSL 差不多是这样的: 12345678910111213141516171819202122private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, new TrustManager[]&#123; new X509TrustManager() &#123; public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; &#125;, null); return sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); &#125;&#125; 这个是信任所有证书的，包括自制证书，相当于客户端不会去检查证书的签名。这么做毫无安全性可言，一般不要这么做 SSL的配置Android中SSL的配置，可以不配置（系统会默认信任Android内置证书），但是如果用系统默认的 SSL，那么就是假设一切 CA 都是可信的。可往往 CA 有时候也不可信，比如某家 CA 被黑客入侵什么的事屡见不鲜。虽然 Android 系统自身可以更新信任的 CA 列表，以防止一些 CA 的失效。那么为了更高的安全性，我们希望指定信任的锚点（我们信任的证书），可以类似采用如下的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by Ervin on 2017/3/14. */public class CertificationFactory &#123; public static SSLContext getSLLContext(Context context)&#123; SSLContext sslContext = null; try &#123; //取得本地证书的流 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); InputStream cerInputStream = context.getAssets().open(&quot;root.crt&quot;); Certificate ca = cf.generateCertificate(cerInputStream); //创建Keystore包含我们的证书 String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // 创建一个 TrustManager 仅把 Keystore 中的证书 作为信任的锚点 String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); TrustManager[] trustManagers = tmf.getTrustManagers(); // 用 TrustManager 初始化一个 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, trustManagers, null); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sslContext; &#125;&#125; 在Okhttp中开启配置： 1234567891011httpClient = new OkHttpClient .Builder() .addInterceptor(new TokenValidInterceptor(this.context)) .addInterceptor(new HttpRespV3ConvertInterceptor()) .addInterceptor(loggingInterceptor) //开启SSL配置 .sslSocketFactory(CertificationFactory.getSLLContext(this.context).getSocketFactory()) .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .build(); 这样的话Okhttp会只信任“root.crt”以及被它签发的证书才会被信任。这里有个地方要注意：这里的root.crt在我的项目中代表了CA的根证书（第一级的证书，也许也是中间证书，过期时间比较久），还有一种证书是用这个root去签发的，在你购买证书后会给你去服务器配置的。因为在实际情况中，一般购买的证书（子证书）有效期都是2年左右，如果客户端信任这个子证书那么也就是2年后证书过期，你的APP就不能用了，因此我们考虑了使用根证书，（根证书默认会信任他以及他所签发的证书），这样子证书到期后，只要还用这家CA的证书签发一个子证书，APP还是会继续信任。这样比起信任100多个根证书，我只信任一个要安全得多。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QUANTUMULT的配置]]></title>
    <url>%2F2019%2F03%2F18%2FQuantumult%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。 老板由于已知的原因，时隔半年回归。寄语：“Whatever does not kill us makes us stronger.” - Friedrich Nietzsche 这里Quantumul讲的很详细，这里就不多啰嗦了，后续还会更新最新的FQ技术及方法。 Mac：shadowsocksR-NG-R，ClashXIOS：quantumul,shadowrockets,surgeAndroid: SSR,ClashNG,… 配置教程]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的简单配置]]></title>
    <url>%2F2019%2F03%2F14%2Falfred%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景Alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧 获取从官网就可能下载使用Alfred了，但是想用他的完整功能，比如workflow就要激活powerpack了，在天朝这些都不是问题，推荐几个Mac软件搬运工网站： 大名鼎鼎的xclinet 域名很黄的waitsun 未来软件园 等等吧，收藏夹里一堆。 基础功能介绍首先是启动alfred了，一般为避免和spotlight快捷键冲突，会将alfred启动快捷键设置为：double cmd。这样也确实挺方便的 搜索这个是最简单最基础的功能了，alfred自带了一些查询，例如： 只要输入关键字，就可以打开浏览器Google一下你要的内容了，alfred会自动匹配所有和关键字相关的内容（10个）给你选择。你也可以自己设置自定义的搜索规则： Clipboard剪切板功能也是一个很赞的功能，我的使用频率也是最高的之一，一般快捷键设置为：cmd+option+C。会弹出最近你所复制的文本，图片，甚至文件。如果一段文字你需要多次用到，那么这个将会大大提高你的效率。 System这个功能主要是你可以使用alfred的感觉真关机，待机，锁定屏幕等等。 Terminal/shell这个是由于我在Mac上使用的是程序员专用的iTerm命令行工具，然后Alfred可以通过“&gt;”来开启命令行（很好的功能），但是它默认使用的是mac系统自带的terminal，如果你想开启iTerm，那么： Preference - Terminal/shell - Application:custom 1234567891011121314151617181920212223242526272829303132333435363738394041424344//适用于iTerm2on alfred_script(q) if application &quot;iTerm2&quot; is running or application &quot;iTerm&quot; is running then run script &quot; on run &#123;q&#125; tell application \&quot;:Applications:iTerm.app\&quot; activate try select first window set onlywindow to false on error create window with default profile select first window set onlywindow to true end try tell current session of the first window if onlywindow is false then tell split vertically with default profile write text q end tell end if end tell end tell end run &quot; with parameters &#123;q&#125; else run script &quot; on run &#123;q&#125; tell application \&quot;:Applications:iTerm.app\&quot; activate try select first window on error create window with default profile select first window end try tell the first window tell current session to write text q end tell end tell end run &quot; with parameters &#123;q&#125; end ifend alfred_script WorkFlow这个是收费功能，也是alfred可以拥有无限可能的功能，他类似于IOS中的捷径（其实原来也叫workflow，被Apple收编后叫捷径） 下面简单介绍几个有用的workflow： New Filemac上新建文件是个比较蛋痛的事，一般人还新建不来。如果有这个就好办了。该插件默认启动关键字是：new。默认情况下，你可以直接新建 TXT、MD、自定义文件类型这三种类型的文件和目录。其中 TXT、MD 格式也是比较常用的文本格式，插件就将这两种类型的文件直接作为了默认文件类型。真是非常贴心！ TerminalFinder看名字就知道是Finder和Terminal互相切换的，有时候我们在Finder中想开启命令行，还有时候在命令行中打开了一个目录又想在Finder中显示。用这个吧。 有道词典系统自带的词典，查找起来不太方便，alfred的workflow中使用yd关键字就能英汉互查 好用的workflow其实有很多，需要大家去发掘去使用，但是另一方面我们其实也用不到那么多功能，所以还是适合自己的才是最好的。 搜索插件workflow插件是傻瓜式的，直接下载.workflow文件下来后，点击就能安装了。下面给几个下载workflow的网站： Packal alfredflow 还有就是Google了。。。。。 配置最后，如果你有多台mac之间都在用alfred，你想使用一个配置文件，那么你就要使用同步功能了。坑爹的是，aflred默认是不同步的（连iCloud都不支持），它只是把配置文件保存在本地，那么怎么才能同步呢，上图： 说白了也就是自己把配置文件上传到云端，多端同步。 最后，其实这个blog只是我使用的一个简单介绍或者记录，alfred还有很多高级功能没有去涉及，还是希望能帮助到别人吧。生命在于折腾！]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常规配置]]></title>
    <url>%2F2019%2F02%2F28%2Fgit%E7%9A%84%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Markgit的全局和单个仓库的用户名和邮箱的配置 全局 1234git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot;//查询git config --list 某个仓库 12git config user.name &quot;name&quot;git config user.email &quot;email&quot; 未完待续，持续更新。。。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android后期开发的几个方向]]></title>
    <url>%2F2019%2F02%2F25%2FAndroid%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[背景从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。 移动端未来的几个方向动态化目前我们项目已经在尝试走组件化和插件化，前两年，插件化火起来了，为什么火呢，因为可以实现Android不用发布版本就可以热更新，但是插件化有自己的问题，就是兼容性。Android机型太多（马上要出折叠屏了），插件化框架难免要涉及到系统API的hook，兼容性问题就出现了，开发者会莫名其妙碰到各种错误，随着Android版本迭代，插件化这条路越来越不好走，Android P给了开发者一个信号，不能再随便hook系统API了，Google要开始整顿了。然后，另外一个动态化就是Hybrid开发了，利用H5和原生混合开发（目前最为流行的开发方式），例如老牌的Cordova，Facebook的React-Native（通过Jscore进行js解析，使得原生View进行渲染，提供桥机制调用原生的能力）。RN是第一个真正的高性能动态框架，它的出现让Web前端和客户端的界限变得模糊。随之而来的是各个大公司的自研框架，例如阿里巴巴的Weex和美团的Picasso框架，RN只提供了Android和IOS的支持，Weex扩展了思路，提供了Web端的支持，一个是React语法糖，一个Vue语法糖。另外，Google自己在2018年下半年正式推出了自己的跨平台方案—Flutter（前面Blog已经写过），通过Dart编写APP，然后编译成机器码运行在IOS和Android上，对开发者最好的是Hot reload，而且做到了原生跨平台。 移动端机器学习毫无疑问，移动端机器学习从2017年年底就开始火起来了，TensorFlow 也推出了移动端框架，很多应用都开始在移动端部署机器学习模型，例如相机类应用（FaceU）、电商类应用（唯品会）等，包括离线的机器学习。如果深挖这个方向，我觉得十年内不会被淘汰。当然了，难度也不小。 AR和VR从支付宝的 AR抢红包、QQ的AR踢球等玩法被越来越多的人体验，AR走进了人们的视野。对于广告引流玩法来说，AR无疑是能带来巨大收益的。那么开发AR引擎的移动开发者自然成了香饽饽，目前AR主要应用的领域是广告变现，不过很多公司也找到了AR的一些落地场景，如果是研究OpenGL，计算机图形学的移动开发者，可以往AR引擎开发方向发展，非常有前景。 移动端音视频 这个领域最火的就是抖音了，还有各种相机，图片应用等都需要音视频开发领域的专业开发人员，图像处理，滤镜，剪裁等，研究OpenGL，计算机图形学的移动开发者在这个领域也有很大的优势 移动端区块链在人人都知道比特币的时候，背后的区块链技术也得到了大家的拥护，区块链应用目前最多的还是数字钱包，但是未来应该会有更多的落地方式，例如Status。如果有移动开发同学对区块链方向感兴趣的，可以开始研究起来了。如果要学习智能合约开发的同学，我推荐一个非常好的网站：Cryptozombies，绝对是入门 solidity 智能合约开发的精品。 目前移动端的区块链人才还不多，各大公司也没有在招，但是两三年内，应该就会爆发了，现在还在探索落地场景的阶段，也给了对区块链技术感兴趣的移动开发同学学习的时间。改变世界的技术了解一下？ 移动端基础框架UI未来可能都会被动态化技术接管，但是移动基础框架不会。一个APP总要有网络请求，日志处理，ORM，缓存，PUSH等框架，这部分和UI关系不大，但是是组成APP不可或缺的部分。框架其实就是轮子，我们用轮子用的很溜并不代表你的代码能力很溜，而是人间写的轮子很溜，好的轮子就是无论开发者代码能力好坏，写出来的功能和性能都是差不多的，比如Retrofit，OKhttp等。在这些框架基础上P5和P7写的代码不会有多大差别。然后，轮子总要有人写，而且大公司的需求可能开源的轮子不满足，这时候就要自创轮子了。写轮子就需要开发者的知识深度和广度了，需要沉淀和学习。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画总结]]></title>
    <url>%2F2019%2F02%2F16%2FAndroid%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：lottie,SVGA 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。) 动画分类各自特点及区别Android动画主要分为视图动画和属性动画，视图动画只有透明度，旋转，平移，伸缩四种，而属性动画则是只要是对象的属性且有setter该属性的方法就可以对该属性执行一种动态变化效果。视图动画主要是使用Animation，组合动画使用AnimationSet，而属性动画主要是Animator，组合使用AnimatorSet。视图动画主要就是四种操作，对对象的颜色，背景等就无能为力了。相对来说，属性动画会更精细点，能实现更多更好的效果。 视图动画视图动画很早就出现在Android中，主要在android.view.animation包下面，这里可以看到主要是对View进行操作的，里面有很多的类帮助我们实现一些简单动画效果，如对view进行移动，缩放，旋转，淡入淡出等，并且我们可以借助AnimationSet将这些动作组合起来 补间动画（Tween Animation） 名称 原理 对应Animation 子类 平移动画 移动视图位置 TranslateAnimation 缩放动画 放大缩小视图 ScaleAnimation 旋转动画 旋转视图位置 RotateAnimation 透明度动画 改变视图透明度 AlphaAnimation 逐帧动画（Frame Animation） 这个类似动画片，一帧一帧播放，每一帧是一张图片，按顺序去播放一组预先定义好的图片，简单方便，但是容易OOM，占资源 属性动画属性动画在Android3.1的时候才引入到Android中，主要在android.animator包下面。属性动画机制已经不仅仅是针对View来设计了（看包名就知道），也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不在是视觉上的动画效果了。它实际上是一种不断对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性（真的改变了对象属性）。属性动画的工作原理和逻辑： 步骤2中的插值器，默认会有一些系统自带的插值器，如下表，表示的是初始值到结束值的一个变化关系，关系到动画的一个显示效果。 名称 描述 插值器（Interpolator） 值的变化模式（匀速,加速） 估值器（TypeEvaluator） 决定值的具体变化数值 插值器名称 描述 AccelerateDecelerateInterpolator 先加速再减速 AccelerateInterpolator 先加速再一直加速 AnticipateInterpolator 先往后一下，再加速往前 AnticipateOvershootInterpolator 先往后一下，再一直往前超过终点，再往回收一下。 BounceInterpolator 最后会回弹一下 CycleInterpolator 重复几次，感觉就是环形进度条那种，具体我还没试过 DecelerateInterpolator 一直减速 LinearInterpolator 线性匀速 OvershootInterpolator 到了终点之后，超过一点，再往回走。有个参数可以定义，超过的力度。 ValueAnimator 定义：通过不断控制值的变化，再不断手动赋值给对象的属性，从而实现动画效果。如下图： 用法 ObjectAnimatorObjectAnimator继承自ValueAnimator测试Hexo本地是否要保留原文件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SBT环境搭建]]></title>
    <url>%2F2019%2F01%2F30%2FSBT%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景 由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做个记录（凑数）。 步骤 前提必须要装JDK，sbt也是运行在JVM上的，所以需要java的环境，没有环境sbt会提示你先要装JDK，然后就是配置好环境变量了。 下载IDE现在宇宙IDE非IDEA莫属了（VS Code表示不服），前后端主要的平台都支持，AndroidStudio就是基于这个IDE写的。咱也熟。下载完成后下载插件：Scala和Sbt。下载完成后重启IDE，导入Sbt项目后，会自动在右侧多了个sbt编译按钮 下载sbt sdk这里要下载sbt最新版本（好像是1.2.+），配置好环境变量，在命令行测试命令：sbt或者sbt test。这样在user目录下会生成一个.sbt目录。 配置私服访问一般上面三步基本就能配好环境。直接导入代码就可以使用sbt编译了，但是我们的后端很多依赖包是在自己公司搭建的私服上的，所以还需要配置访问私服的密钥和路径。（问人的，这个貌似很多文章都找不到），生成两个文件（一个私服仓库的路径文件，一个授权访问私服的文件）见图：需要放在上面所说的.sbt文件中。 这里还有一个很坑人的地方，导致你编译失败，代码一片红，因为我们在上面的私服仓库路径文件里面配置的第三方依赖包和我们自己仓库的依赖包都会同时下载，但是基于经验判断我们下载自己仓库的包的时候先决条件是需要把第三方包都下载好，这样如果同时下载会导致所有包都下不下来（坑），这时候就需要根据经验先下载一些优先的第三方包，注释掉另外一些路径，等下载完成后再打开这些路径，接着下载所需的私有仓库中的包。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>scala，sbt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin常用操作符]]></title>
    <url>%2F2019%2F01%2F03%2FKotlin%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[操作符？操作符表示这个对象可能为空 12//在变量后面加？，代表这个变量可以为空var name: String? = &quot;zhangsan&quot; 1234//如果str不能转为Int类型，则返回nullfun parseInt(str: String): Int?&#123; //&#125; 12// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？b?.length ?:操作符如果操作符左边表达式不为空用左边表达式结果，为空则用右边的值。类似三元运算符1234val l: Int = if(b!=null) b.length else -1// 除了完整的if表达式，这个还可以用Elvis操作符来表示：val l = b?.length ?: -1// 如果?: 左侧表达式非空，elvis操作符就返回左侧表达式的值，否则返回右侧的值。 注意：当且仅当左侧为空时，才会对右侧表达式求值。 ！！操作符一定是非空的值 12//这会返回一个非空的b值，或者如果b为空，就会抛出空指针异常var l = b!!.length == 与 ===这个类似java中的 == 和 .equals() == 判断值是否相等，=== 判断值及引用是否完全相等。 12345val num: Int = 128;val a:Int? = numval b:Int? = numprintln(a == b) //trueprint(a === b) //false ..符号以及 in 和 !in 操作符..代表从x到y，==包括x和y,这是一个闭区间==运算符，而until则是半闭区间运算符，代表从a到b范围内所有的值，==包括a和不包括b==。in代表在一个区间中，！in代表不在一个区间中。 123456if(i in 1..10)&#123; //等价于 1 &lt;= i &lt;= 10 println(i) &#125;使用until函数，创建一个不包括其结束元素的区间for(i in 1 until 10)&#123;&#125; // i in [1,10) downTo()函数倒叙遍历，区间内循环 1for(i in 4 downTo 1)&#123;&#125; //print(i) -- 4321 step函数可以进行任意数量的迭代 12for (i in 1..4 step 2) print(i) // prints &quot;13&quot;for (i in 4 downTo 1 step 2) print(i) // prints &quot;42&quot; ::符号得到类的Class对象 1startActivity(Intent(this@KotlinActivity, MainActivity::class.java)) @符号限定this的类型 123456789101112class User &#123; inner class State&#123; fun getUser(): User&#123; //返回User return this@User &#125; fun getState(): State&#123; //返回State return this@State &#125; &#125;&#125; 作为标签跳出双层循环123456789101112loop@ for (itemA in arraysA) &#123; var i : Int = 0 for (itemB in arraysB) &#123; i++ if (itemB &gt; 2) &#123; break@loop &#125; println(&quot;itemB:$itemB&quot;) &#125;&#125; ==命名函数自定义标签：== 1234567891011121314fun fun_run()&#123; run &#123; println(&quot;lambda&quot;) &#125; var i: Int = run &#123; return@run 1 &#125; println(&quot;$i&quot;) //匿名函数可以通过自定义标签进行跳转和返回 i = run (outer@&#123; return@outer 2 &#125;) println(i)&#125; 从forEach跳出 12345678910111213141516171819202122fun forEach_label(ints: List&lt;Int&gt;)&#123; var i =2 ints.forEach &#123; //forEach中无法使用continue和break;// if (it == 0) continue //编译错误// if (it == 2) /*break //编译错误 */ print(it) &#125; run outer@&#123; ints.forEach &#123; if (it == 0) return@forEach //相当于在forEach函数中continue,实际上是从匿名函数返回 if (it == 2) return@outer //相当于在forEach函数中使用break,实际上是跳转到outer之外 &#125; &#125; if (i == 3) &#123; //每个函数的名字代表一个函数地址，所以函数自动成为标签 return@forEach_label //等同于return &#125;&#125; as?操作符当使用as转型的时候，可能经常出现ClassCastException。所以，现在可以用==as?安全转型==，当转型不成功的时候，它会返回null。 注意：在使用intent传值的时候，会出现空字符串不能用as强制转型，应该使用as? 1val m: Int? = a as? Int 冒号：用于类的继承，变了的定义 类型和超类型之间的冒号前要有一个空格 实例和类型之间的冒号前不能用空格 12345//定义全局变量时var str: String? = null//类的继承与变量定义class TestActivity&lt;T : Serializable&gt;(str: String) : Activity&#123;&#125; 类型判断符is检查某个实例是否是某个类型，如果判断出属于某个类型，那么判断后的分支中可以直接可当该类型使用，==无需显示转换== 123456fun getStringLength(obj: Any): Int? &#123; //obj在&amp;&amp;右边自动动转换成&quot;String&quot;类型 if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null &#125; $操作符字符串可以包含模板表达式，及一小段代码，会求值并把结果包含到字符串中。模板字符串以美元符号$开头，由一个简单的名字构成： 12val value:Int=5;val str:String=&quot;the value is $value&quot; 标准函数run 、 apply 、 let 、 also 和 with 五个函数均位于 kotlin 包下的 Standard 文件中，其含义和用法比较相似，现分别介绍如下。 run run函数使用的一般结构 12object.run&#123;&#125; run函数的inline+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block() 结构分析run函数实际上可以说是let和with的结合体，run函数只是接受一个lambda函数作为参数，以闭包形式返回，==返回值为最后一行的值或者指定的return的表达式== 例子 1234567891011121314151617181920212223//kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = user.run &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//java public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var5); int result = 1000; String var3 = &quot;result: &quot; + result; System.out.println(var3); &#125; 适用场景适用于let，with函数任何场景，因为run函数是let，with两个函数的结合体，它既弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样省略，直接访问实例的公有属性和方法，另一方面也弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理 run函数使用前后对比 不使用run函数12345678910111213override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; val item = getItem(position)?: return with(item)&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; 使用run函数 123456789101112override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; getItem(position)?.run&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) // 可以看到直接省略了item，并且可以在之前判空 holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; let let函数的一般结构 123456789object.let&#123;it.todo()//在函数体内使用it替代object对象去访问其公有的属性和方法...&#125;//另一种用途 判断object为null的操作object?.let&#123;//表示object不为null的条件下，才会去执行let函数体it.todo()&#125; let函数底层的inline扩展函数+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) 结构分析从源码let函数来看，它是一个只有一个lambda 函数块block作为参数的函数，调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过it指代该对象，返回值为函数块的最后一行或者指定return表达式。 let函数的kotlin和java转化 1234567891011121314151617181920212223 //kotlin fun main(args: Array&lt;String&gt;) &#123; val result = &quot;testLet&quot;.let &#123; println(it.length) 1000 &#125; println(result) &#125;//返回值：7/1000 //java public final class LetFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); String var2 = &quot;testLet&quot;; int var4 = var2.length(); System.out.println(var4); int result = 1000; System.out.println(result); &#125;&#125; let函数适用的场景最常用的场景就是使用let函数处理需要针对一个可以null的对象统一判空处理。 let函数的前后对比 没有使用前： 123mVideoPlayer?.setVideoView(activity.course_video_view)mVideoPlayer?.setControllerView(activity.course_video_controller_view)mVideoPlayer?.setCurtainView(activity.course_video_curtain_view) 使用后： 123456//对对象做了统一的判空处理mVideoPlayer?.let &#123; it.setVideoView(activity.course_video_view) it.setControllerView(activity.course_video_controller_view) it.setCurtainView(activity.course_video_curtain_view)&#125; with with函数的一般结构 12with(object)&#123;&#125; with函数底层的inline扩展函数+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() 结构分析with函数和前面几个函数使用方法略有不同，因为它不是以扩展的形式存在的。它是将某个对象作为函数的参数，==在函数块内可以通过this指代该对象==。返回值为函数块最后一行或者指定的return表达式。 可以看出with函数接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始的样子如下： 1234val result = with(user, &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125;) 但是由于，with函数最后一个参数是一个函数，可以把函数提到圆括号外部，所以最终with函数的调用形式如下：（可以看下kotlin的lambda表达式） 1234val result = with(user) &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; with函数的kotlin和java转化 1234567891011121314151617181920212223//kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = with(user) &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//java public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var4 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var4); int result = 1000; String var3 = &quot;result: &quot; + result; System.out.println(var3); &#125; with函数的适用场景 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBindViewHolder中，数据model的属性映射到UI上 with函数使用前后对比 没有使用： 12345678910111213141516@Overridepublic void onBindViewHolder(ViewHolder holder, int position) &#123; ArticleSnippet item = getItem(position); if (item == null) &#123; return; &#125; holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn)); holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary)); String gradeInfo = &quot;难度：&quot; + item.gradeInfo; String wordCount = &quot;单词数：&quot; + item.length; String reviewNum = &quot;读后感：&quot; + item.numReviews; String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum; holder.tvExtraInfo.setText(extraInfo); ...&#125; 使用了之后： 1234567891011121314override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123; val item = getItem(position)?: return with(item)&#123; holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn) holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary) //省略了item，直接调用了实例中的方法 holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot; ... &#125;&#125; apply apply函数使用的一般结构 123object.apply&#123;//todo&#125; apply函数的inline+lambda结构 12@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; apply函数的inline结构分析 从结构上来看，apply函数和run函数很像，唯一不同点就是他们各自返回值不同，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回值则是传入对象的本身。 apply函数的kotlin和java转化 12345678910111213141516171819202122232425/kotlinfun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;) val result = user.apply &#123; println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;) 1000 &#125; println(&quot;result: $result&quot;)&#125;//输出：result：kotlin，1，111111（User本身对象被打印出来）//javapublic final class ApplyFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;); String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum(); System.out.println(var5); String var3 = &quot;result: &quot; + user; System.out.println(var3); &#125; apply函数使用前后的对比 没有使用： 1234567mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = truemSheetDialogView.course_comment_seek_bar.max = 10mSheetDialogView.course_comment_seek_bar.progress = 0 使用后： 1234567891011//形成了链式调用mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123; course_comment_tv_label.paint.isFakeBoldText = true course_comment_tv_score.paint.isFakeBoldText = true course_comment_tv_cancel.paint.isFakeBoldText = true course_comment_tv_confirm.paint.isFakeBoldText = true course_comment_seek_bar.max = 10 course_comment_seek_bar.progress = 0&#125; 多层级判空问题 12345678910111213if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123; return;&#125;if (mSectionMetaData.questionnaire.userProject != null) &#123; renderAnalysis(); return;&#125;if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123; fetchQuestionData(); return;&#125; -&gt; 使用了apply后可以变为链式调用 1234567891011121314151617mSectionMetaData?.apply&#123; //mSectionMetaData不为空的时候操作mSectionMetaData&#125;?.questionnaire?.apply&#123; //questionnaire不为空的时候操作questionnaire&#125;?.section?.apply&#123; //section不为空的时候操作section&#125;?.sectionArticle?.apply&#123; //sectionArticle不为空的时候操作sectionArticle&#125; also also函数使用的一般结构 123object.also&#123;//todo&#125; also函数的inline+lambda结构 1234@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)//可以看到这个函数是从kotlin1.1开始才有的public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125; also函数的inline结构分析 also函数的结构实际上和let很像，唯一的区别是返回值不一样，let是以闭包的形式返回的，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值，而also函数则返回传入对象本身。这个和apply一样。 also函数的kotlin和java转化 12345678910111213141516171819202122//kotlinfun main(args: Array&lt;String&gt;) &#123; val result = &quot;testLet&quot;.also &#123; println(it.length) 1000 &#125; println(result)&#125;//结果：7/testLet//javapublic final class AlsoFunctionKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); String var2 = &quot;testLet&quot;; int var4 = var2.length(); System.out.println(var4); System.out.println(var2); &#125;&#125; 标准函数总结 函数名 定义inline结构 函数体内代指对象 返回值 是否是扩展函数 使用场景 let fun T.let(block: (T) -&gt; R): R = block(this) it 闭包返回 是 适用于处理不为null的操作场景 with fun with(receiver: T, block: T.() -&gt; R): R = receiver.block() this 返回闭包 否 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上 run fun T.run(block: T.() -&gt; R): R = block() this 闭包返回 是 适用于let,with函数任何场景。 apply fun T.apply(block: T.() -&gt; Unit): T { block(); return this } this 返回this 是 also fun T.also(block: (T) -&gt; Unit): T { block(this); return this } it 返回this 是 适用于let函数的任何场景，一般可用于多个扩展函数链式调用]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法（二）]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。 单向链表转置这个问题其实是很常见的一个算法问题，但是如果没弄清楚就会被它给搞晕了，从晕到不晕的过程就是你理解该算法的过程。 算法还是需要理解它，才能真正的去掌握它 下图是一个单向链表转置的初始状态和终止状态。 转置后： 链表首先要知道链表的数据结构是怎么样的，链表首先有自己的值（value），其次它有一个指针指向了下个结点，我们用代码来表示是这样的： 123456789class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value = data &#125;&#125; 从上面代码可以很清楚的看到链表的特点，他是区别于数组的一种数据结构。 链表和数组在数组中，是通过==索引==来访问元素的，很多算法都是利用索引来操作的，所以数组这种数据结构可以快速的查询到数据。链表的优势则是删除/插入数据，因为数组是固定长度的，所以增删都会改变数组的所有元素（下标变化了），而链表是可以动态改变大小的，他只会影响左右相邻的两个结点。另外链表在内存中的存储不是连续的。 算法分析过程先上代码 123456789101112131415public Node reverseList(Node head)&#123; //临时变量 Node pre = null Node next = null while(head != null)&#123; next = head.next // 1 head.next = pre // 2 pre = head //3 head = next. //4 &#125; return pre&#125; 我们来分析下具体过程，其实主要是while循环中四句话。我们逐一来分析，第一轮过程： 首先初始状态： 执行完1：next = head.next后： 执行完2: head.next = pre后：（pre此时是null） 执行完3: pre = head后： 执行完4: head = next后： 第一轮结束，我们看到头结点head在2的位置了，递归操作，我们继续分析第二轮： 执行完1：next = head.next后： 执行完2: head.next = pre后：（pre此时是指向了1）这一步很巧妙将1和2转置了。执行完3: pre = head后： 执行完4: head = next后： 如此，经过5次循环就能将这个单向链表成功转置了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法 (一)]]></title>
    <url>%2F2018%2F12%2F16%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。 常见排序算法快速排序算法原理：分治，前后两个指针交替前进，然后递归，主要步骤是： 取一个数作为基数（一般就选第一个） 将数组中比这个数大的放在它的右边，比基数小的放在它左边 递归两遍的数组 123456789101112131415161718192021222324252627public void quickSort(int[] a,int low,int high)&#123; int i = low; int j = high; int temp = a[low] //比较的数 while(i &lt; j)&#123; while(i&lt;j &amp;&amp; a[j] &gt;= temp)&#123; j--; &#125; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; while(i &lt; j &amp;&amp; a[j] &lt; temp)&#123; i++; &#125; if(i&lt;j)&#123; a[j] = a[i]; j--; &#125; &#125; a[i] = temp; quickSort(a,low,i-1); quickSort(a,i+1;high);&#125; 堆排序原理：堆其实是一个完全二叉树，它的特征是当前结点下标为i，那么它的根结点为i/2，它的左子结点为：2i+1；右子结点为：2i+2。堆排序要经过两步： 将树变为稳定的二叉树（大堆模式），即每个根结点都要大于等于它的子结点。 将根结点和最后一个结点互换，递归以上操作 手写代码：12345678910111213141516171819202122//第一步变为稳定树public void adjustHeap(int[] ,int parent,int length)&#123; int temp = a[parent]; int leftChildIndex = 2*parent + 1; while(leftChildIndex &lt; length)&#123; if (a[leftChildeIndex] &lt; a[leftChildIndex + 1]&#123; leftChildIndxe = leftChildIndex + 1; &#125; if (temp &gt; a[leftChildIndex])&#123; break; &#125; a[parent] = a[leftChildIndex]; parent = leftChildIndex; leftChildIndex = 2*leftChildIndex + 1; &#125; a[parent] = temp;&#125; 冒泡排序原理：内存循环会不停比较两个数的大小，进行换位，完成一轮后，最大的数会排在最后。（注意和选择排序的区别，选择排序是内层循环和外层循环比较）算法时间复杂度：O（n2） 1234567891011121314public static void bubbleSort(int[] a)&#123; int len = a.length; for(int i =0 ;i&lt;len;i++)&#123; for(int j=1;j&lt;len - i -1;j++)&#123;//每一轮最后一个数不用比较 // 内存循环比较相邻两个数 if(a[j] &gt; a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125; 选择排序原理：遍历数组中最小值，放在最左边，再从剩下数组中找最小值，直到排序完成（在要排序的一组数中，选出最小的一个数与第一个位置的数交换位置）算法时间复杂度：O（n2） 123456789101112131415public static void selectSort(int[] a)&#123; int len = a.length; for(int i = 0;i&lt;len;i++)&#123; for(int j = i+1; j&lt; len;j++)&#123; // 和外层第一个元素比较 if(a[j] &gt; a[i])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法，Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDG Shenzhen 2018]]></title>
    <url>%2F2018%2F12%2F09%2FGDG%20Shenzhen%202018%2F</url>
    <content type="text"><![CDATA[关于GDGGDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。 GDG官网 昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。 活动打卡活动地址，关键离我住的地方很近。 更多照片–现场图片直播 心得感想今年的活动收获还比较多，GDE（Google developer expert）将了很多AI，TensorFlow，Google的一些东西，包括很具体的Flutter，Kotlin以及Android的优化等等东西。干活还是比较多的。作为一个Android开发者，对于Android的未来其实一直有关注，blog里面也写了很多，这里就写一些经过这个活动后的感受吧，Google其实已经在开发Android的替代系统了，而且kotlin也迭代到了V1.3版本，这个时候又来了个Flutter（跨平台开发），感觉这些项目都是各自为政，其实看过《硅谷之谜》这本书后也能理解，大公司其实内部为了保持创新活力会鼓励团队或者部门去折腾，类似公司里面的成立小的创业团队，每个团队负责一个项目，如果做好了就会被公司收购，做的不好就被关掉（垃圾Google关掉了多少优秀的服务，看看隔壁百度。。。）。对于我们这些开发者而言，其实还是要靠自己的兴趣去选择，感觉李锐博士说的很好：选择职业要看自己的兴趣，不要太功利，AI很火大家都去AI，市场饱和后还是靠大家的实力，如果已自己的兴趣为出发点，赚钱是一个自然的过程。保持好奇心，紧跟前沿技术，不断去学习。然后，我自己感觉，flutter这个东西还是需要去认真对待的，特别是感受到他的hot reload的特性后，感觉非常爽，还有kotlin也是需要快速去掌握的，目前个人掌握的并不全面。另外，需要移动端结合AI来做些东西，可能会有不一样的发现。下面列出个人比较关注和感兴趣的点： 数据安全，在中国还有很多工作要做 隐藏的歧视，这里其实指的是，在技术发展飞速的今天，很多年轻人已经享受到了技术带来的好处，但是还有些人是没有得到实惠的，这些人在这个时代是弱势群体，但是他们经常会被忽略。 Flutter的优势在众多跨平台框架中是很out standing的 Android WorkManager某些情况下是可以替代Service的，比如在那些不用立即在后台执行操作的场景下 Kotlin的协程概念。这个我比较感兴趣，这个特性是V1.3刚发布的，这个是kotlin中的异步概念的实现，很像Rxjava的链式调用，需要去学习一下，另外kotlin好像也能有在大数据里面。 供web和移动端调用的轻量级TensorFlow，包括tensorflwo.js tensorflow.lite。 中国的AI发展很快，美帝国主义可能要制裁这些公司了。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>GDG</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悖论之共有知识和公共知识]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%82%96%E8%AE%BA%E4%B9%8B%E5%85%B1%E6%9C%89%E7%9F%A5%E8%AF%86%E5%92%8C%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[背景继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。 题目说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩： 大家不能讨论别人眼睛的颜色。 如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。 有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？ 分析首先，根据规则，其实大家都知道在村里有红/蓝两种眼睛的人，但是大家都不知道自己眼睛是什么颜色的。直到来了外乡人说了一句“你们中有人跟我一样是蓝色眼睛的人”，我们来分析下：假设村里只有1个蓝眼睛的人，那么这个人只知道村里都是红眼睛的，那么那个蓝眼睛就是自己了。那么再假设村里有2个蓝色眼睛的人，那么这两个人都知道对方是蓝眼睛的，但是第一天对方没有去自杀，那么理由只有一个村里蓝眼睛的人不止一个，也就是自己也是蓝眼睛，那么这两个人都会第二天自杀；依次类推，有3个蓝眼睛的人，如果第二天没人死，那么就是村里不止两个蓝眼睛的人，也就是自己就是蓝眼睛。。。。那么，红眼睛的人会死吗？答案是不会，因为红眼睛的人不知道自己眼睛的颜色是什么？可能红色，也可能黑色对不对 引申我们来看下，其实外乡人什么信息都没增加，为什么就发生了这种事情呢？这就要从知识分类来说了，知识分两类：共有知识，公共知识。共有知识：大家都知道的知识公共知识：大家都知道大家知道的知识 那么，从上面例子可以看出，大家原来都知道村里有红蓝眼睛的人，这就是共有知道，但是当外乡人把这件事情说出来共有知识就变成了公共知识，大家就都知道大家知道这件事情了。其实现实生活中有很多这样的例子，大家可以去发现，只有去讨论，将自己心里知道的东西说出来，才能变成公共知识，发挥出效果。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>心理学，悖论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悖论系列之分金问题]]></title>
    <url>%2F2018%2F12%2F06%2F%E6%82%96%E8%AE%BA%E4%B9%8B%E4%B8%89%E5%A7%AC%E5%88%86%E9%87%91%2F</url>
    <content type="text"><![CDATA[背景一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。 问题有一期的问题是：从前有一个国王，一天他的三位妃子想玩一个游戏，这个游戏规则是这样的： 有100金币供三个人A B C分 每个人按顺序发言，即提议分配这100金的方案 如果这个人的发言超过半数的人同意，则方案达成，如果没有，提议的人则要被处死。 每个人都很聪明而且人性本恶，每个人都想尽量多的获得更多的金币，如果还能杀死对方，那么则更好。问题是：最终这个金币会怎么分？ 想一想。。。。。。。。。。。。。。。。。初想下：A应该分的最少吧，因为最先提 分析首先，我们来假设A已经死了，只剩下B和C来分这个金币会出现什么情况，这个时候其实很简单了，按照第四条原则：B不管提出什么方案，C都不同意，那么C就能分到100金币，并且杀死了A和B。那么，其实在A死的情况下B也一定死；所以，B要怎么做才能不死呢，答案只有一个：A不能死。这个情况A是知道的，B也知道。那么就是说：无论A提出什么样的方案，B都会同意，这个时候分配方案是A：100/B：0/C：0，那么也有答案是A应该给一块金币B，那么B更加会同意A，如果A死，B一定死而且一毛钱拿不到。 总结我们引申下这个问题，如果来了四个人来分金币，会怎么样呢：M A B C？依然遵循上面的分析过程，M会拿到最多的金币，但是A就是一毛拿不到了，B和C反而会各拿到1个金币（大家想想是不是）：如果M死了，B和C都会一毛拿不到，这个时候M如果给B和C一人一个金币，那么B和C必然赞同，而A为了自己利益最大化，当然是想把M干掉，但是BC同意的话A的意见也没什么作用了。 这个问题很像现在的社会，国家也一样，老大永远提防老二，而老二永远想干掉老大，老大为了压制老二还会去讨好老三老四组成联盟。这个问题其实蛮有趣的，以前没想过这个问题，现在慢慢发现，很多问题其实都来源于人性。这个问题就到此，后面会有其它悖论的题目再分析吧。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>悖论</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter V1.0.0发布]]></title>
    <url>%2F2018%2F12%2F06%2FFlutter1.0%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[flutter是什么Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编写。2018/12/04Google正式发布了它的V1.0.0稳定版本，也就是说移动端的开发有可能会发生革命性的变化。本人第二天看了youtube上的发布会，然后试玩了一下发布会上说的Google三个员工三个月为这场发布会写的Demo app：The history of everything。个人感觉：完全感觉不出是非原生的，动画，过渡非常流畅，而且我还用的是老的Nexus 6P来运行的，这种表现打破了我对跨平台开发的认知，让我相当震撼，也许原生开发真的要被取代了，喊了N多遍的狼来了看来也只是时间问题了。 个人感想当变化来的时候，也许最好的方式是去拥抱变化，而不是墨守成规，扛着原生开发的大旗拉上kotlin小弟一起为Google的保守势力买单。技术现在发展月来越快，技术更新周期越来越短，这也对开发者提出了更高的要求，你需要不断的学习新东西，去适应这个快速发展的世界；但是，每个人的精力都是有限的，怎样在这个信息爆炸的时代学习到保命技能做到以不变应万变，这就需要你的眼光，高度以及眼界了，形而上的东西看着像套路但是归根结底被前人总结的其实就是这些东西，如果你具有了这些“能力”，你就会敏锐的知道在这些快速发展的技术中，哪些是革命性的？哪些是过渡的？集中精力去学习革命性的技术会让你在以后有先发优势，而如果你选择错误，则只能看着刚学的内容马上就out了。 个人总结的几点建议： 不盲目跟风口。如果自己专业领域就是风口，那就是最好，这里说的是不同领域为了去风口而盲目转型，最少要有关联性，而且是你喜欢的。 跟随大公司。这里的大公司指的是掌握核心科技的公司，站在业界前沿的公司如Google，他们发布的技术有可能就是革命性的。 对新技术保持永远的好奇心。还是刚说的要去拥抱变化，而不是抵触。 抓住机会，去更大的平台。大平台的优势不用说了。在技术变革期，大平台是最敏感的。 在技术外，丰富自己的知识库，多看书，多阅历，多和优秀的人沟通。 flutter的特性这里就贴一些文章，看到的都是各种赞不绝口，希望我也能把它收进武器库。Google 要用 Flutter 一统移动、桌面开发江湖？ Flutter 1.0 正式版: Google 的便携 UI 工具包]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>跨平台</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https简介]]></title>
    <url>%2F2018%2F12%2F04%2FHttps%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https协议 Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。 Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。 下面我们来看下加密图解过程： 加密过程解析： 客户端发送https请求，服务端返回给客户端证书（证书中含有服务端随机产生的非对称加密的公钥P）==非对称加密的算法首推RSA，可以去看原理，其实就是求一个大数的质数分解== 客户端验证发送的证书是有有效，是否去信任该证书，并随机产生对称加密的密钥K，使用P对K进行加密。 将加密后的对称加密密钥K传回给服务端，服务端用非对称加密的私钥将其解开，这样服务端和客户端都有了对称加密密钥K了。（这么做的目的是防止在传输过程中K被泄漏） 以后客户端会通过K进行数据加密，而服务端也会用K进行解密 1-2是密钥协商过程，3是加密传输过程，其中密钥协商过程解决了对称加密密钥的传输问题，由于非对称加密比对称加密解析效率低，但是安全的多的特点，因此将非对称加密用来传递对称加密密钥，而用对称加密去加解密数据。这样既保证了对称加密密钥，又保证了数据解析过程中效率。 证书证书应该是第三方认证机构颁发出来的，具有签名的一种信任凭证。而证书是需要购买的：免费的：国内沃通：沃通国外：woturs 其实，国内这家的根证书也是startssl签发的，实际上也是国外的。 参考链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化（一）]]></title>
    <url>%2F2018%2F11%2F30%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Android内存优化（一）在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。 HashMapHashMap内部使用了一个默认容量为16的数组来存储数据，而数组中每个元素又是一个链表的头结点，所以其实HashMap就是一个数组+链表的数据结构。如图： 左边纵向是数组，右边横向为链表。 这个数据结构中每一个都一个Entry类型，那么Entry的数据结构是怎么样的呢： 1234final K key;V value;final int hash;HashMapEntry&lt;K, V&gt; next; 从中我们可以看到Entry中有key，value，hash值以及下一个结点Entry，那么Entry数据是按照什么规则来存储的呢：通过计算元素key的hash值，然后对HashMap中的数组长度（默认16）取余从而得到该元素应该存在哪里，计算公式为==hash(key)%len==,举一个例子： hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置 如图：从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不回覆盖前一个，而是放在链表末尾，从而解决了Hash冲突的问题。（问题1:如果key的hash值取余大于15，那么元素该放在哪里？）。 所以，重点是：我们知道HashMap默认存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap的对象的时候，即使里面没有任何元素，系统也是会分配这么多空间给它的，而且，当我们不断往里面put数据的时候，当达到了一定的容量限制时，HashMap会扩容，而且扩大后的新的空间一定是原来的==两倍==。 扩容条件：HashMap中的数据量&gt;容量*加载因子，默认加载因子是0.75 参见HashMap详解 参见HashMap的实现 只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费。附上hash函数的实现图： 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。 SparseArraySparesArray相比HashMap更省内存，某些条件下性能更好。它的内部规则是通过两个数组来存储数据的，一个存储key，另一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约了内存空间。我们从源码中可以看到key和value分别是用数组表示： 12private int[] mKeys;private Object[] mValues; 从源码中看到，SparesArray只能存储key为int类型的数据，同时，SparesArray在存储和读取数据的时候，使用的是二分查找法： 12345678public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); ... &#125; public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); ... &#125; 也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从==小到大的顺序排列好==，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。 使用场景：虽然SparesArray性能好，但是由于其添加，查找，删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，还有有下降，所以使用也是要看使用场景的： 数据量不大，在千以内（Android开发大部分场景吧） key必须为int类型以上就是使用它的场景了。 ArrayMapArrayMap其实也是一个key-value映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用了两个数组存储数据，一个数组记录key的hash值，另外一个数组记录value值，和SparesArray一样，也会对可以使用二分法进行从小到大的排序，在添加，删除，查找数据的时候都是使用二分法查到相应的index，然后通过index来进行操作，它的使用场景： 数据量不大，千以内 数据结构为Map类型 例子： 1ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;(); 如果我们要兼容api19以下版本，那么导入V4包import android.support.v4.util.ArrayMap;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin之object详解]]></title>
    <url>%2F2018%2F11%2F28%2FKotlin%E4%B9%8Bobject%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。 object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景： 对象声明（Object Decalaration） 伴生对象（Companion Object） 对象表达式（Object Expression）– 上面提到的就是这种 对象声明语法：通过object实现kotlin中的单例例子： 12345object RepositoryManager&#123; fun method()&#123; println(&quot;I&apos;m in object declaration&quot;) &#125;&#125; 即将object代替class关键字，声明一个类，这个类就是单例了 使用： 1234fun main(args: Array&lt;String&gt;) &#123; RepositoryManager.method()//kotlin的调用 RepositoryManager.INSTANCE.method();//java的调用&#125; 像在Java中调用静态方法（kotlin中没有静态方法）一样去调用其中定义的方法。其实，object声明的类最终被编译成：一个类拥有一个静态成员变量来持有对自己的引用，并且这个静态成员的名称是INSTANCE。它等价于java代码： 12345class RepositoryManager&#123; private RepositoryManager()&#123;&#125; public static final RepositoryManager INSTANCE = new RepositoryManager();&#125; 尽管和普通类的声明一样，可以包含属性，方法，初始化代码块以及可以继承其他类或者实现某个接口，但是它不能包含构造器，java中构造器是私有的。 它也可以定义在一个类的内部： 12345678910class ObjectOuter &#123; object Inner&#123; fun method()&#123; println(&quot;I&apos;m in inner class&quot;) &#125; &#125; &#125; fun main(args: Array&lt;String&gt;) &#123; ObjectOuter.Inner.method() &#125; 伴生对象（Companion object）在kotlin中是没有static关键字的，也就意味着没有了静态方法和静态成员。那么在kotlin中如果想表示这种概率，取而代之的是==包级别函数==这里的伴生对象。他们的区别在下面会介绍。 包级别函数是指在kotlin中fun可以不依赖于class，直接新建.kt文件在文件中直接可以写fun方法，调用的时候IDE会自动导入文件急fun的方法名可以在其他类中直接使用。（其实编译后它还是在类中的，只不过类名称是.kt的文件名） 伴生对象的语法形式： 12345class A&#123; companion object 伴生对象名(可以省略)&#123; //define method and field here &#125;&#125; 示例： 1234567891011class ObjectTest &#123; companion object MyObjec&#123; val a = 20 fun method() &#123; println(&quot;I&apos;m in companion object&quot;) &#125; &#125;&#125; 使用： 123456789fun main(args: Array&lt;String&gt;) &#123; //方式一 ObjectTest.MyObject.method() println(ObjectTest.MyObject.a) //方式二（推荐方式） ObjectTest.method() println(ObjectTest.a)&#125; 在定义时如果省略了伴生对象名称，那么编辑器会为其提供默认的名字Companion。在方法二中，我们是直接通过类名称.方法名()的形式调用的，我们在没有生成ObjectTest类对象时，直接调用了其伴生对象中定义的属性和方法，和java中的静态方法很相似。 通过javap命令，让我们看下其生成的字节码： 注意红框中，这个MyObject成员变量的类型，是用$符号连接的，那么说明我们在定义伴生对象的时候，实际上是把它当作了静态内部类来看待的，并且目标类会持有该内部类的一个应用，最终调用的是定义在这个静态内部类中的实例方法。 那么伴生对象和包级别函数的区别是什么呢？我们反编译下kt文件。 可以看出，一个名叫ObjectTest2.kt文件实际上会生成一个名叫ObjectTest2Kt的类，而这个顶级函数是作为这个类的静态方法的形式存在的。所以实际上类中的静态方法和内部类中的实例方法的区别，因为成员内部类中的方法是可以访问外部内定义的方法和成员变量的，哪怕是private的，而静态方法是做不到这一点的。 对象表达式（Object Expression）先来看下java中的匿名内部类： 123456789101112131415161718192021interface Contents &#123; void absMethod();&#125;public class Hello &#123; public Contents contents() &#123; return new Contents() &#123; @Override public void absMethod() &#123; System.out.println(&quot;method invoked...&quot;); &#125; &#125;; &#125; public static void main(String[] args) &#123; Hello hello = new Hello(); hello.contents().absMethod(); //打印method invoked... &#125;&#125; 这里指出两点java中内部类的局限性 如果在匿名内部类中添加了一些方法和属性，那么在外部是无法调用的 12345678910111213141516171819return new Contents() &#123; private int i = 1; public int value() &#123; return i; &#125; @Override public void absMethod() &#123; System.out.println(&quot;method invoked...&quot;); &#125; &#125;; public static void main(String[] args) &#123; Hello hello = new Hello(); hello.contents().absMethod(); hello.value(); //Cannot resolve method &apos;value()&apos; &#125; 当你想使用这个value方式的时候，编译会报错，因为java的多态导致父类型的引用是无法知晓子类添加的方法的。 一个匿名内部类肯定只能实现一个接口或者继承一个类。 在看看kotlin的对象表达式：语法： 1object [ : 接口1,接口2,类型1, 类型2]&#123;&#125; //中括号中的可省略 示例：实现一个接口或者类 1234567891011121314interface AA &#123; fun a()&#125;fun main(args: Array&lt;String&gt;) &#123; val aa = object : AA &#123; override fun a() &#123; println(&quot;a invoked&quot;) &#125; &#125; aa.a()&#125; 不实现任何接口和类，并且在匿名内部类中添加方法 12345678910fun main(args: Array&lt;String&gt;) &#123; val obj = object &#123; fun a() &#123; println(&quot;a invoked&quot;) &#125; &#125; obj.a() //打印：a invoked&#125; 从这个例子看出kotlin中，新添加的方式是可以调用的那么，实现多个接口和类（NB） 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; val cc = object : AA, BB() &#123; override fun a() &#123; &#125; override fun b() &#123; &#125; &#125; cc.a() cc.b()&#125;//注意写法 kotlin官方文档上的一句话：匿名对象只定义局部变量和private成员变量时，才能体现它的真实类型，如果你是将匿名对象作为public函数的返回值或者是public的属性时，你只能将它看作是它的父类，当然你不指定类型时就当Any看待，这时你在匿名对象中添加的方法和属性时不能被访问的。 例子： 12345678910111213141516171819202122232425262728293031323334class MyTest &#123; private val foo = object &#123; fun method() &#123; println(&quot;private&quot;) &#125; &#125; val foo2 = object &#123; fun method() &#123; println(&quot;public&quot;) &#125; &#125; fun m() = object &#123; fun method()&#123; println(&quot;method&quot;) &#125; &#125; fun invoke()&#123; val local = object &#123; fun method()&#123; println(&quot;local&quot;) &#125; &#125; local.method() //编译通过 foo.method() //编译通过 foo2.method() //编译通不过 m().method() //编译通不过 &#125;&#125; 最后：object声明：当第一次访问它时才初始化，是一种懒加载伴生对象：当他对应的类被加载后，它才初始化，类似java中的额静态代码块对象表达式：一旦被执行，就立刻初始化。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么用Kotlin去提高生产力：Kotlin Tips]]></title>
    <url>%2F2018%2F11%2F23%2FKotlin-Tips%2F</url>
    <content type="text"><![CDATA[目录 Tip1-更简洁的字符串 1、三个引号 2、字符串模版 Tip2-Kotlin中大多数控制结构都是表达式 1、语句和表达式 2、if 3、when Tip3-更好调用的函数：显式参数名及默认参数值 1、显式参数名 2、默认参数值 3、@JvmOverloads Tip4-扩展函数和属性 1、扩展函数 2、扩展属性 Tip5-懒初始化bylazy和延迟初始化lateinit 1、by lazy 2、lateinit Tip6-不用再手写findViewById 1、Activity 2、子View或者include标签 3、Fragment Tip7-利用局部函数抽取重复代码 1、局部函数 2、扩展函数 Tip8-使用数据类来快速实现model类 Tip9-用类委托来快速实现装饰器模式 Tip10-Lambda表达式简化OnClickListener Tip11-with函数来简化代码 Tip12-apply函数来简化代码 Tip13-在编译阶段避免掉NullPointerException 1、可空和不可空类型 2、let 3、Elvis操作符 Tip14-运算符重载 Tip15-高阶函数简化代码 Tip16-用Lambda来简化策略模式 Tip1-更简洁的字符串回到目录 三个引号详见案例代码KotlinTip1 Kotlin中的字符串基本Java中的类似，有一点区别是加入了三个引号”””来方便长篇字符的编写。而在Java中，这些都需要转义，先看看java中的式例12345678910111213public void testString1() &#123; String str1 = "abc"; String str2 = "line1\n" + "line2\n" + "line3"; String js = "function myFunction()\n" + "&#123;\n" + " document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";\n" + "&#125;"; System.out.println(str1); System.out.println(str2); System.out.println(js);&#125; kotlin除了有单个双引号的字符串，还对字符串的加强，引入了三个引号，”””中可以包含换行、反斜杠等等特殊字符：12345678910111213141516171819/** kotlin对字符串的加强，三个引号"""中可以包含换行、反斜杠等等特殊字符* */fun testString() &#123; val str1 = "abc" val str2 = """line1\n line2 line3 """ val js = """ function myFunction() &#123; document.getElementById("demo").innerHTML="My First JavaScript Function"; &#125; """.trimIndent() println(str1) println(str2) println(js)&#125; 字符串模版同时，Kotlin中引入了字符串模版，方便字符串的拼接，可以用$符号拼接变量和表达式123456789/** kotlin字符串模版，可以用$符号拼接变量和表达式* */fun testString2() &#123; val strings = arrayListOf("abc", "efd", "gfg") println("First content is $strings") println("First content is $&#123;strings[0]&#125;") println("First content is $&#123;if (strings.size &gt; 0) strings[0] else "null"&#125;")&#125; 值得注意的是，在Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是${‘$’}1234567/** Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是$&#123;'$'&#125;* */fun testString3() &#123; println("First content is \$strings") println("First content is $&#123;'$'&#125;strings")&#125; Tip2-Kotlin中大多数控制结构都是表达式回到目录 首先，需要弄清楚一个概念语句和表达式，然后会介绍控制结构表达式的优点：简洁 语句和表达式是什么？ 表达式有值，并且能作为另一个表达式的一部分使用 语句总是包围着它的代码块中的顶层元素，并且没有自己的值Kotlin与Java的区别 Java中，所有的控制结构都是语句，也就是控制结构都没有值 Kotlin中，除了循环（for、do和do/while）以外，大多数控制结构都是表达式(if/when等) 详见案例代码tip2 Example1：if语句java中，if 是语句，没有值，必须显式的return12345678910/** java中的if语句* */public int max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125;&#125; kotlin中，if 是表达式，不是语句，因为表达式有值，可以作为值return出去123456/** kotlin中，if 是表达式，不是语句，类似于java中的三目运算符a &gt; b ? a : b* */fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; 上面的if中的分支最后一行语句就是该分支的值，会作为函数的返回值。这其实跟java中的三元运算符类似，123456/** java的三元运算符* */public int max2(int a, int b) &#123; return a &gt; b ? a : b;&#125; 上面是java中的三元运算符，kotlin中if是表达式有值，完全可以替代，故kotlin中已没有三元运算符了，用if来替代。上面的max函数还可以简化成下面的形式1234/** kotlin简化版本* */fun max2(a: Int, b: Int) = if (a &gt; b) a else b Example2：when语句Kotlin中的when非常强大，完全可以取代Java中的switch和if/else，同时，when也是表达式，when的每个分支的最后一行为当前分支的值先看一下java中的switch12345678910111213141516/** java中的switch* */public String getPoint(char grade) &#123; switch (grade) &#123; case 'A': return "GOOD"; case 'B': case 'C': return "OK"; case 'D': return "BAD"; default: return "UN_KNOW"; &#125;&#125; java中的switch有太多限制，我们再看看Kotlin怎样去简化的123456789101112/** kotlin中，when是表达式，可以取代Java 中的switch，when的每个分支的最后一行为当前分支的值* */fun getPoint(grade: Char) = when (grade) &#123; 'A' -&gt; "GOOD" 'B', 'C' -&gt; &#123; println("test when") "OK" &#125; 'D' -&gt; "BAD" else -&gt; "UN_KNOW"&#125; 同样的，when语句还可以取代java中的if/else if，其是表达式有值，并且更佳简洁123456789101112131415/** java中的if else* */public String getPoint2(Integer point) &#123; if (point &gt; 100) &#123; return "GOOD"; &#125; else if (point &gt; 60) &#123; return "OK"; &#125; else if (point.hashCode() == 0x100) &#123; //... return "STH"; &#125; else &#123; return "UN_KNOW"; &#125;&#125; 再看看kotlin的版本，使用不带参数的when，只需要6行代码123456789/** kotlin中，when是表达式，可以取代java的if/else，when的每个分支的最后一行为当前分支的值* */fun getPoint2(grade: Int) = when &#123; grade &gt; 90 -&gt; "GOOD" grade &gt; 60 -&gt; "OK" grade.hashCode() == 0x100 -&gt; "STH" else -&gt; "UN_KNOW"&#125; Tip3-更好调用的函数-显式参数名及默认参数值回到目录 显式参数名Kotlin的函数更加好调用，主要是表现在两个方面：1，显式的标示参数名，可以方便代码阅读；2，函数可以有默认参数值，可以大大减少Java中的函数重载。例如现在需要实现一个工具函数，打印列表的内容：详见案例代码KotlinTip312345678910111213141516171819202122232425/** 打印列表的内容* */fun &lt;T&gt; joinToString(collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList() &#123; val list = listOf(2, 4, 0) // 不标明参数名 println(joinToString(list, " - ", "[", "]")) // 显式的标明参数名称 println(joinToString(list, separator = " - ", prefix = "[", postfix = "]"))&#125; 如上面的代码所示，函数joinToString想要打印列表的内容，需要传入四个参数：列表、分隔符、前缀和后缀。由于参数很多，在后续使用该函数的时候不是很直观的知道每个参数是干什么用的，这时候可以显式的标明参数名称，增加代码可读性。 默认参数值同时，定义函数的时候还可以给函数默认的参数，如下所示：1234567891011121314151617181920212223/** 打印列表的内容，带有默认的参数，可以避免java的函数重载* */fun &lt;T&gt; joinToString2(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;/** 测试* */fun printList3() &#123; val list = listOf(2, 4, 0) println(joinToString2(list, " - ")) println(joinToString2(list, " , ", "["))&#125; 这样有了默认参数后，在使用函数时，如果不传入该参数，默认会使用默认的值，这样可以避免Java中大量的函数重载。 @JvmOverloads在java与kotlin的混合项目中，会发现用kotlin实现的带默认参数的函数，在java中去调用的化就不能利用这个特性了，还是需要给所有参数赋值，像下面java这样：123List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2(arr, "-", "", "");System.out.println(res); 这时候可以在kotlin的函数前添加注解@JvmOverloads，添加注解后翻译为class的时候kotlin会帮你去生成多个函数实现函数重载，kotlin代码如下：12345678910111213141516/** 通过注解@JvmOverloads解决java调用kotlin时不支持默认参数的问题* */@JvmOverloadsfun &lt;T&gt; joinToString2New(collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125; 这样以后，java调用kotlin的带默认参数的函数就跟kotlin一样方便了：12345List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;() &#123;&#123;add(2);add(4);add(0);&#125;&#125;;String res = joinToString2New(arr, "-");System.out.println(res);String res2 = joinToString2New(arr, "-", "=&gt;");System.out.println(res2); Tip4-扩展函数和属性回到目录 扩展函数和扩展属性是Kotlin非常方便实用的一个功能，它可以让我们随意的扩展第三方的库，你如果觉得别人给的SDK的Api不好用，或者不能满足你的需求，这时候你可以用扩展函数完全去自定义。 扩展函数例如String类中，我们想获取最后一个字符，String中没有这样的直接函数，你可以用.后声明这样一个扩展函数：详见案例代码KotlinTip41234567891011/** 扩展函数* */fun String.lastChar(): Char = this.get(this.length - 1)/** 测试* */fun testFunExtension() &#123; val str = "test extension fun"; println(str.lastChar())&#125; 这样定义好lastChar()函数后，之后只需要import进来后，就可以用String类直接调用该函数了，跟调用它自己的方法没有区别。这样可以避免重复代码和一些静态工具类，而且代码更加简洁明了。例如我们可以改造上面tip3中的打印列表内容的函数：12345678910111213141516171819/** 用扩展函数改造Tip3中的列表打印内容函数* */fun &lt;T&gt; Collection&lt;T&gt;.joinToString3(separator: String = ", ", prefix: String = "", postfix: String = ""): String &#123; val result = StringBuilder(prefix) for ((index, element) in withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;fun printList4() &#123; val list = listOf(2, 4, 0) println(list.joinToString3("/"))&#125; 扩展属性除了扩展函数，还可以扩展属性，例如我想实现String和StringBuilder通过属性去直接获得最后字符：12345678910111213141516171819202122/** 扩展属性 lastChar获取String的最后一个字符* */val String.lastChar: Char get() = get(length - 1)/** 扩展属性 lastChar获取StringBuilder的最后一个字符* */var StringBuilder.lastChar: Char get() = get(length - 1) set(value: Char) &#123; setCharAt(length - 1, value) &#125;/** 测试* */fun testExtension() &#123; val s = "abc" println(s.lastChar) val sb = StringBuilder("abc") println(sb.lastChar)&#125; 定义好扩展属性后，之后只需import完了就跟使用自己的属性一样方便了。 Why？Kotlin为什么能实现扩展函数和属性这样的特性？在Kotlin中要理解一些语法，只要认识到Kotlin语言最后需要编译为class字节码，Java也是编译为class执行，也就是可以大致理解为Kotlin需要转成Java一样的语法结构，Kotlin就是一种强大的语法糖而已，Java不具备的功能Kotlin也不能越界的。 那Kotlin的扩展函数怎么实现的呢？介绍一种万能的办法去理解Kotlin的语法：将Kotlin代码转化成Java语言去理解，步骤如下： 在Android Studio中选择Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode 这样就把Kotlin转化为class字节码了 class码阅读不太友好，点击左上角的Decompile就转化为Java 再介绍一个小窍门，在前期对Kotlin语法不熟悉的时候，可以先用Java写好代码，再利用AndroidStudio工具将Java代码转化为Kotlin代码，步骤如下： 在Android Studio中选中要转换的Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File 我们看看将上面的扩展函数转成Java后的代码123456789101112131415161718192021/** 扩展函数会转化为一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char lastChar(@NotNull String $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final char getLastChar(@NotNull StringBuilder $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.charAt($receiver.length() - 1);&#125;/** 设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象* */public static final void setLastChar(@NotNull StringBuilder $receiver, char value) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); $receiver.setCharAt($receiver.length() - 1, value);&#125; 查看上面的代码可知：对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象，这样把类的实例传入函数以后，函数内部就可以访问到类的公有方法。对于扩展属性也类似，获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象，设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象。函数内部可以访问公有的方法和属性。顶层的扩展函数是static的，不能被override 从上面转换的源码其实可以看到扩展函数和扩展属性适用的地方和缺陷： 扩展函数和扩展属性内只能访问到类的公有方法和属性，私有的和protected是访问不了的 扩展函数不是真的修改了原来的类，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型，案例代码StaticllyExtension.kt 12345678910111213141516171819202122open class C class D : C() fun C.foo() = "c" fun D.foo() = "d" /** https://kotlinlang.org/docs/reference/extensions.html* Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,* but merely make new functions callable with the dot-notation on variables of this type. Extension functions are* dispatched statically.* */fun printFoo(c: C) &#123; println(c.foo())&#125; fun testStatically() &#123; printFoo(C()) // print c printFoo(D()) // also print c&#125; 上面的案例中即使调用printFoo(D())还是打印出c，而不是d。转成java中会看到下面的代码，D类型在调用的时候会强制转换为C类型： 12345678910111213141516171819public static final String foo(@NotNull C $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "c";&#125; public static final String foo(@NotNull D $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return "d";&#125; public static final void printFoo(@NotNull C c) &#123; Intrinsics.checkParameterIsNotNull(c, "c"); String var1 = foo(c); System.out.println(var1);&#125;public static final void testStatically() &#123; printFoo(new C()); printFoo((C)(new D()));&#125; 声明扩展函数作为类的成员变量 上面的例子扩展函数是作为顶层函数，如果把扩展函数申明为类的成员变量，即扩展函数的作用域就在类的内部有效，案例代码ExtensionsAsMembers.kt123456789101112131415161718192021222324252627282930313233343536open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // call the extension function &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;fun testAsMembers() &#123; C().caller(D()) // prints "D.foo in C" C1().caller(D()) // prints "D.foo in C1" - dispatch receiver is resolved virtually C().caller(D1()) // prints "D.foo in C" - extension receiver is resolved statically C1().caller(D1()) // prints "D.foo in C1"&#125; 函数caller的类型是D，即使调用C().caller(D1())，打印的结果还是D.foo in C，而不是D1.foo in C，不是运行时来动态决定类型，成员扩展函数申明为open，一旦在子类中被override，就调用不到在父类中的扩展函数，在子类中的作用域内的只能访问到override后的函数，不能像普通函数override那样通过super关键字访问了。 下面再举几个扩展函数的例子，让大家感受一下扩展函数的方便：1234567891011121314151617181920212223242526272829303132333435/** show toast in activity* */fun Activity.toast(msg: String) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()&#125;val Context.inputMethodManager: InputMethodManager? get() = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager/** hide soft input* */fun Context.hideSoftInput(view: View) &#123; inputMethodManager?.hideSoftInputFromWindow(view.windowToken, 0)&#125;/** * screen width in pixels */val Context.screenWidth get() = resources.displayMetrics.widthPixels/** * screen height in pixels */val Context.screenHeight get() = resources.displayMetrics.heightPixels/** * returns dip(dp) dimension value in pixels * @param value dp */fun Context.dip2px(value: Int): Int = (value * resources.displayMetrics.density).toInt() Tip5-懒初始化bylazy和延迟初始化lateinit回到目录 懒初始化by lazy懒初始化是指推迟一个变量的初始化时机，变量在使用的时候才去实例化，这样会更加的高效。因为我们通常会遇到这样的情况，一个变量直到使用时才需要被初始化，或者仅仅是它的初始化依赖于某些无法立即获得的上下文。详见案例代码KotlinTip512345678910/** 懒初始化api实例* */val purchasingApi: PurchasingApi by lazy &#123; val retrofit: Retrofit = Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(MoshiConverterFactory.create()) .build() retrofit.create(PurchasingApi::class.java)&#125; 像上面的代码，retrofit生成的api实例会在首次使用到的时候才去实例化。需要注意的是by lazy一般只能修饰val不变的对象，不能修饰var可变对象。12345678class User(var name: String, var age: Int)/** 懒初始化by lazy* */val user1: User by lazy &#123; User("jack", 15)&#125; 延迟初始化lateinit另外，对于var的变量，如果类型是非空的，是必须初始化的，不然编译不通过，这时候需要用到lateinit延迟初始化，使用的时候再去实例化。12345678/** 延迟初始化lateinit* */lateinit var user2: Userfun testLateInit() &#123; user2 = User("Lily", 14)&#125; by lazy 和 lateinit 的区别 by lazy 修饰val的变量 lateinit 修饰var的变量，且变量是非空的类型 Tip6-不用再手写findViewById回到目录 在Activity中使用在Android的View中，会有很多代码是在声明一个View，然后通过findViewById后从xml中实例化赋值给对应的View。在kotlin中可以完全解放出来了，利用kotlin-android-extensions插件，不用再手写findViewById。步骤如下：详见案例代码KotlinTip6 步骤1，在项目的gradle中 apply plugin: ‘kotlin-android-extensions’ 步骤2，按照原来的习惯书写布局xml文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tip6Tv" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/tip6Img" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/tip6Btn" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 步骤3，在java代码中import对应的布局就可以开始使用了，View不用提前声明，插件会自动根据布局的id生成对应的View成员（其实没有生成属性，原理见下面） 123456789101112131415161718192021222324252627import com.sw.kotlin.tips.R/** 导入插件生成的View* */import kotlinx.android.synthetic.main.activity_tip6.*class KotlinTip6 : Activity() &#123; /* * 自动根据layout的id生成对应的view * */ override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_tip6) tip6Tv.text = "Auto find view for TextView" tip6Img.setImageBitmap(null) tip6Btn.setOnClickListener &#123; test() &#125; &#125; private fun test()&#123; tip6Tv.text = "update" &#125;&#125; 像上面代码这样，Activity里的三个View自动生成了，不用再去声明，然后findViewById，然后转型赋值，是不是减少了很多没必要的代码，让代码非常的干净。 Why？原理是什么？插件帮我们做了什么？要看原理还是将上面的代码转为java语言来理解，参照tips4提供的方式转换为如下的java代码：12345678910111213141516171819202122232425262728293031323334353637383940414243public final class KotlinTip6 extends Activity &#123; private HashMap _$_findViewCache; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setContentView(2131296284); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"Auto find view for TextView"); ((ImageView)this._$_findCachedViewById(id.tip6Img)).setImageBitmap((Bitmap)null); ((Button)this._$_findCachedViewById(id.tip6Btn)).setOnClickListener((OnClickListener)(new OnClickListener() &#123; public final void onClick(View it) &#123; KotlinTip6.this.test(); &#125; &#125;)); &#125; private final void test() &#123; TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence) "update"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; var2 = this.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125;&#125; 如上面的代码所示，在编译阶段，插件会帮我们生成视图缓存，视图由一个Hashmap结构的_$_findViewCache变量缓存，会根据对应的id先从缓存里查找，缓存没命中再去真正调用findViewById查找出来，再存在HashMap中。 子View或者include标签中findViewById子子View或者include标签中，同样可以省略findViewById，但需要主要默认的activity的布局import是不会将这个include的View引入进来123456789101112131415&lt;include layout="@layout/layout_tip6"/&gt;//include layout&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/test_inside_id" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/app_name"/&gt;&lt;/FrameLayout&gt; 需要我们引入对应的View的id，像这样import kotlinx.android.synthetic.main.layout_tip6.*123456//导入插件生成的Viewimport kotlinx.android.synthetic.main.activity_tip6.*//include layout的Viewimport kotlinx.android.synthetic.main.layout_tip6.*test_inside_id.text = "Test include" 在Fragment中findViewById在Fragment中也类似，但有一点需要注意但地方，例子如下：12345678910111213141516171819class Tip6Fragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val view = inflater?.inflate(R.layout.fragment_tip6, container, false) /* * 这时候不能在onCreateView方法里用view，需要在onViewCreate里，原理是插件用了getView来findViewById * */ // tip6Tv.text = "test2" return view &#125; /* * 需要在onViewCreate里，原理是插件用了getView来findViewById * */ override fun onViewCreated(view: View?, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) tip6Tv.text = "test" &#125;&#125; 如上所示，Fragment需要注意，不能在onCreateView方法里用view，不然会出现空指针异常，需要在onViewCreate里，原理是插件用了getView来findViewById，我们看看将上面的代码转成java后的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class Tip6Fragment extends Fragment &#123; private HashMap _$_findViewCache; @Nullable public View onCreateView(@Nullable LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater != null?inflater.inflate(2131296286, container, false):null; return view; &#125; public void onViewCreated(@Nullable View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); TextView var10000 = (TextView)this._$_findCachedViewById(id.tip6Tv); Intrinsics.checkExpressionValueIsNotNull(var10000, "tip6Tv"); var10000.setText((CharSequence)"test"); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(Integer.valueOf(var1)); if (var2 == null) &#123; View var10000 = this.getView(); if (var10000 == null) &#123; return null; &#125; var2 = var10000.findViewById(var1); this._$_findViewCache.put(Integer.valueOf(var1), var2); &#125; return var2; &#125; public void _$_clearFindViewByIdCache() &#123; if (this._$_findViewCache != null) &#123; this._$_findViewCache.clear(); &#125; &#125; // $FF: synthetic method public void onDestroyView() &#123; super.onDestroyView(); this._$_clearFindViewByIdCache(); &#125;&#125; 跟Activity中类似，会有一个View的HashMap，关键不同的地方在_$findCachedViewById里面，需要getView获得当前Fragment的View，故在onViewCreated中getView还是空的，原理就好理解了。另外在onDestroyView会调用$_clearFindViewByIdCache方法清掉缓存。 Tip7-利用局部函数抽取重复代码回到目录 局部函数抽取代码Kotlin中提供了函数的嵌套，在函数内部还可以定义新的函数。这样我们可以在函数中嵌套这些提前的函数，来抽取重复代码。如下面的案例所示:详见案例代码KotlinTip71234567891011121314class User(val id: Int, val name: String, val address: String, val email: String)fun saveUser(user: User) &#123; if (user.name.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Name") &#125; if (user.address.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Address") &#125; if (user.email.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty Email") &#125; // save to db ...&#125; 上面的代码在判断name、address等是否为空的处理其实很类似。这时候，我们可以利用在函数内部嵌套的声明一个通用的判空函数将相同的代码抽取到一起：123456789101112131415/** 利用局部函数抽取相同的逻辑，去除重复的代码* */fun saveUser2(user: User) &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $&#123;user.id&#125;: empty $fildName") &#125; &#125; validate(user.name, "Name") validate(user.address, "Address") validate(user.email, "Email") // save to db ...&#125; 扩展函数抽取代码除了利用嵌套函数去抽取，此时，其实也可以用扩展函数来抽取，如下所示：12345678910111213141516171819/** 利用扩展函数抽取逻辑* */fun User.validateAll() &#123; fun validate(value: String, fildName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException("Can't save user $id: empty $fildName") &#125; &#125; validate(name, "Name") validate(address, "Address") validate(email, "Email")&#125;fun saveUser3(user: User) &#123; user.validateAll() // save to db ...&#125; Tip8-使用数据类来快速实现model类回到目录 在java中要声明一个model类需要实现很多的代码，首先需要将变量声明为private，然后需要实现get和set方法，还要实现对应的hashcode equals toString方法等，如下所示：详见案例代码Tip81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static class User &#123; private String name; private int age; private int gender; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + ", address='" + address + '\'' + '&#125;'; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; if (gender != user.gender) return false; if (name != null ? !name.equals(user.name) : user.name != null) return false; return address != null ? address.equals(user.address) : user.address == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; result = 31 * result + gender; result = 31 * result + (address != null ? address.hashCode() : 0); return result; &#125;&#125; 这段代码Java需要70行左右，而如果用kotlin，只需要一行代码就可以做到。123456789/** Kotlin会为类的参数自动实现get set方法* */class User(val name: String, val age: Int, val gender: Int, var address: String)/** 用data关键词来声明一个数据类，除了会自动实现get set，还会自动生成equals hashcode toString* */data class User2(val name: String, val age: Int, val gender: Int, var address: String) 对于Kotlin中的类，会为它的参数自动实现get set方法。而如果加上data关键字，还会自动生成equals hashcode toString。原理其实数据类中的大部分代码都是模版代码，Kotlin聪明的将这个模版代码的实现放在了编译器处理的阶段。 Tip9-用类委托来快速实现装饰器模式回到目录 通过继承的实现容易导致脆弱性，例如如果需要修改其他类的一些行为，这时候Java中的一种策略是采用装饰器模式：创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个成员变量。与原始类拥有相同行为的方法不用修改，只需要直接转发给原始类的实例。如下所示：详见案例代码KotlinTip91234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 常见的装饰器模式，为了修改部分的函数，却需要实现所有的接口函数* */class CountingSet&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; &#123; var objectAdded = 0 override val size: Int get() = innerSet.size /* * 需要修改的方法 * */ override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; /* * 需要修改的方法 * */ override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125; override fun contains(element: T): Boolean &#123; return innerSet.contains(element) &#125; override fun containsAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.containsAll(elements) &#125; override fun isEmpty(): Boolean &#123; return innerSet.isEmpty() &#125; override fun clear() &#123; innerSet.clear() &#125; override fun iterator(): MutableIterator&lt;T&gt; &#123; return innerSet.iterator() &#125; override fun remove(element: T): Boolean &#123; return innerSet.remove(element) &#125; override fun removeAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.removeAll(elements) &#125; override fun retainAll(elements: Collection&lt;T&gt;): Boolean &#123; return innerSet.retainAll(elements) &#125;&#125; 如上所示，想要修改HashSet的某些行为函数add和addAll，需要实现MutableCollection接口的所有方法，将这些方法转发给innerSet去具体的实现。虽然只需要修改其中的两个方法，其他代码都是模版代码。只要是重复的模版代码，Kotlin这种全新的语法糖就会想办法将它放在编译阶段再去生成。这时候可以用到类委托by关键字，如下所示：1234567891011121314151617/** 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了* */class CountingSet2&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123; var objectAdded = 0 override fun add(element: T): Boolean &#123; objectAdded++ return innerSet.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; objectAdded += elements.size return innerSet.addAll(elements) &#125;&#125; 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了，通过类委托将10行代码就可以实现上面接近100行的功能，简洁明了，去掉了模版代码。 Tip10-Lambda表达式简化OnClickListener回到目录 详见案例代码KotlinTip10lambda表达式可以简化我们的代码。以Android中常见的OnClickListener来说明，在Java中我们一般这样设置：1234567TextView textView = new TextView(context);textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // handle click &#125;&#125;); Java中需要声明一个匿名内部类去处理，这种情况可以用lambda表达式来简化。 lambda表达式一般长这样 { x:Int, y:Int -&gt; x+y } 参数 -&gt; 表达式 并且始终在大括号中 it作为默认参数名 lambda捕捉，当捕捉final变量时，它的值和lambda代码一起存储 非final变量，它的值被封装在一个特殊的包装器中，这个包装器的引用会和lambda代码一起存储 我们来看看Kotlin中的例子：12345678910111213141516171819val textView = TextView(context)/** 传统方式* */textView.setOnClickListener(object : android.view.View.OnClickListener &#123; override fun onClick(v: android.view.View?) &#123; // handle click &#125;&#125;)/** lambda的方式* */textView.setOnClickListener(&#123; v -&gt; &#123; // handle click &#125;&#125;) 当lambda的参数没有使用时可以省略，省略的时候用it来替代123456/** lambda的参数如果没有使用可以省略，省略的时候用it来替代* */textView.setOnClickListener(&#123; // handle click&#125;) lambda在参数的最后一个的情况可以将之提出去123456/** lambda在参数的最后一个的情况可以将之提出去* */textView.setOnClickListener() &#123; // handle click&#125; lambda提出去之后，函数如果没有其他参数括号可以省略123456/** lambda提出去之后，函数如果没有其他参数括号可以省略* */textView.setOnClickListener &#123; // handle click&#125; 我们再看看如果自己去实现一个带lambda参数的函数应该怎么去定义：1234567891011121314151617181920212223242526interface OnClickListener &#123; fun onClick()&#125;class View &#123; var listener: OnClickListener? = null; /* * 传统方式 * */ fun setOnClickListener(listener: OnClickListener) &#123; this.listener = listener &#125; fun doSth() &#123; // some case: listener?.onClick() &#125; /* * 声明lambda方式，listener: () -&gt; Unit * */ fun setOnClickListener(listener: () -&gt; Unit) &#123; &#125;&#125; 在函数参数中需要声明lambda的类型后，再调用该函数的时候就可以传入一个lambda表达式了。 Tip11-with函数来简化代码回到目录 with 函数原型： 1inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() with函数并不是扩展函数，返回值是最后一行，可以直接调用对象的方法 Kotlin中可以用with语句来省略同一个变量的多次声明，例如下面的函数详见案例代码KotlinTip11123456789101112/**打印字母表函数，在函数内result变量在好几处有使用到* */fun alphabet(): String &#123; val result = StringBuilder() result.append("START\n") for (letter in 'A'..'Z') &#123; result.append(letter) &#125; result.append("\nEND") return result.toString()&#125; 在上面的函数中，result变量出现了5次，如果用with语句，可以将这5次都不用再出现了，我们来一步一步地看是怎么实现的：1234567891011121314/** 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了* */fun alphabet2(): String &#123; val result = StringBuilder() return with(result) &#123; this.append("START\n") for (letter in 'A'..'Z') &#123; this.append(letter) &#125; this.append("\nEND") this.toString() &#125;&#125; 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了，而且这个this是可以省略的 1234567891011121314/** 通过with语句，将result参数作为参数，在内部this也可以省略掉* */fun alphabet3(): String &#123; val result = StringBuilder() return with(result) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 在内部this省略掉后，现在只有一个result了，这个其实也是没必要的，于是出现了下面的最终版本：12345678910111213/** 通过with语句，可以直接将对象传入，省掉对象的声明* */fun alphabet4(): String &#123; return with(StringBuilder()) &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND") toString() &#125;&#125; 像上面这样，我们可以把同一个变量的显式调用从5次变为0次，发现Kotlin的魅力了吧。 Tip12-apply函数来简化代码回到目录 apply 函数原型： 1inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 除了用上面的with可以简化同一个变量的多次声明，还可以用apply关键字，我们来改造一下tip11中的函数：详见案例代码KotlinTip1212345678910/** 用apply语句简化代码，在apply的大括号里可以访问类的公有属性和方法* */fun alphabet5() = StringBuilder().apply &#123; append("START\n") for (letter in 'A'..'Z') &#123; append(letter) &#125; append("\nEND")&#125;.toString() 像上面这样的，通过apply后，在apply的大括号里可以访问类的公有属性和方法。这在对应类的初始化是非常方便的，例如下面的例子12345678910111213141516171819202122/** 用apply语句简化类的初始化，在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁* */fun testApply(context: Context) &#123; var imgView = ImageView(context).apply &#123; setBackgroundColor(0) setImageBitmap(null) &#125; var textView = TextView(context).apply &#123; text = "content" textSize = 20.0f setPadding(10, 0, 0, 0) &#125; var user = User().apply &#123; age = 15 name = "Jack" val a = address address = "bbb" &#125;&#125; 在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁 Tip13-在编译阶段避免掉NullPointerException回到目录 可空类型和不可空类型NullPointerException是Java程序员非常头痛的一个问题，我们知道Java 中分受检异常和非受检异常，NullPointerException是非受检异常，也就是说NullPointerException不需要显示的去catch住，往往在运行期间，程序就可能报出一个NullPointerException然后crash掉，Kotlin作为一门高效安全的语言，它尝试在编译阶段就把空指针问题显式的检测出来，把问题留在了编译阶段，让程序更加健壮。详见案例代码KotlinTip13 Kotlin中类型分为可空类型和不可空类型，通过？代表可空，不带？代表不可为空 123456789101112131415161718192021fun testNullType() &#123; val a: String = "aa" /* * a是非空类型，下面的给a赋值为null将会编译不通过 * */ // a = null a.length /* * ？声明是可空类型，可以赋值为null * */ var b: String? = "bb" b = null /* * b是可空类型，直接访问可空类型将编译不通过，需要通过?.或者!!.来访问 * */ // b.length b?.length b!!.length&#125; 对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过 对于一个可空类型：通过？声明，在访问该类型的时候直接访问不能编译通过，需要通过?.或者!!. ?. 代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性 !!. 代表着如果该类型为空的话就抛出NullPointerException，如果不为空就去访问对应的方法或者属性，所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出NullPointerException。而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了：12345/** 不推荐这样的写法：链式的连续用!!.* */val user = User()user!!.name!!.subSequence(0,5)!!.length 对应一个可空类型，每次对它的访问都需要带上?.判断12345678val user: User? = User() /* * 每次访问都用用?.判断 * */ user?.name user?.age user?.toString() 但这样多了很多代码，kotlin做了一些优化，12345678/** 或者提前判断是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了* */if (user != null) &#123; user.name user.age user.toString()&#125; 通过if提前判断类型是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了。 let语句简化对可空对象对访问 let 函数原型： 1inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) let函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。 上面的代码还可以用?.let语句进行，如下所示：12345678/** 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作* */user?.let &#123; it.name it.age it.toString()&#125; 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作 Elvis操作符 ?: 简化对空值的处理如果值可能为空，对空值的处理可能会比较麻烦，像下面这样：123456789101112131415161718/** 对空值的处理* */fun testElvis(input: String?, user: User?) &#123; val a: Int? if (input == null) &#123; a = -1 &#125; else &#123; a = input?.length &#125; if (user == null) &#123; var newOne = User() newOne.save() &#125; else &#123; user.save() &#125;&#125; Elvis操作符?:能够简化上面的操作，?:符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟?.let正好相反，例如我们可以用两行代码来简化上面从操作：1234567/** * Elvis操作符 ?: 简化对空值的处理 */fun testElvis2(input: String?, user: User?) &#123; val b = input?.length ?: -1; user?.save() ?: User().save()&#125; Tip14-运算符重载回到目录 Kotlin支持对运算符的重载，这对于对一些对象的操作更加灵活直观。 使用operator来修饰plus\minus函数 可重载的二元算术符 A * B times A / B div A % B mod A + B plus A - B minus 以下面对坐标点Point的案例说明怎么去重载运算符：详见案例代码KotlinTip14123456789101112131415161718192021class Point(val x: Int, val y: Int) &#123; /* * plus函数重载对Point对象的加法运算符 * */ operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125; /* * minus函数重载对Point对象的减法运算符 * */ operator fun minus(other: Point): Point &#123; return Point(x - other.x, y - other.y) &#125; override fun toString(): String &#123; return "[x:$x, y:$y]" &#125;&#125; 如上所示，通过plus函数重载对Point对象的加法运算符，通过minus函数重载对Point对象的减法运算符，然后就可以用+、-号对两个对象进行操作了：1234567fun testOperator() &#123; val point1 = Point(10, 10) val point2 = Point(4, 4) val point3 = point1 + point2 println(point3) println(point1 - point2)&#125; Tip15-高阶函数简化代码回到目录 高阶函数：以另一个函数作为参数或者返回值的函数 函数类型 (Int, String) -&gt; Unit 参数类型-&gt;返回类型 Unit不能省略 1234567891011121314val list = listOf(2, 5, 10)/** 传入函数来过滤* */println(list.filter &#123; it &gt; 4 &#125;) /** 定义函数类型* */val sum = &#123; x: Int, y: Int -&gt; x + y &#125;val action = &#123; println(42) &#125;val sum2: (Int, Int) -&gt; Int = &#123; x: Int, y: Int -&gt; x + y &#125;val action2: () -&gt; Unit = &#123; println(42) &#125; 函数作为参数函数作为参数，即高阶函数中，函数的参数可以是一个函数类型，例如要定义一个函数，该函数根据传入的操作函数来对2和3做相应的处理。详见案例代码KotlinTip15 123456789101112/** 定义对2和3的操作函数* */fun twoAndThree(operator: (Int, Int) -&gt; Int) &#123; val result = operator(2, 3) println("Result:$result")&#125;fun test03() &#123; twoAndThree &#123; a, b -&gt; a + b &#125; twoAndThree &#123; a, b -&gt; a * b &#125;&#125; operator是函数类型，函数的具体类型为(Int, Int) -&gt; Int，即输入两个Int返回一个Int值。定义完了后就可以像上面这样使用了。再举一个例子，实现String类的字符过滤：123456789101112131415/** 函数作为参数，实现String类的字符过滤* */fun String.filter(predicate: (Char) -&gt; Boolean): String &#123; val sb = StringBuilder() for (index in 0 until length) &#123; val element = get(index) if (predicate(element)) sb.append(element) &#125; return sb.toString()&#125;fun test04() &#123; println("12eafsfsfdbzzsa".filter &#123; it in 'a'..'f' &#125;)&#125; 像上面这样predicate是函数类型，它会根据传入的char来判断得到一个Boolean值。 函数作为返回值函数作为返回值也非常实用，例如我们的需求是根据不同的快递类型返回不同计价公式，普通快递和高级快递的计价规则不一样，这时候我们可以将计价规则函数作为返回值： 1234567891011121314151617181920enum class Delivery &#123; STANDARD, EXPEDITED&#125;/** 根据不同的运输类型返回不同的快递方式* */fun getShippingCostCalculator(delivery: Delivery): (Int) -&gt; Double &#123; if (delivery == Delivery.EXPEDITED) &#123; return &#123; 6 + 2.1 * it &#125; &#125; return &#123; 1.3 * it &#125;&#125;fun test05() &#123; val calculator1 = getShippingCostCalculator(Delivery.EXPEDITED) val calculator2 = getShippingCostCalculator(Delivery.STANDARD) println("Ex costs $&#123;calculator1(5)&#125;") println("St costs $&#123;calculator2(5)&#125;")&#125; 如果是普通快递，采用1.3 it的规则计算价格，如果是高级快递按照6 + 2.1 it计算价格，根据不同的类型返回不同的计价函数。 Tip16-用Lambda来简化策略模式回到目录 策略模式是常见的模式之一，java的例子如下。详见案例代码Tip1612345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 定义策略接口 */ public interface Strategy &#123; void doSth(); &#125; /** * A策略 */ public static class AStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do A Strategy"); &#125; &#125; /** * B策略 */ public static class BStrategy implements Strategy &#123; @Override public void doSth() &#123; System.out.println("Do B Strategy"); &#125; &#125; /** * 策略实施者 */ public static class Worker &#123; private Strategy strategy; public Worker(Strategy strategy) &#123; this.strategy = strategy; &#125; public void work() &#123; System.out.println("START"); if (strategy != null) &#123; strategy.doSth(); &#125; System.out.println("END"); &#125; &#125; 如上面的例子所示，有A、B两种策略，Worker根据不同的策略做不同的工作，使用策略时：1234Worker worker1 = new Worker(new AStrategy());Worker worker2 = new Worker(new BStrategy());worker1.work();worker2.work(); 在java中实现这种策略模式难免需要先定义好策略的接口，然后根据接口实现不同的策略，在Kotlin中完全可以用用Lambda来简化策略模式，上面的例子用Kotlin实现：1234567891011121314151617181920212223242526/** * 策略实施者 * @param strategy lambda类型的策略 */class Worker(private val strategy: () -&gt; Unit) &#123; fun work() &#123; println("START") strategy.invoke() println("END") &#125;&#125;/** 测试* */fun testStrategy() &#123; val worker1 = Worker(&#123; println("Do A Strategy") &#125;) val bStrategy = &#123; println("Do B Strategy") &#125; val worker2 = Worker(bStrategy) worker1.work() worker2.work()&#125; 不需要先定义策略的接口，直接把策略以lambda表达式的形式传进来就行了。 参考文档 《Kotlin in Action》 https://kotlinlang.org/docs/reference/ https://savvyapps.com/blog/kotlin-tips-android-development]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒冬将至，Android的出路]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%AF%92%E5%86%AC%E5%B7%B2%E8%87%B3%EF%BC%8CAndroid%E7%9A%84%E5%87%BA%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。 Android开发的天花板很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。 再说职业上，确实Android应用开发很难升任CTO，一般的CTO主要是后端，这主要是两个原因：后端的技术栈很早就成熟了，我8年前转做Android开发时，那帮30多岁的Java开发就已经很厉害了，随着时间的推移，后端技术大牛远比Android大牛的人数要多，也更厉害，他们做技术经理时，我们都还在搬砖； 后端确实可以统筹全局，在公司业务上属于重要地位。 不过我们忽略了最重要的一点，如果我们是做后端的，一定能做到CTO吗？我想也是很难的，所以不要眼睛只盯着高处，先想想自己能达到什么程度，站在半山腰就说山下面的风景不开阔本身也不合理啊。 是否要转行Android不热门了，很多Android开发已经转行了，有的正走在转行的路上，还有的迟疑不决，到底要不要转呢？我们来分析下。 转什么好每个人的自身情况不同，转的方向也会有所区别，转人工智能相关开发肯定是最好的，毕竟风口上的猪也能飞，跟着风口无可厚非。只可惜人工智能相关对学历和算法要求很高，最起码得是个硕士吧，而且这只是低配。那么大多数Android开发可以转的方向主要有前端、后端和Python等等。我大概说一下： 转前端，这个是我认为最好转的一个方向，前端的理念很多都和Android类似，也可以作为Android的延伸，向大前端发展，如果对界面感兴趣的可以转前端试试。 转后端，后端这个就是完全的转行了，看似Java大家都会，但是后端的技术栈可不是只有Java，各种框架绝对叫你头大，很多人强调后端技术深，各种处理高并发看似十分有技术含量，不过这只是为数不多的公司在做。如果想要稳定的可以转后端试试。 转Python，Python最近真是很火，因为他跟人工智能发生了关联，其实大部分学Python的没有搞什么人工智能相关，基本都是在搞爬虫。追求浪潮的可以转Python试试。 不要轻易转行，要转就早点转转行有两种我认为是正常的，一种是行业消失或者没落了，个人无法施展才华。另一种是兴趣不在本行，因此转一个自己感兴趣的。而现在大部分转行纯属是为了跟风，为了那点钱，而忽略了长期的发展。我们来看看下面的图。 从图中可以看出，大部分人在35岁前是在加速期，35岁后是上升或者衰落期。以Android开发转前端来说，假设一个Android高级A同学转行前端会变为前端初级，这时从事前端的人都在加速提高，A同学要想赶超前面的拥有同样加速度的人是不可能办到的，这就导致他在转行前期极为被动，A同学还要保证在35岁前成为前端专家或者Leader才有可能在35岁后不进入衰落期，当然这时A同学的Android基本也就荒废了，很难成为专家。如果还想要在技术领域走的更远，就不要轻易的进行转行，如果想要转越早越好，越快越好，因为其他的竞争者都在加速提高，没人会停下等你的。 转行大部分都不是质变一个开发的质变可以理解为在一个领域的大幅提升，或者是不相关领域的跨界，举个例子：可以在Android领域由高级质变为了专家，或者是由一个高级开发升到了Leader，再或者跨界开始做了一些技术相关的培训、演讲、出书等等而被人所熟知。凡是能帮助35岁后进入上升期的都可以看做是一次质变，而转行很少是质变，更多的是倒退回到原点重新出发，形象点来说，就是换了个不同的砖头接着搬砖而已（高技术含量的除外）。因此我们更应该去追求质变，而不是平行或者倒退，一次倒退可以承受，多次倒退就很难在35岁后进入上升期。 如何提升竞争力选择一个细分领域Android现在细分的领域非常多，前面说到的有应用开发、逆向安全、音视频、车联网、物联网、手机开发、SDK开发和智能电视盒子开发等等，在这些领域中选择一个并不断深入。比如音视频，在8年前我刚入门Android时，音视频就是闷声发大财了（PC端），工资高的令人乍舌，现在在移动端，音视频更是青出于蓝，是一个非常好的选择，如果想要入门可以看看何俊林《Android音视频开发》。 尽量学习半衰期长的知识知识半衰期指的是：随着知识更新周期变短，知识裂变速度加快，一个知识落伍的周期。知识半衰期长的职业都是越老越值钱的，比如英语老师和外科医生，知识更新慢并且几乎不会落伍。这一点我们程序员是绝对比不了的，我们的大部分知识半衰期是比较短的，一个框架短短几年可能就会被淘汰，这也导致程序员需要不断的学习新知识，而我们每个人的时间和精力是有限的，那么根据知识半衰期，有策略的进行学习就变得尤为重要。（这个观点很有吸引力） 上面的半衰期图不完全准确，但是却值得参考，如果你是其他的技术领域也可以参考这个半衰期图。这个图不是告诉我们不要去学RN和小程序，而是结合自身工作尽量学习半衰期长的知识。 做减法，尽量专精一门技术现在的社会，技术分工越来越细，越细就意味着大部分企业（小作坊除外）需要专精的人才（最好是精通一门通多门）。你会发现身边脱颖而出的技术人大多都是靠一门技术，却很少看到会一堆技术却都不精通的冒出来。好比在武侠的世界，高手对决都在同一个时间段拿出看家武学，如果看家武学都不精，分分钟被虐，剩下的武学也无需拿出来献丑了。联想到现实版本就是去大公司面试Android，结果Android技术了解不深，被各种虐，剩下的前端技术、后端技术、Python什么的，面试官也没兴趣了解了。 所以并不是你会的技术越多越好，一定要做好减法，先专精一门，然后再去学别的技术。（值得借鉴） 说说最近Android火热的技术Android相关的火热技术最近几年也是频出，没事就在刷屏，我来说说对这些火热技术的看法。 Kotlin，从知识的半衰期来看，这门语言非常值得学习，不过想要普及还是非常难，因为Kotlin还没有表现出非用它不可的竞争力，另外很多企业使用的成本比较高，大多数领导都是不求有功但求无过，不会下力气推广。 Flutter，从知识的半衰期来看，这个框架存在的时间相对不会长，目前也就一些有技术储备的公司去试验去尝试，如果自己公司技术储备不够，就贸然当小白鼠显然不是很明智。 这两个技术都建议大家来学习，但不要指望它们会给你增加什么太大竞争力，李四1周能学会，张三同样也能。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>规划</tag>
        <tag>半衰期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序之CSS入门]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[详解css中的display属性（行内元素和块级元素） 首先，所有主流浏览器都支持display属性。其次，display属性规定了元素应该生成的框的类型。默认值：inline 我们常用的display属性有： inline block inlien-block none 把display设置成none就不会保留元素本该显示的空间（元素直接不显示），但是visibility：hidden会保留。那么其他三个有什么区别呢？看下下面css代码： 1234567891011&lt;body&gt;&lt;span class=&quot;inline&quot;&gt;inline&lt;/span&gt;inline &lt;span class=&quot;block&quot;&gt;block&lt;/span&gt;block &lt;span class=&quot;inline-block&quot;&gt;inline-block&lt;/span&gt; inline-block&lt;/body&gt; 点此看效果 inline特性我们发现内联对象inline给它设置属性height和width是没用的，致使它变宽变大的原因是： 内部元素的宽高‘+padding’。观察inline对象的前后元素我们会发现inline不单独占一行，其他元素会紧跟其后。 block特性 而块对象‘block’是可以设置宽高的，但是它的实际宽高是本身宽高+’padding‘。观察block的前后元素，我们会发现block会独占一行。 如果，我们即希望div有宽高，又不希望它独占一行要怎么办？ inline-block这个时候我们就需要’inline-block‘属性了，我们看下显示效果，就会发现： inline-block即具有block的宽高特性又具有inline的同行元素特性。 也就是说，当我们想让一个元素即不独占一行，又可以设置其宽高属性的时候，我们就可以选择inline-block了。 行内元素特点 和其他元素都在一行上； 元素的高度，宽度，行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素特点 每个块级元素都是从新的一行开始，并且其后的元素也另起一行； 元素的高度，宽度，行高及顶部和底部边距都是可以设置的； 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素一致），除非设定一个宽度。 在html中，span,a,lable,input,img,strong和em就是典型的行内元素。div,p,h1,form,ul,li就是块级元素。 块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 更多CSS display请参考]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>CSS</tag>
        <tag>小程序</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程中的TCP和UDP通信方式简介]]></title>
    <url>%2F2018%2F11%2F03%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code） TCP方式和UDP的区别 TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现 UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现 ### 网络协议简介通过上图知道不管是TCP还是UDP都是互联网络协议中的一层—传输层协议。 图中简单对网络协议做了分层，金典的网络协议是四层，这里给了不同的四层。 最底层的以太网协议规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信，但是以太网协议不能解决多个局域网如何互通，这由IP协议解决（IP协议可以连接多个局域网） IP协议定义了一套自己的地址规则，成为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息（路由器就是基于IP协议，局域网之间靠路由器连接）。 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入很多根网线，路由器内部有一张路由表，规定了A段IP地址走出口一，B段IP地址走出口二。…通过这套指路牌，实现了数据包的转发。 IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要靠TCP协议了。 TCP协议具体的TCP协议可能是一本书的内容，这里管中窥豹一下。简单来说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 原来，我们只是简单知道TCP协议的七次==连接==，三挥四别，这里我们来完整了解下他其中的原理。 TCP数据包大小以太网数据包（pakage）的大小是固定的，最初是1518字节，后来增加到了1522字节。其中，1500字节是负载（payload），22字节是头信息（head）。IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少20字节，所以IP数据包的负载最多1480字节，TCP数据包在IP数据包的负载里面，TCP的头也要占20字节，因此TCP数据包最大负载1460字节。由于，IP和TCP协议往往还有额外的头信心，所以TCP实际负载为1400字节左右，下图会清晰的表明这种关系： 因此，一条1500字节的信息需要两个TCP数据包来承载发送。==HTTP/2协议==的一大改进就是压缩了HTTP协议的头信息，使得一个HTTP请求可以放在一个TCP数据包里面，而不是分成多个，这样就提高了传输速度。 TCP数据包的编号（SEQ）一个包1400字节，那么发送一个10M大小的数据包，需要发送7100多个包，发送的时候，TCP协议会给每个包编号，一边接收方按照顺序还原，万一发生丢包，也可以知道丢失的是哪个包。一般第一个包编号是随机的。假设我们叫第一个包编号为1号包，这个包负载100字节，那么可以推算出下一个包的编号应该是101，就是说，每个数据包都可以得到两个编号：一个自身的编号，及下一个数据包的编号。几首方由此知道，应该按照什么顺序将他们还原成原始文件。（可以用抓包工具抓来看） TCP数据包的组装收到TCP数据包以后，由操作系统来完成组装操作，应用程序是不会直接处理TCP数据包的，而是处理由他封装的例如HTTP协议的数据包。对应用程序来说，不用关心数据通信的细节，应用程序需要的数据放在了TCP数据包里面，有自己的格式（比如常见的HTTP协议），TCP不能标识原始文件大小，这个只能由应用层协议来规定，如HTTP头COntent-length，表示了信息体的大小。对于操作系统来说，就是持续的接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据，一旦组装好TCP数据包，就把他们交给引用程序（怎么组装呢？？），TCP数据包里面有个端口（port）就是用来指定转交给监听该端口的应用程序。 如上图：系统根据TCP数据包中端口，将组装好的数据转交给相应的应用程序。如21端口是FTP服务器，25端口是SMTP（邮件协议）服务，80是Web服务器（常用的Http请求）。这些一般都是在服务端的。 慢启动和ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。==TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。==（NB）。Linux 内核里面设定了（常量==TCP_INIT_CWND==），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 期待要收到下一个数据包的编号。 接收方的接收窗口剩余容量 （图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。） 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 数据包的遗失处理丢包时有发生，TCP的可靠性是怎么保证的呢？简单来说：由于每一数据包都带有编号，如有下一个数据包没收到，那么ACK的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。==这会导致大量重复内容的 ACK==。如果发送方发现收到了==三个==连续重复的ACK，或者超时没收到任何ACK，就会确认丢包了，及5号包丢了，从而再次发送这个包，通过这种机制，TCP保证了不会有数据包丢失。==（好像TCP会丢包的）== 。下图比较形象说明了这个例子： （图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。） TCP连接 Java的TCP实现（Socket）123456789101112131415161718192021public void client() throws Exception &#123; // InetAddress.getLocalHost()为客户端请求连接的主机号，此处设置为本地主机，服务进程的端口号是8090 // 主机号和端口号唯一确定了唯一主机上面的唯一进程。 Socket socket = new Socket(InetAddress.getLocalHost(), 8090); // socket.getOutputStream()获得输出流，通过输出流像主机发送数据。 OutputStream os = socket.getOutputStream(); os.write("黑猫呼叫白猫收到请回复!".getBytes()); // 关闭数据输出，如果不关闭的话服务端并不知道数据传输已经结束还会一直等待。 socket.shutdownOutput(); // 接收server端发送的数据 InputStream is = socket.getInputStream(); int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; is.close(); os.close(); socket.close(); &#125; 123456789101112131415161718192021222324public void server() throws Exception &#123; // 给服务端一个端口号8090使得客户端可以连接。 ServerSocket ss = new ServerSocket(8090); // 接受客户端的连接 Socket socket = ss.accept(); // 获得客户端的输入流 InputStream is = socket.getInputStream(); // 输出client端发送的数据 int len = 0; byte[] b = new byte[1024]; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.println(str); &#125; OutputStream os = socket.getOutputStream(); // 通过输出流向客户端发送数据。 os.write("黑猫这里是白猫，我已收到你的呼叫!".getBytes()); os.close(); // socket.shutdownOutput(); is.close(); socket.close(); ss.close(); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+Github搭建个人Blog]]></title>
    <url>%2F2018%2F10%2F24%2FHEXO%2BGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog%2F</url>
    <content type="text"><![CDATA[HEXO背景hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面 超快部署 支持MarkDown 一键部署 丰富的插件 下面以我的Blog为例，记录搭建过程。 环境准备 安装NodeJs 123456789//mac下安装node很简单，使用mac下的包管理工具brew命令就可以了$ brew install node$ brew install npm//brew一般被安装在/usr/local/bin 目录下面//验证是否安装成功$ node -v 安装HEXO 1$ npm install hexo-cli -g 运行 装上Hexo后就可以在本地跑服务了，执行一下命令（HEXO的常见命令） 1234567$ hexo clean// 生成静态网页$ hexo g / hexo generator// 开启服务$ hexo s / hexo server运行：localhost：4000 托管托管就是将你生成的静态网页保存在服务器上，别人可以通过域名去访问（当然需要在hexo上去配置）. 一般是在github上免费托管，也可以自己去买个小鸡，既可以搭个小机场，也可以托管博客. 如果要部署到github上，首先要有GitHub账号（没有的可以不用看了），然后在仓库建一个”github账号.github.io” 名字一定要一样 添加部署插件hexo-deployer-git 1$ npm install hexo-deployer-git --save 添加git源 1234567// 编辑根目录.config.ymlvim .config.ymldeploy: type: git repo: &lt;repository url&gt; branch: [branch] branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址 添加源后就可以部署了 1$ hexo d 配置全局配置关于hexo的配置都在根目录下的.config_yml下面，而关于主题的配置都在/theme/**/.config_yml下面，详细配置可以查看官方文档 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言 theme -&gt; 主题配置（主题名字 /theme目录下） 坑：进行配置时，需要在冒号:后加一个英文空格 主题配置Hexo 中有很多主题，可以在官网查看。主题现在比较流行的是Next — hexo-theme-next。 下载：推荐去官方看最新下载。 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 设置主要是在theme/next/_config.yml文件。然后去找官方或者别人的方案修改即可。 发布文章 使用命令：1$ hexo new test 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 直接将写好的markdown文件放在_posts文件下面即可，在markdown下添加头部 1234---title: categories: []--- 使用命令查看效果 12$ hexo g$ hexo s 主题美化主题美化借鉴了一些前人的集思广益，参考了网上许多文章教程，本博客就是实践出来的，感谢！ 这里mark一些借鉴连接，供大家详参！ Hexo主题美化 干货 Hexo官网]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android存储]]></title>
    <url>%2F2018%2F10%2F22%2FAndroid%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[Android存储路径先来看一张大图： 内部存储 Environment.getDataDirectory().getParentFile();也就是根目录，一般就是指/data/data目录下的数据，需要root之后可以看见 /data/app 该文件存放着系统中安装的第三方应用apk Android的应用安装就是将应用安装包拷贝到/data/app目录下面，每个包本质是一个zip压缩文件。为了提升启动效率，Android会将解压的dex提取出来，缓存在/data/dalvik-cache目录下 api 路径 getDataDirectory() /data getDownloadCacheDirectory() /cache getRootDirectory() /system /data/data 该文件夹存放存储包==私有数据==，对于设备中每一个安装的App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除data/data目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类： 地址 说明 api data/data/包名/cache 存放缓存信息 context.getCacheDir() data/data/包名/database APP数据库信息 context.getDataDir() / context.getDatabasePath(name) data/data/包名/files 存放APP的文件信息 context.getFilesDir() 外部存储每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。 获取外部存储路径及状态 Environment.getExternalStorageState() Environment.getExternalStorageDirectory() 公共目录 Android在外部存储上提供了十个公共目录来存储对应的文件，通过api：Environment.getExternalStoragePublicDirectory(type)来访问 名称 地址 DIRECTORY_MUSIC /storage/emulated/0/Music DIRECTORY_PODCASTS /storage/emulated/0/Podcasts DIRECTORY_RINGTONES /storage/emulated/0/Ringtones DIRECTORY_ALARMS /storage/emulated/0/Alarms DIRECTORY_NOTIFICATIONS /storage/emulated/0/Notifications DIRECTORY_PICTURES /storage/emulated/0/Pictures DIRECTORY_MOVIES /storage/emulated/0/Movies DIRECTORY_DOWNLOADS /storage/emulated/0/Downloads DIRECTORY_DCIM /storage/emulated/0/Dcim DIRECTORY_DOCUMENTS /storage/emulated/0/Documents 3. 私有目录 Android2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。==与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。====和内部存储一样，会在 SD 卡的 Android/data ++目录下生成对应包名的文件夹++== 地址 api /storage/emulated/0/Android/data/应用包名/files context.getExternalFilesDir(type) /storage/emulated/0/Android/data/应用包名/cache context.getExternalCacheDir() /storage/emulated/0/Android/obb/应用包名 context.getObbDir() Android其它目录 /system/app 和 /data/app 的区别 /data/app 里软件权限没全开，/system/app 里的软件获取了所有权限 /data/app 可以应用卸载，/system/app 只能 root 后删除 /data/app 文件夹大小随便，/system/app 文件夹有大小限制 卸载/system/app 目录下的文件并不会增加系统空间，即可用 ROM 空间]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维的误区-幸存者偏见]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%80%9D%E7%BB%B4%E7%9A%84%E8%AF%AF%E5%8C%BA-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81%20%2F</url>
    <content type="text"><![CDATA[何为“幸存者偏见” “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。 &emsp;&emsp;&emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下： 有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？ 不同领域中的“幸存者偏见”西赛罗的那个故事，属于宗教领域的“幸存者偏见”。除了宗教领域，还有很多领域（甚至可以说，所有的领域）都会存在这类偏见。下面，俺挑选几个领域来举例。 IT 领域——创业的“银弹” &emsp;&emsp;&emsp;作为 IT 从业人员，俺经常在某些 IT 网站上看到某某公司的创业事迹。如果你也跟俺一样，估计这方面的故事也看了不少。 &emsp;&emsp;&emsp;不知你有没有发现，那些广为流传的创业案例，都是【成功】案例。越成功的，越具有传奇色彩，被宣传的次数就越多（比如乔布斯、盖茨）。相反，那些创业【失败】的案例，（相比而言）被提及的次数非常非常少。 &emsp;&emsp;&emsp;这会产生啥问题捏？ &emsp;&emsp;&emsp;假设某个有志青年想要创业，他看了很多创业成功的案例，这些案例都提到某些共同的因素。于是捏，此人就误以为这些共同的因素是“银弹”——只要具备这些银弹，创业必定成功。这就如同西赛罗的那个故事——只看到存活的祈祷者，就误以为“祈祷”是存活的【充分条件】。 成功学领域——虚假的“充分条件” &emsp;&emsp;&emsp;说完“创业”，很自然就联想到“成功学”。那些鼓吹“成功学”的文章/书籍，通常存在很多谬误，其中一个谬误是——号称“某某方法论”是成功的【充分条件】。换句话说，只要具备了该方法论，就一定可以获得成功。 &emsp;&emsp;&emsp;为啥俺说这是一个谬误捏？因为这些鼓吹成功学的文章/书籍，通常都【没有】去检验：该方法论是否也出现在失败者身上。只要有一个失败者也采用了该方法论，就足以说明——这个方法论【不是】成功的充分条件。比如说，很多成功学的理论提到了“勤奋”是成功的充分条件。但其实捏，勤奋而没有成功的，大有人在。 投资领域——仅凭运气的“股神” 最近半年，天朝股市迎来新一轮的牛市行情。前几天有读者建议俺聊聊股市的话题，所以今天顺便拿投资领域来说事儿。似乎在每一个国家的股市中，都有那么几个人被誉为“股神”。如果碰到牛市，被冠以“股神”的人还会再多出好几倍。（暂且【不】考虑“弄虚作假、谎报战绩”的情况）假设这些获得股神称号的人，都在实际操作过程中获得远高于大盘的收益率，他们有资格获得“股神”的称号吗？为了说明这个例子，俺转载某篇文章的其中一段（此文写于1984年）。 我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。 “幸存者偏见”导致的问题 错误的认知 这个最好理解了——由于“错误的认知”会导致你对“沉默证据”的忽视，所以你对该领域的认知是不完全的。 错误的归因 在【只看到】“显式样本”的情况下，你可能会产生一些错误的归因。“幸存者偏见”导致的“错误归因”会有很多种。俺这里仅举几个例子。 因果倒置 想必大伙儿都看过举重比赛。对于举重运动员，很多人都有一个错误的观点——以为这些运动员是在练习举重之后，才导致身材变得矮壮。但实际上捏，举重队在一开始筛选运动员的时候，就把那些身材细长的忽略掉了（这些身材细长的候选人，就是“沉默的样本”）。换句话说，是因为他们身材矮壮，才有可能被选中去参加举重培训，而不是因为参加举重培训导致身材如此——这就是【因果倒置】。 牵强的归因（无中生有） 假设某个赌徒去赌场玩“押大小”（此游戏的胜负概率皆为 50%），连续赢了10次。对于大型赌场，每天来玩的人足够多，那么一段时间之后，总会出现某个赌徒玩“押大小”连续赢10次（甚至更多次）。从概率学的角度讲，这是很普通的。但是对该赌徒而言，如果他陷入了“幸存者偏见”这个误区，他就会企图给这个现象找到一个解释（进行“归因”）。假如此人是个宗教信徒，他/她可能会断言——有神明相助。这就属于“牵强的归因”——把【随机事件】看作是有其它原因，并企图在随机性之外寻找一个解释。 错误的决策 还以刚才赌徒的例子来说事儿。假设这个赌徒是宗教信徒，并且误以为自己连续赢10次是神明相助，那么他/她就会获得一种【虚假的信心】，并在这个“虚假信心”的支持下继续玩，甚至还会加大赌注/筹码。最后的结局很可能是——彻底输光。这就是“幸存者偏见”导致的“错误决策”。如果你比较喜欢琢磨，可以把这个赌场的例子替换成天朝的牛市，你会发现其中有某些相通之处。 如何对付“幸存者偏见”？ 意识到“沉默证据”的存在 这是最起码的一点——你首先要能意识到“沉默证据”的存在。这说起来容易，做起来很难——你需要形成这样一种思维习惯：每当看到“显式的证据”，你都要在内心反问：是否存在与之对应的“隐式证据”？ 找到不同类型、不同层次的“沉默证据” 在前一条的基础上，你如果能找到“沉默的证据/隐式的证据”，自然就会获得更全面的认知。有必要提醒一下：“隐式的证据”有时候不止一种类型。碰到这种情况，不是每个人都能想到所有的类型。前面提到的“天朝舆论”的例子。那些思考问题不够深入的同学，通常只意识到“网管审查/删贴”导致的“沉默证据”，而忽略了更隐蔽的“沉默证据”——那些连上网条件都没有的人，是无法在网上表达不满的。 决定一个样本会成为“隐式样本”or“显式样本”，有两种可能：情况A至少有一个原因在起作用（比如前面提到“莎草纸的例子”，气候是原因之一）情况B根本就【没有任何原因】（比如前面提到的“抛硬币的猩猩”），仅仅是随机性决定了某个样本会成为“显式” or “隐式”。对此种情况，如果你非要去找出一个原因，就会出现前面提到的“牵强的归因”。 如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。具体该如何排除捏？在本文的最后，咱们重新回到本文开头提到的那篇巴菲特演讲。在说完“猩猩抛硬币”的游戏之后，巴菲特又说了如下一段话。通过这段话，你可以借鉴一下——如何规避“随机因素”的干扰。 然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；(b)如果经过20天的竞赛，只剩下215只赢家；(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。 于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。 科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。 除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。 在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。 我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>好文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下全局翻墙]]></title>
    <url>%2F2018%2F10%2F20%2FMac%E4%B8%8B%E7%9A%84%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mac下全局翻墙 路由翻墙 ssr + .bash_profile 使用工具，类似profixer，surge等 使用iterm的，环境变量也可以使用.bash的(需要在.zsh中去设置环境变量走.bash_profile)也可以在.zshrc中 由于ss或者ssr只是支持了socks5的代理，也就是所有的都走socks5协议，而浏览器本身是支持socks5的（当然还有http，https，ftp等），但是如果你想mac上装的客户端，比如telegram也能通过ssr达到科学上网就想多了，但是这些软件，还比如AS都可以手动去设置代理的（socks5），一般ssr默认的设置如下： 123ip：127.0.0.1# http走的是1087端口port：1086 方法2设置步骤 vimb(vim .bash_profile) 修改文件（添加下面代码） source .bash_profile 验证：curl www.google.com 12345# proxyproxy=socks5://127.0.0.1:1086export http_proxy=$proxyexport https_proxy=$proxyexport ftp_proxy=$proxy 通过上面设置就能在命令行中发现已经可以科学上网了，目前还有两个蛋痛的地方没解决： profixer在mac上装不了了，一直弹窗。权限都给了 使用Google Drive同步文件用不了，只有将ssr设置全局才可以，MD。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云集成IM]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1IM%E9%9B%86%E6%88%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面 集成集成其实很简单，网易提供了两种方式，jar和gradle，毫无疑问gradle 12345678// 基础功能 (必需)netease_basesdk : &apos;com.netease.nimlib:basesdk:5.1.1&apos;,// 音视频需要netease_avchat : &apos;com.netease.nimlib:avchat:5.1.1&apos;,// 音视频需要netease_nrtc : &apos;com.netease.nimlib:nrtc:5.1.1&apos;,// 全文检索服务需要netease_lucene : &apos;com.netease.nimlib:lucene:5.1.1&apos;, 其中第一个是早就集成了的，自带IM功能，第二第三则是音视频需要的，第四个是需要做聊天记录搜索要用到的 APPID申请 权限 初始化 前两个看官方文档就可以了，初始化一般就是在主APP的Aplication中进行，代码如下 1234567891011// 注册通知消息过滤器registerIMMessageFilter();// 初始化消息提醒NIMClient.toggleNotification(true);// 注册网络通话来电enableAVChat();//初始化IM UI组件NimUIKit.init(this); 官方文档和demo中也有说明，需要使用到哪种能力就去初始化哪些，比如该版本还用到了IM的自定义消息，那么也必须在这里进行注册 注意：以上的初始化只能在主线程中进行，为此，云信提供了一个API：NIMUtil.isMainProcess(this) 123NIMClient.getService(MsgService.class).registerCustomAttachmentParser(new CustomAttachParse()); NimUIKit.registerMsgItemViewHolder(DiagnosisMsg.class, MsgViewHolderDiagnosis.class); IM消息监听 123456// 注册IM消息监听 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, true);// 反注册 NIMClient.getService(MsgServiceObserve.class) .observeReceiveMessage(messageObserver, false); 相关概念 注册登陆：集成网易云后，需要将本地用户与网易云id关联，每一个用户在网易云有一个唯一的accid和token，对于登陆相当于用户名及密码，对于业务比如：视频/IM则相当与电话号码，你需要和别人通信的时候必须知道对方的accid。 用户信息托管：由于本地用户在网易云有一个id关联，那么当要用到网易云的一些能力的时候，我们希望用户的一些基础信息（头像，昵称）是要与本地后端保持一致的。 消息锚点：其实就是一个消息对象，它携带了一些时间或者其他信息，方便搜索。 上面两点都是本地后端处理的，前段需要处理的则是，在登陆系统成功后，需要手动调用网易登陆api去帮助用户登陆到网易云，并且监听用户的登陆状态。 123456789101112131415161718192021222324252627282930313233public void nimLogin(User user) &#123; LoginInfo info = new LoginInfo(user.accid, user.token); // config... RequestCallback&lt;LoginInfo&gt; callback = new RequestCallback&lt;LoginInfo&gt;() &#123; @Override public void onSuccess(LoginInfo param) &#123; Logger.d(&quot;login nim success&quot;); &#125; @Override public void onFailed(int code) &#123; Logger.d(&quot;login nim failed :&quot; + code); &#125; @Override public void onException(Throwable exception) &#123; Logger.e(exception, &quot;login nim failed&quot;); &#125; &#125;; AbortableFuture&lt;LoginInfo&gt; request = NIMClient.getService(AuthService.class).login(info); request.setCallback(callback); &#125; @Override public void observeNimOnlineStatus(User user) &#123; NIMClient.getService(AuthServiceObserver.class).observeOnlineStatus( (Observer&lt;StatusCode&gt;) status -&gt; &#123; Log.i(&quot;nim&quot;, &quot;User status changed to: &quot; + status); if (status.shouldReLogin()) &#123; new Handler().postDelayed(() -&gt; nimLogin(user), 5000); &#125; &#125;, true); &#125; IM相关界面由于lib_neteaseui库提供了界面能力，所以自然自定义界面的话需要集成他的界面，这里有两种方式 集成现有类（比如p2pmessage）,只需要修改layout，并且传递需要的参数即可。 继承SDK中的UI并实现ModuleProxy代理类中方法 开启单聊很简单直接看代码 1IMMessageActivity.start(getContext(), entity.accid, customization, null, IMMessageActivity.class); 其中，entity.accid代表了对方的号码。 消息面板设置 面板类：MessageListPanelEx，这里面封装了发送消息面板的所有功能 抽屉：基类BaseAction，比如拍照，相片或者自定义类型都是通过这个基类来实现的。 IM面板layout：nim_message_activity_text_layout 设置用户托管信息： 12// 设置网易云用户资料（IM中的头像，昵称等）NimUserManager.setUserBasicInfo(user.patientName,user.imgUrl); 消息设置 消息屏蔽： 1234//屏蔽所有消息NIMClient.toggleNotification(false);//屏蔽某个用户消息NIMClinet.getService(FriendService.class).setMessageNotify(account,checkState) 消息接收 12345678910/** * IM消息监听 */ com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt; messageObserver = new com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt;() &#123; @Override public void onEvent(List&lt;IMMessage&gt; imMessages) &#123; Logger.d(&quot;im message received&quot;); &#125; &#125;; 自定义消息 自定义消息比较复杂，参见代码。具体步骤如下： 定义消息 1234567/** * 需要多端统一 */public interface CustomAttachmentType &#123; int diagnosisMsg = 1001;&#125; 自定义消息的基础类 1234567891011121314151617181920public abstract class CustomAttachment implements MsgAttachment &#123; protected int type; CustomAttachment(int type) &#123; this.type = type; &#125; public void fromJson(JsonObject data) &#123; if (data != null) &#123; parseData(data); &#125; &#125; @Override public String toJson(boolean send) &#123; return CustomAttachParse.packData(type, packData()); &#125; public int getType() &#123; return type; &#125; protected abstract void parseData(JsonObject data); protected abstract JsonObject packData();&#125; 自定义消息结构类（用于组装自定义数据） 1public class DiagnosisMsg extends CustomAttachment 自定义消息解析类（用于显示自定义消息） 1public class CustomAttachParse implements MsgAttachmentParser 参见官方文档 其他 注册账号accid网易云强制小写 网易云消息从后端还是本地拉取 1messageListPanel = new MessageListPanelEx(container, rootView, anchor, false, remote); 其中最后一个参数remote = true表示从云端拉取数据 IM聊天点击头像事件layout：MsgAdapter中layout.nim_message_item 点击事件：NimUIKitImpl.setSessionListener]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的常用命令行]]></title>
    <url>%2F2018%2F10%2F19%2FMac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看IP123$curl ip.gs$ifconfig 关于文件操作由于mac下面不能使用右键新建文件，所以需要使用一些工具，如workflow，或者直接命令行 123456789101112# 查看文件如果没有则创建新文件touch filename# 新建文件夹mkdir filename# 删除文件或者目录rm -rf filename# 查看文件详细信息stat filename# 查看目录结果，需要装treenpm install treetree -L 1 vim常规操作 操作命令 效果 i 在光标处插入，进入编辑模式 dd 剪切光标所在的一行内容 yy 复制光标所在的一行内容 D 删除光标右边的所有内容 gg 将光标快速移动到文件首 G 将光标快速移动到文件尾 0 将光标快速移动到行首 $ 将光标快速移动到行尾 退出命令 效果 :w 保存 :q 未保存直接退出（如果没有修改，用下面的命令） :q！ 强制退出 :wq 保存退出 :wq 强制保存退出]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用心得]]></title>
    <url>%2F2018%2F10%2F18%2Fgit%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1. git reset1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用1git reset HEAD &lt;file&gt; 将某个文件从暂存区拿出来。 2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用1git reset -soft/--mix/--hard &lt;commite id&gt; 会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。git reset命令的使用 选项 git reset的影响 选项 HEAD 索引（暂存区） 工作目录（源代码） –soft 是 否 否 –mix 是 是 否 –hard 是 是 是 HEAD：表示当前git指针指向的位置索引：表示add之后去到的暂存区工作目录：表示代码文件的改动提交C1 –&gt; 提交C2总结就是：soft后git指针会指向C1的提交，而C2修改的文件还是add状态，修改内容不会丢失，对现有的版本改动最小；mix后（git reset默认操作）git指针会指向C1提交，C2修改的文件不是add状态（需要重新add）不在暂存区，文件修改内容不丢失；hard后git指针指向C1提交，C2修改文件不在暂存区，文件修改丢失，完全恢复到C1提交的状态. ==hard慎用== ==或者==12git reset HEAD~git reset HEAD~1 如果你提交了多个commit，那么可以通过修改HEAD～之后的数字，如撤销前3次的commit 1git reset HEAD~3 ==下面是一个很有用的后悔药==12# 查询所有git的提交记录，包括详细commite idgit reflog 下图为git reflog的界面 这里面记录了你本地仓库中相关切换和更改的详细描述清单，你可以通过： 12# 可以通过以下命令回到任何一个位置git reset HEAD@&#123;n&#125; 2. git add语法 语法 描述 git add -A stages All git add . stages new and modified, without deleted git add -u stages modified and deleted, without new 3. git merge合并现在最简单的merge模式就是fast-farward merge了，就是从master拉出的分支develop后，master没有再做任何修改，所有的代码都在develop分支上提交，等到最后要合并develop到master上时，可以使用如下命令： 1234# 切换到Master分支git checkout master# 对Develop分支进行合并git merge --no-ff develop 4. git tag打标签标签可以针对某一时间点的版本做标记，常用于版本发布。 1.列出标签 1234# 在控制台打印出当前仓库的所有标签git tag# 搜索符合模式的标签git tag -l ‘v0.1.*’ 2.打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。 123456# 创建轻量标签git tag v0.1.2-light# 创建附注标签git tag -a v0.1.2 -m &quot;0.1.2版本&quot;# 针对某个提交打标签git tag v1.0 &lt;commite id&gt; 3.切换标签 1git show v0.1.2 4.删除标签 1234# 删除本地标签git tag -d v0.1.2# 删除远程标签git push origin --delete tag v1.0 5.标签发布 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： 1234# 将v0.1.2标签提交到git服务器git push origin v0.1.2# 将本地所有标签一次性提交到git服务器git push origin –tags 5. git stash该命令用来保存当前分支上还没commite的修改，使当前分支保持clean状态（git status） 使用场景:执行git stash后，你在dev分支没有提交的修改暂时被“藏”了起来，看起来dev分支是干净的。但是，请一定注意，你还在dev分支！因为你需要切换到master分支去修改bug，因此此时需要切换到master分支（如果不执行git stash就切换到master分支是不行的：git会报告当前dev分支还存在未提交的修改，比如先提交才允许你切换分支，而出于各种原因，你还不能现在提交dev分支的内容（一般也就先提交了，大不了再切回来改就是哦），这就是git stash存在的价值）。 切换到stash分支后的恢复命令12345678# 恢复并删除stash内容git stash pop# 查看现场git stash list# 保存现场git stash 6. git分支管理 master:主分支，当前分支上的代码随时可以直接发布，并且只能通过Pull Request从其他分支进行合并，而不能直接push修改。当开发告一段落，产生了新的可供发布的代码时，master分支通过Pull Request更新了代码，同时，每一次更新必须添加对应版本号的标签TAG。 develop:开发分支，保存当前最新开发成果的分支，即当一个新功能开发完毕需要先合并到develop分支，这个分支的代码会进行每日的代码持续集成(Daily Build)。所有的开发任务都是从这个分支Checkout新的特性分支进行开发。 feature:特性分支，当开发新的功能时，从develop分支Checkout新的feature分支，这个分支的代码最终要合并回develop分支或者废弃掉(例如预研功能效果不好时)。feature分支最好以功能为单位。 hotfix:紧急修复分支，唯一从master分支派生的分支，当生产环境中发现了异常或者缺陷的时候，从master分支上指定的TAG版本Checkout hotfix分支进行紧急修复工作，当修复完成之后，必须同时合并到master分支和develop分支。合并完代码之后删除hotfix分支。 新建分支(已feature为例) 12345678# 切换本地分支到develop分支git checkout develop# 拉取远程Git仓库中的最新的develop分支的代码git pull# 创建本地特性分支featuregit checkout -b feature# 推送本地特性分支到远程Git仓库（即创建远程特性分支），-u为追踪远程分支git push -u origin feature 已feature分支为例开发合并全流程 12345# 开发代码。以下两步的作用是保证你本地的feature分支的代码为最新，因为有可能你是和别人合作开发的该功能，如果你刚更新过或者你是一个人在开发则可以省略此操作# 切换到本地feature分支git checkout feature# 拉取远程分支代码，--rebase最好加上git pull --rebase 123456789# 合并代码# 切换到本地develop分支git checkout develop# 拉取最新的远程origin/develop分支代码，因为可能已经有人提交了代码git pull --rebase# 从本地feature-login分支合并代码，--no-ff为禁止fast-farward模式git merge --no-ff feature-login# 推送到远程分支git push 1234567# 代码已经合并完，可以删除本地特性分支和远程特性分支# 删除本地feature-login特性分支git branch -d feature-login# 删除远程origin/feature-login特性分支（废除，实验无效）git branch -r -d origin/feature-login#在v1.7.0 之后，可以使用这种语法删除远程分支(同删除标签tag类似)git push origin --delete &lt;branch name&gt; 7.git pushpush到远程分支有https和ssh两种方式，https每次push都会要求输入用户名和密码，而ssh只要在远端注册了ssh key则不需要。另外，ssh可以上传大文件，https貌似不行。12# 这个会把本地当前分支的内容push到远端的demo分支，如果远端没有该分支则自动创建git push -u origin demo 1234# 生成ssh key,该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：ssh-keygen# 可以查看远程分支情况git remote -v 8.git reset第一小节有类似操作。 本地代码回滚 1234# 回滚到commit-id，讲commit-id之后提交的commit都去除git reset --hard commit-id# 将最近3次的提交回滚git reset --hard HEAD~3 远程代码回滚。应用场景：app已经发布了，发现有问题需要回滚到某个commit，再重新发布。这时需要先将本地分支退回到某个commit，删除远程分支，再重新push本地分支。操作步骤（还没检验） 1234567891011121314# 1git checkout the_branch# 2git pull# 3 备份一下这个分支当前的情况(本地新建分支？)git branch the_branch_backup# 4 把the_branch本地回滚到the_commit_idgit reset --hard the_commit_id# 5 删除远程 the_branch（可以删除远程分支）git push origin :the_branch# 6 用回滚后的本地分支重新建立远程分支git push origin the_branch# 7 如果前面都成功了，删除这个备份分支git push origin :the_branch_backup 9.git remote多源操作，一般是一个源，但是多源也很有用1234567891011121314151617# 如果想关联另一个远端仓库（加一个源）git remote add &lt;origin name&gt; git@gitlab.com:demo/demo.git# 显示全部源git remote / git remote -v# renamegit remote rename &lt;origin name&gt; &lt;origin new name&gt;# deletedgit remote rm &lt;origin name&gt;# 查看指定源的全部信息git remote show &lt;origin name&gt;# 修改远程仓库地址git remote set-url origin &lt;origin url&gt; 10.git commit合并某个分支上的某个commit或者多个commit到master分支上123dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature] 比如，feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做： 123# 示例git checkout mastergit cherry-pick 62ecb3 在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。(未实验，要实验一下) 1234# 首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：git checkout -bnewbranch 62ecb3# 然后，rebase这个新分支的commit到master（--ontomaster）。76cada^ 指明你想从哪个特定的commit开始。git rebase --ontomaster 76cada^ 11.git rebase12345678910111213```### 12.git detached HEAD在一些情况下，会出现detached HEAD的情况，（后面分析下原因）。detached head即游离的HEAD，HEAD指向了未知的分支，即不在所有已知的分支范围内。解决办法：```git$ git branch* (HEAD detached at origin/master) dev master HEAD指向了一个未知的分支，可用git checkout -b基于当前分支创建一个新的临时分支保留代码，合并到合适的分支后删除12345678910111213$ git checkout -b tempSwitched to a new branch &apos;temp&apos;$ git branch dev master* temp$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.$ git merge tempAlready up-to-date.$ git branch -d tempDeleted branch temp (was 3e74a7a).]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
</search>
