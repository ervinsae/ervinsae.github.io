<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-03-19T03:19:36.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sing-box订阅</title>
    <link href="http://yoursite.com/2024/03/19/Sing-Box%E8%AE%A2%E9%98%85/"/>
    <id>http://yoursite.com/2024/03/19/Sing-Box订阅/</id>
    <published>2024-03-18T16:00:00.000Z</published>
    <updated>2024-03-19T03:19:36.918Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用ClaudFlare Vless薅了一波<a href="https://github.com/jwfst5088/cmliu-edgetunnel" target="_blank" rel="noopener">羊毛</a>，作为备用节点感觉完全足够了（ClaudFlare真的是个宝藏）。然后使用Mac上的Clash去订阅发现它不支持Vless协议，iOS上小火箭是支持的但是QX又不支持，然后偶然间X上看到了一个博主在说sing-box，印象中好像在它testfligth时就开始下载了，但是一直不知道怎么用，然后就看了下推文，发现它是个GFW工具，然后它也支持订阅，只是需要转换，这里记载下转换的方式。</p><a id="more"></a><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><p>打开 Replit 项目：<a href="https://replit.com/@misaka-blog/sing-box-subscribe" target="_blank" rel="noopener">https://replit.com/@misaka-blog/sing-box-subscribe</a> ，然后点击“Fork”按钮，克隆成自己的项目<br><img src="https://telegraph-image-brt.pages.dev/file/66fb9dbc1e30d6dc2857c.png" alt></p><p>找到这个文件：providers.json，将 “url” 后面的值改成自己的机场 / 自建节点订阅链接地址<br><img src="https://telegraph-image-brt.pages.dev/file/353173476fb204b5dc951.png" alt></p><p>然后点击绿色的“Run”按钮，待配置好项目依赖之后，选择配置模板（Singbox 1.8.0 及以上请输入 1，以下版本输入3），我是1.8.9版本，所以输入1<br><img src="https://telegraph-image-brt.pages.dev/file/5f119f0dc9815df5d3180.png" alt></p><p>待一切无误后，可以在左侧的文件列表看到 config.json 文件，即可代表完成生成</p><p><img src="https://telegraph-image-brt.pages.dev/file/45c257052888ca40ae279.png" alt></p><p>之后，将config.json文件导入到sing-box中，路径：Profies - New Profile - type选择local，file选择import，然后导入Create。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用ClaudFlare Vless薅了一波&lt;a href=&quot;https://github.com/jwfst5088/cmliu-edgetunnel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;羊毛&lt;/a&gt;，作为备用节点感觉完全足够了（ClaudFlare真的是个宝藏）。然后使用Mac上的Clash去订阅发现它不支持Vless协议，iOS上小火箭是支持的但是QX又不支持，然后偶然间X上看到了一个博主在说sing-box，印象中好像在它testfligth时就开始下载了，但是一直不知道怎么用，然后就看了下推文，发现它是个GFW工具，然后它也支持订阅，只是需要转换，这里记载下转换的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GFW" scheme="http://yoursite.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>随想（二）</title>
    <link href="http://yoursite.com/2024/03/14/%E9%9A%8F%E6%83%B3%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2024/03/14/随想（2）/</id>
    <published>2024-03-13T16:00:00.000Z</published>
    <updated>2024-03-15T07:24:04.655Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一些书《芯片战争》、《枪炮，钢铁，病菌》，看了一些许知远做的《十三邀》采访的一些人物采访，基于这些记录我的一些思考。都是一些点状的，可能是思维认知的一次缓慢升级过程，重要的不是它是什么，而是我产生了这些思考并记录下来，希望后面的自己能从这些点状的思考中获取一些能量把它织成一张网。</p><ul><li>在这个特定时代，大部分成功的人（商业）都在高喊着理想主义，伟大愿景；做的其实都是现实主义，鼠目寸光的事情（逻辑思维）。理想和现实不能说是背道而驰，起码不是同一个方向，也就是想的说的和做的不同。往往，诗和远方在现实面前会被击的粉碎。</li><li>大家为什么而活着？什么是对的？</li><li>一个成功的商人一定不是理想主义者，就算原来是一个理想主义者，在残酷的商业竞争下也会变成一个极度的现实主义者。</li><li>过去，信息很匮乏，知识是分散的，有知识的人获取知识的效率是远高于没有知识的，大家都固化在自己的知识阶级中；现在，信息极度爆炸，信息量多到大家没精力去去伪存真。所有的信息扑面而来，大家能做的是只接受自己愿意接收的，信息茧房形成了。你看，知识流动过低和过快导致的结果好像是一致的。我们现在追求的极致效率，在带给我们方便的同时其实也深深的伤害了我们。</li><li>过去四十年快速发展给我们造成了速度和效率一日千里是常态的假象，其实看过人类历史的发展停滞和缓慢才是主旋律。</li><li>站在知识付费厂商角度：我们做的事情是在推动知识平权，让更多的人更容易获取知识，提高整个社会的认知水平，最好能达成一种高认知的社会共识（什么是对的，什么是错的）；站在消费者角度：我买了这个知识，这个知识就是我的，至于我有没有看，有没有吸收不重要，重要的是我参与了知识的传递(我是他们中的一员)；站在第三方角度：贩卖焦虑，过度包装，说是让社会达成共识，其实什么都达不成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了一些书《芯片战争》、《枪炮，钢铁，病菌》，看了一些许知远做的《十三邀》采访的一些人物采访，基于这些记录我的一些思考。都是一些点状的，可能是思维认知的一次缓慢升级过程，重要的不是它是什么，而是我产生了这些思考并记录下来，希望后面的自己能从这些点状的思考中获取一些能量把
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>AI Agents</title>
    <link href="http://yoursite.com/2023/11/27/AI%20Agents/"/>
    <id>http://yoursite.com/2023/11/27/AI Agents/</id>
    <published>2023-11-27T03:11:34.911Z</published>
    <updated>2023-11-27T03:40:09.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很久没有更新blog了，自从3月份OpenAI推出了GPT3.5以来，AI圈子爆红了一段时间，大家讨论了很多关于AI的话题，随着时间流逝，讨论的热度也逐渐消退，似乎OpenAI只是激起了一点水花而已。但是，在AI圈子的人，特别是长期关注AI发展的人（2023-3月以前）据我观察其实是更活跃了，这期间也出过了很多很多技术，各个大厂层出不穷的推出了自己的LLM。作为一个被隔绝的旁观者，我只能尽量去体验一些我能体验的模型，然后关注下Twitter中AI大佬发布的最新动态。在此过程中，我看了两篇文章，这里做一下总结和心得。</p><h2 id="关于这两篇文章"><a href="#关于这两篇文章" class="headerlink" title="关于这两篇文章"></a>关于这两篇文章</h2><p>在此之前，我自己申请了Azure Open Ai，里面创建了几个模型，然后使用cloudflare把API暴露出来，使用Opencat或者其它AI工具客户端设置代理就可以用了；当然Open AI的web端还有Poe都是可以用的。另外，我还尝试使用Python用Long Chain工具和Azure AI接口想把自己的Blog向量化，做一个自己的私有知识库，但是一直卡在token太多这个问题里面，然后工作事情较多就一直耽搁了。。。（还是想抽时间把这个实现了）。</p><p>回到主题，我看了两篇文章一个是7月份发布的来自Lilian Weng的个人Bolg，就是讲AI Agents的，文章是<a href="https://www.aixinzhijie.com/article/6824818" target="_blank" rel="noopener">软件2.0雏形初现，OpenAI的下一步</a>，感觉这篇文章中的观点非常受启发，所以打算记录一下；另一篇是Twitter中宝玉大佬转发的杨立昆教授在《AI:Grappling with a New Kind of Intelligence》中的发言类容（这里不给链接了）。</p><p>下面我会大量摘抄两篇文章中的内容，然后就一些点记录一下自己的观点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;很久没有更新blog了，自从3月份OpenAI推出了GPT3.5以来，AI圈子爆红了一段时间，大家讨论了很多关于AI的话题，随着时间流逝，讨
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>杂记(4)</title>
    <link href="http://yoursite.com/2023/09/20/%E6%9D%82%E8%AE%B0-4/"/>
    <id>http://yoursite.com/2023/09/20/杂记-4/</id>
    <published>2023-09-20T05:48:39.000Z</published>
    <updated>2023-09-20T05:54:04.506Z</updated>
    
    <content type="html"><![CDATA[<p>我对你好，不是因为我想你也能以相同的方式对待我，而是因为我觉得你值得被这样对待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我对你好，不是因为我想你也能以相同的方式对待我，而是因为我觉得你值得被这样对待。&lt;/p&gt;

      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>杂记（3）</title>
    <link href="http://yoursite.com/2023/05/11/%E6%9D%82%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2023/05/11/杂记（3）/</id>
    <published>2023-05-10T16:00:00.000Z</published>
    <updated>2023-05-19T05:49:54.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何做一个“内核稳”的人"><a href="#如何做一个“内核稳”的人" class="headerlink" title="如何做一个“内核稳”的人"></a>如何做一个“内核稳”的人</h2><ol><li><p>不急着反应，别人肯定你，不欣喜若狂；别人批评你，不盲目自卑内耗。这都是别人的看法，和本来的你关系不大。</p></li><li><p>多内观自己的坏情绪。会因为什么事情焦虑、恐惧、内耗，把这些事情从头到尾梳理一遍，以第三者角度看待事情，就会理智很多。</p></li><li><p>提高自己的经济能力。这个重要，但不是最重要。所以如果自己的经济能力暂时不会有太大的改 善，先从心态开始练起。</p></li><li><p>不要有过多的解释欲。不是所有人都值得你解释，只对自己在乎的几个人说自己的事，必要的时候甚至可以不说。 </p></li><li><p>接受别人可以是任何样子。可以是聪明的，也可以是傻逼的。可以是漂亮的，也可以是丑陋的。可以是善良的，也可以是阴狠的。</p></li><li><p>存在即合理。世界上很多东西不符合自己的三观，但它必然有存在的理由，抱着平和的心态多去看世界，了解多样性，就能更有包容心。</p></li></ol><a id="more"></a><h2 id="辩证思考"><a href="#辩证思考" class="headerlink" title="辩证思考"></a>辩证思考</h2><p>什么叫爱？就是用对方需要的方式表达你的好，而不是用自认为好的方式强加于人。</p><p>什么叫沟通？就是用对方的语言讲述你的道理，而不是用自己的语言来讲述自己的道理。</p><p>什么叫辩论？就是用对方的逻辑证明你的观点，而不是用自己的逻辑证明自己的观点。</p><p>什么叫销售？就是让客户觉得他占了你的便宜，而不是把自认为便宜的东西卖给了客户。</p><p>什么叫好感？就是让别人觉得你在他眼中有多么优秀，而不是证明自己有多优秀。</p><p>什么叫理解？就是用对方的立场看待自己的观点，而不是站在自己的立场强调自我感受。</p><h2 id="底层逻辑的三个特点"><a href="#底层逻辑的三个特点" class="headerlink" title="底层逻辑的三个特点"></a>底层逻辑的三个特点</h2><ol><li><p>抽象性：抽象就是从众多的事物中提取出共同的、本质性的特征。比如人会对抽烟、喝酒、吸毒、玩游戏等各种事物上瘾，而上瘾的本质就是多巴胺欲望回路过强，导致人们无法控制自己的欲望。</p></li><li><p>驱动性：底层逻辑是各种事物呈现出当前现象的驱动力。比如水往低处流、汽车在下坡时关闭发动机还能继续滑行，这都是受到了重力的驱动。</p></li><li><p>通用性：底层逻辑针对的不是某个特定问题，而是某一类问题，有时甚至能被运用在万事万物上。比如在读书、写作、健身、财富积累等方面，我们要想大有收获，都必须坚持<strong>长期主义</strong>。</p></li></ol><h2 id="顶层思维"><a href="#顶层思维" class="headerlink" title="顶层思维"></a>顶层思维</h2><p>顶层思维是一种自上而下，由大到小的思维框架，类似计算机术语中的递归思维，和它相对的思维方式是随机思维（随机思维的最大问题是一叶障目，将自己锁死在低效率的小圈子中），自下而上一点点往上拱。</p><p>随机思维是每次的行动都是由外在的机缘触发的，而顶层思维是从事务的核心原理出发，用积极的姿态去寻找解决方案，将目标与现状链接，找到其中必然步骤，然后列出次序一一落实。</p><p>一个正确的理论模型（框架）是可以预测事物出现的。把现有事物填充到理论模型（框架）中不能证明这个理论牛逼，如果通过这个理论模型（框架）可以去发现未知事物那才牛逼。类似元素周期表的理论。（2023/5/19，这个例子好像不太合适，元素周期表本质上是真实世界的客观规律，但是理论模型实质是一种可以自洽的方法论并不是客观规律）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何做一个“内核稳”的人&quot;&gt;&lt;a href=&quot;#如何做一个“内核稳”的人&quot; class=&quot;headerlink&quot; title=&quot;如何做一个“内核稳”的人&quot;&gt;&lt;/a&gt;如何做一个“内核稳”的人&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不急着反应，别人肯定你，不欣喜若狂；别人批评你，不盲目自卑内耗。这都是别人的看法，和本来的你关系不大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多内观自己的坏情绪。会因为什么事情焦虑、恐惧、内耗，把这些事情从头到尾梳理一遍，以第三者角度看待事情，就会理智很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高自己的经济能力。这个重要，但不是最重要。所以如果自己的经济能力暂时不会有太大的改 善，先从心态开始练起。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要有过多的解释欲。不是所有人都值得你解释，只对自己在乎的几个人说自己的事，必要的时候甚至可以不说。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接受别人可以是任何样子。可以是聪明的，也可以是傻逼的。可以是漂亮的，也可以是丑陋的。可以是善良的，也可以是阴狠的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存在即合理。世界上很多东西不符合自己的三观，但它必然有存在的理由，抱着平和的心态多去看世界，了解多样性，就能更有包容心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>杂记（2）</title>
    <link href="http://yoursite.com/2023/03/20/2023-03-20/"/>
    <id>http://yoursite.com/2023/03/20/2023-03-20/</id>
    <published>2023-03-20T10:43:12.837Z</published>
    <updated>2023-04-01T03:53:37.460Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>思维其实是有维度的，点，线，面，体。</p></li><li><p>丛林法则，弱肉强食，雪豹捕猎羚羊，本质上他们都是为了活下去。</p></li><li><p>LLM最重要的三个元素，数据，算法，算力。其中算力和硬件（半导体）有关，也就是门槛。预计各大巨头公司都会发展自己的LLM，只是目前微软领先了一个身位。国内由于算力就被卡死，不能用最先进的H100，导致始终会比国外要慢一拍，所以可能的机会是换个赛道，基于有缺陷的模型深度构建应用层，丰富基于模型的生态，继续卷。所以，我预测是未来几年在国内做应用的会有一波新的机会。</p></li><li><p>类似chatGPT这类的大模型，参数达到了175B（1750亿）个，还有一些小型的模型（典型的是Anthropic, PBC开发的Claude，参数是170万），其实普通用户在使用上区分不出他们有什么区别。下面是我问他和chatGPT有什么区别，挺有意思的。</p></li></ul><p><img src="https://s1.locimg.com/2023/03/30/df761d3b8e272.jpg" alt="claude.jpg"></p><ul><li>目前能想到使用这类语言模型干得活有：翻译，查询，知识普及，文章创作或润色，codepilot等等（想象力匮乏），后续陆续如果加上图片，声音甚至是视频，那想象空间就无限大了，基本就实现了AIGC。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;思维其实是有维度的，点，线，面，体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;丛林法则，弱肉强食，雪豹捕猎羚羊，本质上他们都是为了活下去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LLM最重要的三个元素，数据，算法，算力。其中算力和硬件（半导体）有关，也就是门槛。预计
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="http://yoursite.com/2023/03/16/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2023/03/16/一些感想/</id>
    <published>2023-03-15T16:00:00.000Z</published>
    <updated>2023-04-01T03:52:36.157Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一天中最幸运的事情：</li></ul><ol><li>碰到一首可以单曲循环的歌</li><li>解决了一个难题</li><li>突然冒出一个令自己兴奋的想法，想立马去实施</li><li>完成了一项让自己满意的工作</li><li>消除了和另一个在意的人之间的矛盾</li><li>1，2，3，4，5都来一遍</li><li>。。。</li></ol><ul><li><p>天下无不散的宴席。人生是一场旅途，有人同行是一种缘分，珍惜同行时光，等到分别之时，挥手告别，微笑离开。</p></li><li><p>成年人能够依赖的只有自己，能够救自己的也只有自己。</p></li><li><p>永远不要去试探人性，人性通常都禁不起推敲。</p></li><li><p>不作恶，保持善良。</p></li><li><p>不以物喜，不以己悲。平静对待赞赏，坦然接受批评。持续反思，保持好奇心，多琢磨，多折腾。</p></li><li><p>AI的可怕之处在于，他永远在反思，在对未知事物保持敬畏。他的回答已经很完美了，最后还会来一句他有局限性。相比而言，作为人类认知不及AI万分之一，还经常飘。人类和AI共存的日子马上就要来临了。</p></li><li><p>美好的东西，站在远处观赏就好。靠的太近也许是另一番景象。</p></li><li><p>剖析自己，找到自己的缺点，就算改不掉也要时刻提醒自己。</p></li><li><p>不要看他说什么，看他做什么，他做什么代表他相信什么。</p></li><li><p>每个人只相信自己相信的东西。</p></li><li><p>多元的信息输入源很重要，信息茧房的产生其实就是常年接受一种信息源，不断强化你的既有认知。特别是目前的社交网络，信息流很多都是同质化，信息量密度低的内容，接触多了之后会让你不愿意或者没有耐心去思考稍微复杂的问题，让人变得无知且固执。</p></li><li><p>顿悟是什么感觉？王阳明砍竹子和牛顿被苹果砸都让他们顿悟了，外界的扰动触发了内心认知的一次升级。</p></li><li><p>命运和人定胜天可能是人生的两个不同纬度，后天的努力通过因果关系可以改变命运。</p></li><li><p>出了问题，有时候向内去找答案比向外求助更有用。</p></li><li><p>越来越相信平行宇宙的理论。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;一天中最幸运的事情：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;碰到一首可以单曲循环的歌&lt;/li&gt;
&lt;li&gt;解决了一个难题&lt;/li&gt;
&lt;li&gt;突然冒出一个令自己兴奋的想法，想立马去实施&lt;/li&gt;
&lt;li&gt;完成了一项让自己满意的工作&lt;/li&gt;
&lt;li&gt;消除了和另一个
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>深度学习之环境搭建</title>
    <link href="http://yoursite.com/2023/03/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2023/03/10/深度学习之环境搭建/</id>
    <published>2023-03-09T16:00:00.000Z</published>
    <updated>2023-03-13T09:49:48.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队内部要做一些分享，最近ChatGPT正火，而且正好也在研究深度学习在移动设备上的相关东西，所以就想就深度学习这个方向去沉淀一些东西供参考。</p><p>深度学习目前是两大框架，神仙打架。Google的Tensorflow和Meta的Pytorch，本文基于Tensorflow来讲。由于本人使用的是Mac M1版本，在折腾过程中遇到了很多问题，最终还是解决了。这里做个记录。</p><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Mac自带了python环境，直接安装tensorflow后，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br></pre></td></tr></table></figure></p><p>直接就报错了：illegal hardware instruction python3</p><p>后面发现是由于Tensorflow不支持Arm的cpu架构，需要使用Macos专用的Tensorflow框架，也询问了ChatGPT，最终过程是这样的。</p><ol><li><p>下载基于Arm架构的miniconda<br>下载地址：<a href="https://github.com/conda-forge/miniforge/#download" target="_blank" rel="noopener">https://github.com/conda-forge/miniforge/#download</a></p></li><li><p>输入下面三个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#下载完以后在terminal依次输入以下三个命令</span><br><span class="line"># 授权</span><br><span class="line">chmod +x ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line"># 执行下载的脚本</span><br><span class="line">sh ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line"># 运行脚本</span><br><span class="line">source ~/miniforge3/bin/activate</span><br></pre></td></tr></table></figure></li><li><p>下载conda环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>创建conda虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf python==3.9</span><br><span class="line"></span><br><span class="line">conda activate tf</span><br></pre></td></tr></table></figure></li><li><p>安装tensorflow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pip下载在国内也很慢，很容易网络连接超时，-i https://pypi.tuna.tsinghua.edu.cn/simple能够切换到清华源下载</span><br><span class="line"></span><br><span class="line"># 在终端中依次输入以下三行命令。这三行命令都是下载包，可能速度有点慢，但是切换源之后应该速度很快。</span><br><span class="line"></span><br><span class="line">conda install -c apple tensorflow-deps</span><br><span class="line">python -m pip install tensorflow-macos -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">python -m pip install tensorflow-metal -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>查看是否有效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure></li></ol><p>如果能打印出版本号证明环境安装OK了，这时候会在tf这个虚拟环境中运行tensorflow</p><h2 id="在pycharm中使用刚刚配置的环境"><a href="#在pycharm中使用刚刚配置的环境" class="headerlink" title="在pycharm中使用刚刚配置的环境"></a>在pycharm中使用刚刚配置的环境</h2><p>pycharm是专用来开发python的，刚刚我们本地创建了一个可以运行tf的环境（interpreter）,我们如果想在pycharm里面去使用刚刚的环境，需要做一些配置，按照如果配置：</p><p><img src="https://s1.locimg.com/2023/03/13/444985288b1c9.jpg" alt="pycharm配置"></p><p>其中miniforge3就是上面第一步下载后生成的文件夹，里面有conda环境，通过这样配置生成的一个py项目就能使用tf的运行项目了</p><p><img src="https://s1.locimg.com/2023/03/13/dc1beddc79377.jpg" alt="效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;团队内部要做一些分享，最近ChatGPT正火，而且正好也在研究深度学习在移动设备上的相关东西，所以就想就深度学习这个方向去沉淀一些东西供参考。&lt;/p&gt;
&lt;p&gt;深度学习目前是两大框架，神仙打架。Google的Tensorflow和Meta的Pytorch，本文基于Tensorflow来讲。由于本人使用的是Mac M1版本，在折腾过程中遇到了很多问题，最终还是解决了。这里做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mmap的简单原理解析</title>
    <link href="http://yoursite.com/2023/02/07/mmap%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2023/02/07/mmap的简单原理/</id>
    <published>2023-02-06T16:00:00.000Z</published>
    <updated>2023-02-07T07:18:20.456Z</updated>
    
    <content type="html"><![CDATA[<p>mmap很早就知道一些，但是只是简单知道这个可以减少内存消耗，并不知道它的实现原理是怎么样的，所以也不知道它到底是怎么去减少内存消耗的，然后找了相关资料看了下，发现和android的bundle机制还有点相似，这里做个记录和总结</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>我们都知道linux进程分为<strong>用户空间</strong>和<strong>内核空间</strong>，后来在零拷贝原理中知道对于32位操作系统来说系统会给每个应用进程分配4G的虚拟内存空间，其中0-3G的内存地址属于用户空间，3-4G的内存地址属于内核空间。其中用户空间是不能共享的，而内核空间是运行操作系统的，它独立于普通的应用程序，是被所有应用程序共享的。所以对一个应用来说，只有3G的用户空间是属于应用本身的。参考：<a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">内核空间与用户空间</a>。由于用户空间是隔离的，所以这里当一个进程想访问另外一个进程的用户数据时就涉及到进程之间的通讯了（RPC），Android使用bundle来更好的解决这个问题，后面单独写Android的bundle机制。</p><a id="more"></a><h2 id="mmap是什么"><a href="#mmap是什么" class="headerlink" title="mmap是什么"></a>mmap是什么</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。</p><p>实现了这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写改动过的页面到对应的文件磁盘上，即完成了对文件的操作而不必要再调用read，write等系统函数。相反，内核空间对这段区域的修改也直接反映用户空间（因为内核空间被所有进程公用），从而实现不同进程间的 文件共享。</p><h2 id="mmap的简单原理"><a href="#mmap的简单原理" class="headerlink" title="mmap的简单原理"></a>mmap的简单原理</h2><h3 id="传统的读写文件"><a href="#传统的读写文件" class="headerlink" title="传统的读写文件"></a>传统的读写文件</h3><p>一般来说，修改一个文件需要三个步骤</p><ul><li>把文件内容读入到内存中</li><li>修改内存中的内容</li><li>把内存的数据写入到文件中</li></ul><p>过程如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b5d56c88f4b49ddba0ed1b014928a49~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>从上图可以看到磁盘中的文件file要被用户修改的时候，需要先把file文件拷贝到<strong>页缓存（page cache）</strong>中，然后通过系统函数read读到用户空间的临时buffer中（copy），修改之后，再通过write方法（copy）写回页缓存中，最终改变了磁盘中的file的文件。其中，页缓存是读写文件的中间层，内核使用页缓存与文件的数据块（连续的内存地址）关联起来。所以应用程序读写文件时，实际操作的是页缓存。这里为了实现文件修改在内存中是做了两次copy的。</p><h3 id="使用mmap读写文件"><a href="#使用mmap读写文件" class="headerlink" title="使用mmap读写文件"></a>使用mmap读写文件</h3><p>从上面读写文件的过程中，我们可以看到有一个地方是可以优化的：如果可以直接在用户空间操作（读写）页缓存，那么久可以免去页缓存的数据复制到用户空间的临时buffer的过程。mmap其实就是做这个事情的。</p><p>使用mmap系统调用可以将用户空间的虚拟内存地址与文件进行映射（怎么做到的？），对映射的虚拟内存地址就行读写操作就如同对文件进行读写操作一下，如图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a55af52d3042c79613feb41fc662d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>mmap最终是调用了sendfile方法来实现映射关系的（具体怎么做到将用户空间的内存和页缓存做映射的，可以看这篇文章：<a href="https://developer.aliyun.com/article/375144" target="_blank" rel="noopener">认证分析mmap</a>，这里不深入写，只要知道mmap的第一层原理，它减少了将内核空间往用户空间拷贝的动作，所以性能会很好。）</p><p>由于读写文件都需要经过页缓存，所以mmap映射的正是文件的页缓存，而非磁盘中的文件本身。由于mmap映射的是文件的页缓存，所以就涉及到同步的问题：页缓存上面时候把数据同步到磁盘？linux内核并不会主动把mmap映射的页缓存同步到磁盘，而是需要用户主动触发。同步mmap映射的内存到磁盘有4个时机：</p><ul><li>调用msync函数主动进行数据同步（主动）</li><li>调用munmap函数对文件进行解除映射关系时（主动）</li><li>进程推出时（被动）</li><li>系统关机时（被动）</li></ul><p>mmap 函数会返回映射后的内存地址，我们可以通过此内存地址对文件进行读写操作。如图<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b59dc54fc6fc42a294e3cf1defc1a3b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mmap很早就知道一些，但是只是简单知道这个可以减少内存消耗，并不知道它的实现原理是怎么样的，所以也不知道它到底是怎么去减少内存消耗的，然后找了相关资料看了下，发现和android的bundle机制还有点相似，这里做个记录和总结&lt;/p&gt;
&lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;p&gt;我们都知道linux进程分为&lt;strong&gt;用户空间&lt;/strong&gt;和&lt;strong&gt;内核空间&lt;/strong&gt;，后来在零拷贝原理中知道对于32位操作系统来说系统会给每个应用进程分配4G的虚拟内存空间，其中0-3G的内存地址属于用户空间，3-4G的内存地址属于内核空间。其中用户空间是不能共享的，而内核空间是运行操作系统的，它独立于普通的应用程序，是被所有应用程序共享的。所以对一个应用来说，只有3G的用户空间是属于应用本身的。参考：&lt;a href=&quot;https://www.cnblogs.com/sparkdev/p/8410350.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核空间与用户空间&lt;/a&gt;。由于用户空间是隔离的，所以这里当一个进程想访问另外一个进程的用户数据时就涉及到进程之间的通讯了（RPC），Android使用bundle来更好的解决这个问题，后面单独写Android的bundle机制。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>随想（一）</title>
    <link href="http://yoursite.com/2023/01/18/%E9%9A%8F%E6%83%B3/"/>
    <id>http://yoursite.com/2023/01/18/随想/</id>
    <published>2023-01-17T16:00:00.000Z</published>
    <updated>2023-01-18T03:42:39.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.</strong> 最近在学习一些管理方面的知识，从思想层面对管理者有了新的认识。执行者和管理者的思维模式是完全不一样的，而大部分走上管理岗位的又往往是那些业务骨干，业务骨干其实就是优秀的执行者，能够很完美的完成领导交付的任务，他们也是领导重点考察和培养的对象。但是，由于执行者和管理者存在的最大不同点在于：思维模式，所以刚进入到管理岗位的执行者会很不适应，有很强的执行者思维惯性。这个时候如果有人可以点拨你，或者自己学习是可以少走很多弯路的。那么，执行者和管理者思维的区别是什么呢？</p><ul><li>执行者：依靠自己，索取资源，局部最优，靠自己的个人能力达成个人目标</li><li>执行者：教练他人，整合资源，全局最优，依靠团队（他人）的能力来达成团队目标</li></ul><p>这里本质不同的是一个是依靠单打独斗达成目标，一个是带领团队依靠别人优秀的能力来达成目标。</p><p><strong>2.</strong> 人际交往的本质其实是价值交换。这个价值可以是有形的也可能是无形的，比如权利，钱，能力或者品质等。你能融入某个圈子说明你具备了这个圈子需要的价值，反之，你融入不了某个圈子就证明你缺少某些价值。人际交往建立后其实就是信任的问题，信任是一个很抽象的概念，这里有个公式可以把信任拆解成几个纬度，让抽象的信任可以被稍微具象化一些：</p><blockquote><p>信任 = （专业性 + 可靠性 + 同频性）/ 自我意识</p></blockquote><p>这里专业性和可靠性都好理解，同频性是指你们具有相似的思维方式，爱好，信仰之类的东西；而自我意识则是你的主观意识存在。这里我认为比较重要的是自我意识，当自我意识很小，信任就可以无限大；当自我意识很大，信任就可以无限小。这里的自我意识其实是说你的思想认识，价值观，看问题视角，认知，感受，调整等。自我意识小，说明你会依附权威，不太会提出反对意见或者都没有反对的意识，这时候你会无限信任比你强的人所提出的观点。那是不是自我意识强就好呢，我觉得也不是，自我意识强是要建立在知识，能力，情感，判断，地位等等具有充足储备的前提下，是需要强大的能力来保障的，盲目的自我意识强是毫无意义的。所以，<strong>信任其实就是在合理自我意识下的价值交换</strong>。合理自我意识还隐藏一个重要的点就是平等，平等的关系才会带来合理的自我意识（自我意识是可以被自我去调整的），信任才有可能被达成，否则我为什么要降低我的自我意识来和你交换？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 最近在学习一些管理方面的知识，从思想层面对管理者有了新的认识。执行者和管理者的思维模式是完全不一样的，而大部分走上管理岗位的又往往是那些业务骨干，业务骨干其实就是优秀的执行者，能够很完美的完成领导交付的任务，他们也是领导重点考察和培养
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>视频编码基础</title>
    <link href="http://yoursite.com/2022/11/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/11/01/视频编码基础/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-03-20T09:51:03.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频传输基本原理"><a href="#视频传输基本原理" class="headerlink" title="视频传输基本原理"></a>视频传输基本原理</h1><p>视频是利用人眼的视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说很不友好。为了能够使视频便于传输和存储，人们发现有视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端回复回来，这样就大大减少了视频数据的文件，因此有了H.264视频压缩标准。</p><p>视频里面最常用的编码格式就说H.264，基于这个编码格式还有H.265（后续研究），音频采样数据会采用AAC编码格式进行压缩。视频内容经过编码压缩后，确实有利于存储和传输。不过当要观看播放视频时，相应也需要解码过程，将压缩的视频还原。所以，编解码之间显然需要约定一种协议，这种协议大概的流程是：<strong>编码器将多张图像进行编码后产生一段一段的GOP（Group of picture），解码器则在播放时读取一段一段的GOP进行解码后读取画面再渲染显示。</strong></p><p><img src="https://s1.locimg.com/2023/03/20/e4f56c4c5d34f.png" alt="1.png"></p><blockquote><p>GOP是一组连续的画面，由一张I帧和数张B帧和P帧组成，它是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。I帧是内部编码帧（也称为关键帧），P帧是前向预测帧（前向参考帧），B帧是双向内插帧（双向参考帧）。简单说，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。如果没有I帧，P和B是无法解码的。</p></blockquote><p><img src="https://s1.locimg.com/2023/03/20/44f418589b027.png" alt="在H.264编码中I帧，P帧，B帧传输的视频画面"></p><a id="more"></a><h1 id="I帧-P帧-B帧"><a href="#I帧-P帧-B帧" class="headerlink" title="I帧,P帧,B帧"></a>I帧,P帧,B帧</h1><ul><li><strong>I帧</strong><br>I帧:即Intra-coded picture（帧内编码图像帧），I帧表示<strong>关键帧</strong>，你可以理解为这一帧画面的完整保留；每个GOP组中第一帧一定是I帧，而且是一种特殊的I帧，也可以称为IDR帧，一个GOP可以有很多I帧，但是只有1个IDR帧。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。<br><img src="https://s1.locimg.com/2023/03/20/0818121e947e7.png" alt="2.png"></li></ul><p><u>I帧的特点：</u></p><ol><li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输</li><li>解码时仅用I帧的数据就可以重构完整的图像</li><li>I帧描述了图像背景和运动主体的详情</li><li>I帧不需要参考其他画面而生成</li><li>I帧是P帧和B帧的参考帧</li><li>I帧所占数据的信息量比较大</li></ol><ul><li><strong>P帧</strong><br>P帧:即Predictive-coded Picture（前向预测编码图像帧）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）<br><img src="https://s1.locimg.com/2023/03/20/212be6bd5232b.png" alt="3.png"></li></ul><p><u>P帧的特点：</u></p><ol><li>P帧是I帧后面相隔1-2帧的编码帧</li><li>P帧采用运动补偿的方法传送它与前面的I或者P帧的差值及运动矢量预测误差</li><li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像</li><li>P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧</li><li>P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧</li><li>由于P帧是参考帧，它可能造成解码错误的扩散</li><li>由于是差值传输，P帧的压缩比较高（大概I帧的一半大小）</li></ol><ul><li><strong>B帧</strong><br>B帧：即Bidirectionally predicted picture（双向预测编码图像帧)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。<br><img src="https://s1.locimg.com/2023/03/20/24ab218973a53.png" alt="4.png"></li></ul><p><u>B帧的特点</u></p><ol><li>B帧是由前面的I或P帧和后面的P帧来进行预测的</li><li>B帧传送的是它与前面的I帧或者P帧和后面的P帧之间的预测误差及运动矢量</li><li>B帧是双向预测编码帧</li><li>B帧压缩比最高，对解码性能要求也高（大概I帧的四分之一）</li><li>需要参考前一个I帧或者P帧及其后面的一个P帧来生成一张完整的视频画面，所以P帧与B帧去掉的是视频帧在时间维度上的冗余信息。</li></ol><p><u>B帧存在的价值</u><br>从上面分析可知，I帧和P帧的解码算法比较简单，资源占用比较少，I只要自己完成就行了，P帧也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果只有I和P，解码器可以不用处理后续数据，边读边解码，那为什么还要引入B帧呢？因为B帧记录了前后帧的差别，<strong>比P帧能节约更多空间</strong>，这样视频文件可以变小，但是相应的就要求解码器性能比较高了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就时说要预读，预解码），而且，B帧不能简单丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的缓慢简单重复，就会造成画面卡顿（丢帧）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;视频传输基本原理&quot;&gt;&lt;a href=&quot;#视频传输基本原理&quot; class=&quot;headerlink&quot; title=&quot;视频传输基本原理&quot;&gt;&lt;/a&gt;视频传输基本原理&lt;/h1&gt;&lt;p&gt;视频是利用人眼的视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说很不友好。为了能够使视频便于传输和存储，人们发现有视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端回复回来，这样就大大减少了视频数据的文件，因此有了H.264视频压缩标准。&lt;/p&gt;
&lt;p&gt;视频里面最常用的编码格式就说H.264，基于这个编码格式还有H.265（后续研究），音频采样数据会采用AAC编码格式进行压缩。视频内容经过编码压缩后，确实有利于存储和传输。不过当要观看播放视频时，相应也需要解码过程，将压缩的视频还原。所以，编解码之间显然需要约定一种协议，这种协议大概的流程是：&lt;strong&gt;编码器将多张图像进行编码后产生一段一段的GOP（Group of picture），解码器则在播放时读取一段一段的GOP进行解码后读取画面再渲染显示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.locimg.com/2023/03/20/e4f56c4c5d34f.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GOP是一组连续的画面，由一张I帧和数张B帧和P帧组成，它是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。I帧是内部编码帧（也称为关键帧），P帧是前向预测帧（前向参考帧），B帧是双向内插帧（双向参考帧）。简单说，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。如果没有I帧，P和B是无法解码的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.locimg.com/2023/03/20/44f418589b027.png&quot; alt=&quot;在H.264编码中I帧，P帧，B帧传输的视频画面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>线程池的一些知识点回顾</title>
    <link href="http://yoursite.com/2022/09/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/10/线程池知识点解析/</id>
    <published>2022-09-09T16:00:00.000Z</published>
    <updated>2022-11-23T07:26:33.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对线程池的一些理解"><a href="#对线程池的一些理解" class="headerlink" title="对线程池的一些理解"></a>对线程池的一些理解</h1><ol><li>线程池是对线程的管理和调度，我们自己当然也可以去新建线程去处理并发操作，但是线程池提供了很好的解决线程之间调度，管理的能力，这些能力可能比我们自己去实现更优。</li><li><p>创建线程池有两种方式（本质上是一种），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Executors封装好的线程池创建方法去创建</span></span><br><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ThreadPoolExecutor来创建，其实上一种本质上也是调用这个来创建线程池的(阿里规范推荐)</span></span><br><span class="line">ExecutorService executors = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">0L</span>,</span><br><span class="line">        TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"><span class="comment">//其中参数1，为核心线程数；2，最大线程数；3，线程存活时间；4，线程的阻塞队列；5，线程（任务）熔断机制</span></span><br></pre></td></tr></table></figure></li><li><p>基于第二点解释这些参数的意义</p></li></ol><ul><li>a, 核心线程数是线程池初始化就会创建的线程，并且该线程不会被回收；</li><li>b, 最大线程数是线程池中允许存在的最大线程数量；</li><li>c, 线程存活时间指的是当非核心线程在处理完任务不再使用后多久被线程池回收；</li><li>d, 线程阻塞队列是任务队列，线程处理的任务会按照队列的特点存在队列中；</li><li>e, 线程熔断机制是当线程处理不过来任务时，应该做一些什么策略。</li></ul><ol start="4"><li>线程池运行的流程</li></ol><ul><li>线程池刚创建的时候，里面没有一个线程，任务队列是做为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个一个任务时，线程池会做几个判断<ul><li>a，如果正在运行的线程数量小于核心线程数，则马上创建线程执行这个任务</li><li>b，如果正在运行的线程数量大于或等于最大线程数，则把任务放入队列中</li><li>c，如果这时候队列满了，运行的线程数小于最大线程数，则创建线程立马执行这个任务</li><li>d，如果队列满了，运行的线程数大于等于最大线程数，则执行线程熔断机制</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程没有任务执行，超过线程存活时间时，线程池会判断，如果当前运行线程大于核心线程数，那么这个线程就会被回收。所以最终线程池的线程数量会维持为核心线程的数量。</li></ul><blockquote><p>这样的过程说明，并不是先加入任务就一定先执行，看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executors = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,</span><br><span class="line">                 <span class="number">6</span>,</span><br><span class="line">                 <span class="number">0L</span>,</span><br><span class="line">                 TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                 <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">         <span class="comment">//ThreadTest01 test01 = new ThreadTest01();</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> taskId = i;</span><br><span class="line">             Runnable task = () -&gt; &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getName() + <span class="string">" is saving data:"</span> + taskId);</span><br><span class="line">                     <span class="comment">/*模拟存储数据耗时*/</span></span><br><span class="line">                     Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">             executors.execute(task);</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="comment">/*运行结果：首先核心线程为3所以立马执行任务1，2，3；然后任务4到13被放入到队列中，14，15，16又会被新创建的3个线程（最大为6）执行，</span></span><br><span class="line"><span class="comment"> 再增加任务17到20时由于当前已经有6个线程在处理任务了，所以17到20的任务由于ThreadPoolExecutor.DiscardPolicy()策略会被丢弃。</span></span><br><span class="line"><span class="comment"> 然后6个线程又会依次从队列冲取出4到13任务去执行。*/</span></span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h1 id="线程池中几种队列的理解"><a href="#线程池中几种队列的理解" class="headerlink" title="线程池中几种队列的理解"></a>线程池中几种队列的理解</h1><ol><li>SynchronousQueue<br> synchronousQueue本身没有容量，是无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</li><li>LinkedBlockingQueue</li><li>ArrayBlockingQueue</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对线程池的一些理解&quot;&gt;&lt;a href=&quot;#对线程池的一些理解&quot; class=&quot;headerlink&quot; title=&quot;对线程池的一些理解&quot;&gt;&lt;/a&gt;对线程池的一些理解&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池是对线程的管理和调度，我们自己当然也可以去新建线程去处理并发操作，但是线程池提供了很好的解决线程之间调度，管理的能力，这些能力可能比我们自己去实现更优。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建线程池有两种方式（本质上是一种），如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通过Executors封装好的线程池创建方法去创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Executors.newSingleThreadExecutor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用ThreadPoolExecutor来创建，其实上一种本质上也是调用这个来创建线程池的(阿里规范推荐)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//其中参数1，为核心线程数；2，最大线程数；3，线程存活时间；4，线程的阻塞队列；5，线程（任务）熔断机制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于第二点解释这些参数的意义&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;a, 核心线程数是线程池初始化就会创建的线程，并且该线程不会被回收；&lt;/li&gt;
&lt;li&gt;b, 最大线程数是线程池中允许存在的最大线程数量；&lt;/li&gt;
&lt;li&gt;c, 线程存活时间指的是当非核心线程在处理完任务不再使用后多久被线程池回收；&lt;/li&gt;
&lt;li&gt;d, 线程阻塞队列是任务队列，线程处理的任务会按照队列的特点存在队列中；&lt;/li&gt;
&lt;li&gt;e, 线程熔断机制是当线程处理不过来任务时，应该做一些什么策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;线程池运行的流程&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;线程池刚创建的时候，里面没有一个线程，任务队列是做为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/li&gt;
&lt;li&gt;当调用execute()方法添加一个一个任务时，线程池会做几个判断&lt;ul&gt;
&lt;li&gt;a，如果正在运行的线程数量小于核心线程数，则马上创建线程执行这个任务&lt;/li&gt;
&lt;li&gt;b，如果正在运行的线程数量大于或等于最大线程数，则把任务放入队列中&lt;/li&gt;
&lt;li&gt;c，如果这时候队列满了，运行的线程数小于最大线程数，则创建线程立马执行这个任务&lt;/li&gt;
&lt;li&gt;d，如果队列满了，运行的线程数大于等于最大线程数，则执行线程熔断机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行&lt;/li&gt;
&lt;li&gt;当一个线程没有任务执行，超过线程存活时间时，线程池会判断，如果当前运行线程大于核心线程数，那么这个线程就会被回收。所以最终线程池的线程数量会维持为核心线程的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这样的过程说明，并不是先加入任务就一定先执行，看下面的例子&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//ThreadTest01 test01 = new ThreadTest01();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; taskId = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Runnable task = () -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread-&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;string&quot;&gt;&quot; is saving data:&quot;&lt;/span&gt; + taskId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &lt;span class=&quot;comment&quot;&gt;/*模拟存储数据耗时*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     Thread.sleep(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             executors.execute(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/*运行结果：首先核心线程为3所以立马执行任务1，2，3；然后任务4到13被放入到队列中，14，15，16又会被新创建的3个线程（最大为6）执行，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; 再增加任务17到20时由于当前已经有6个线程在处理任务了，所以17到20的任务由于ThreadPoolExecutor.DiscardPolicy()策略会被丢弃。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; 然后6个线程又会依次从队列冲取出4到13任务去执行。*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>跨平台技术Flutter技术规划</title>
    <link href="http://yoursite.com/2022/06/29/Flutter%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2022/06/29/Flutter技术规划/</id>
    <published>2022-06-29T13:44:54.453Z</published>
    <updated>2023-03-20T10:33:34.486Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1ebd1a953ba1b8d53e120b6f764ba6e6e387bfc366584eac2fbc9a377ee939e9">ebb08aa0288e261ddeb0b4aadf3d63d9334d551ecfb20a988ee264721d658bcc117ae618d7bd0102b1a64628349aa697db762dff100a77ffc0d8dce728a495b90f3c3638a9eb9cccdd998e9c9068ef07abb960ad41796745f8645488ff22941863cf33a0fca5e848719cc18efd78040c594cb6ef6c42a8710e529b4ab25a45e37659edca2ad19d176eb3c649334813ec4500dafd3757a9d09de6ec43e302575b01bccbaabddc745652c5e40e7ad0c0b42bd4f13ee4d8a0e3467f68df90b6b42e9f72e80dd3bdc3d3720ef41136eeca11a8b68e171417553a7629954389d606e260a62765aa4f3d42420eb61cc4aba9d680191de54edd1a6462f7529747889f6540a282fb509283859a69f42ec299a29f96089c42841fab1d28b59d765124f06acbf125857717111d9c6e32ee694ec4d62163180f9336072d0380fa76d12d628f4b1c6a831d6bb9bca67fcb1c6c8717a32b3f70f67fe5444882e66dc16a977364eb1295c6cf68ced1cfb2b4ab0fc42ab9e7c67a47b319609250d69cfc4245794a500787c55ed6da1ba188355e416acde0458a2f2197a3fec0ceb8e52c2374f1f7127b9666df428162ddaa8433d9c0d890918a0359d8a307a4a35363cda78d8ac2fde860c31bf14573cfb044485b47579ec867e00bd0caadf74d7a2298c146c59cdcf3194efb7161fd38edc4f76b469f24d2369f7e52ed852065326096d384708cd5aa79c258e3210ab8eb8c3f78f710e92742349a147cf46ad303cd7aca5c3dc9df804caa726deaa48a122bd3ccfffe6ddb35b8897e82f811d1413025d34bc2b6954d05e7c22e5a0acf8462c48159440293c9cbc9d9118b8ec71fbc3cdea05a71501aee182cbfcde2f88403f398b10257f0f64b14a2a467e353d61534d076231764f71078cbbc1fadbece02cc8a73c0741975ce60b35dfa02726bdb0d9f16f456d446535e61ddd5cd116c26da4b73f2874c0e3144f803d94b2f923ce0003db4874b0019c9fed3c4455a197480302c9a7470e5f02d22987baed37f4a1425b330b5e93e84e7c2c5175e029ff6aa909f3b9fcb8a6e7c88420833acf57457c15b7436413e5db5c941e18702ef27f0c4952ee999c96159006e16885a62ab9cecf954ed79e3897a6c6d5f5a140ccb9aba804330ddefea460af58b91e9a10243f8f412711cbdccbdc0f1139975d081ffa68af29e6c842fedd9a7814ce9f88c569f8b0ded0355c469f355113e3d30534d3ec1bb23885f9bc122d0984c44b795ae65a5be52d6e827cf1f2502e09dff3e1d67f8b206fcfa22dc15a9f7b802e9956359275a52d26cf7df222a04f82e26266e33e400ea6faa8e790bf7051459bf87013a614109860cb31300805450e3683265621c8389817064ed51e43aeade62e251b324528fdc1904f4991b8e5d0d7975f5875669c2c8d3f965cc05fd1ab9f71e6ea638ac69a6cf4ea9b72ff337ece5fea85906584c48d5ae133a29cd557574e69221b03156d8008e7da886ab90c87318eedb10756f5bb8f7264621094710e8de6742350903f2896d1a52ee4a3fd2ffb91231a4bd0bd599af4cb38c2a215473b5f884348f8f79f8a8f5cbbe5fc972cbd0a00715b87f35f674f670475b1b6ecf83834b725a4938fc8b6dbdaec50abe9f2edd3747208b1f213e05952679241288c9601f29e5745b0716dd4bc6a0dbd2abd28c6441fca636d2d0f4815117d9768d2927407839f9df0485d9281045cf86cd6a07a0a0ba79b4195f0a1c3a3977d3c3b8be7732c71430450fe21aa7e25d5ff72636240976edb429444c8e06a8034cba97c76244ba2f5a6ae3c6ff27f9c20544f89592c2edca786b32bdb47c25c2a7692c25423897dace711445390b5863b07165742cdfc816980daf7352c8e4c0b13e7082ddb37476a7ffd632a9c1c7dce017a870fbe420d20071a50a9e984d9d55b242696f2c44b425d8646b1dcc453b587bcf891cb5180ac98a1319f5ff88a091bf98a4009e1d3c6f0edda50e20415eff0c74555c52319b9add0003d03f7abaadaaccbf7b558026550c39d2bb98c55739596835512c41639a6db27769804dc755304c3f0bf230b9236d881c0aecf10014a0549f416c4fd5c6b7ce4eeb45a253de412aa7db96ce2f0b8b554757d6f1fb9ce43b39d1f059445f631c5c272293cac6941eda9b6c380cf1b47b4f55f2a930edc48e1cd86754e6224f4e74a0ff6458f387a7df5c2c0680f2f0fb6f25c26909ed8234539ac431c3dd088603c31d7a3682550209d854d1e7b2767bc45eea98787160ae652ea70d3d627282e87c20ba404dd6aa058908ae8b2ce564fa381101dff0b9016a9cd926c83225bb3d0d6ddc7cf5cc6d0c13ca6d204993f1e35ddbd95339fd20c45102efbf136b5951a4be1e6954d8d65032eb7fab7f7e8191cdb42a676d4987a1d14c7ac00b74aa2988712598e3b93e9421e87892d0350f88c1a9d1c8f090e98a0390a10f0eac73b55ef4fea75ceb79cfa50595d91e403beb0391f4a1c5cd60d38bab4754115818690b8a238ad66345807cbbd2e0b69ddf602120add94cbe3a706e826b4bb47c86c5f9599891e8443bcc6c04dac55bfc458fed5c881f995a18ba5604d05d4fb01281a9f2cd0a062b7e6b4a4d2c7f657757f448515aa884e0874660ced85c3620e10e1e33c3bbb216e33adf14fa95f30f85e5afe861949a08533cdaea4817fd32a2d59da42496b74791b7f62673de8fa4635107e5bbc01848e6fa70acbfe8ee3a093b4fd264a0c03365459d17fb7db50541d782129beb89107b2a0f18aaafccf8f34364a754dd10d5c000b6c8529a9872499c854c6febf8d158219de398ffcab152a18e03c4d2ee79dcf6e10aeb0b17e470a30a406b85551789925c290c2d1969db29ace80686027f62f218eeeb136c6541509130cd898865a3befef178f6cb4a5f3d4118dc493762fd5aa129710090c1caa40477f4383d7e520d7d5e9de39037e8ce5e3a8961d2d9376c0127742a3e42ef01e311d3f54112f3aadeb92f0ff4633db6bce55b43ac7f01512d7e087632564c247913bca66911bda72cf70761e3e4724074ec9050d8f0ce1bf0a05a2c2c6e6bafc343280e6a0d60604552a23175fe1db721a7b5378d6e8060193282f0d349d6bd0a0400f50e9e4cfd3122e5be26687e2323479a59dd4d03ab3fc004a6ab172ee19d051ab5f70fa5d6bafc65ebcc30ff359964c8c427c4569eb8be78cae7ec642fd9f823ae3f2e08d4d006201fb8098597b8cfb6d6c0efe84a798f4b50796361e0c6152080686327b916390b64f43f81d295cbe53d1c6a0528ec885e1d041c756e02cb938e5b410617edfcf56b66b3ea56a2c97853c3adcc458c4e7c2c4e4db11e79016e59f0c35f52220a4a29dbf22c2d03388b39395423130e65a498ef969e44b92d4d6d2cc22001becd01dc9689bc9c7f62874d70a1ef6d1bd114e0d979e5c7c223bba994c59f1bfb4e4e83400b9b029cc8e98b0f327c2afea64526ab7a468871ddadb874f4ae51493815714d86f7760ab7ec87873dac2108e6da6297078eabdc2fa2e499fee6064c887320abad093b030c4932fedafe985258688f161874277941b7a7e2f7492990956f1ab049003e75d39fbb8faa453c394c4ec2a743495ca06a058f21e0cc3506c23bdba88ae944934b2281eeba8d30331fcec3d81b8e9db2a299824655d56d005c2ca53e40c5042766d4a6e2b6dac071c4e1f25f624c4a3648850fab2c8dc7b3983f6ca60c9568dd925b9c55e594a0080abc76fc09ee50f9a12ce14dc1fdf3db6cc40bc04c2b41ba3b2a304776cb9f6e8c36f5a280818bf49c0b6bc491d1a42a1fefde7ca591f553f3f56a687291b1c163646cd807ee100f085fd871a1c0ba3570ffe5d9a3e76d0a162bc4cfdd149ee202f0cce1d153c5c986509cc90931c9a414083276d3af187fbf3618555b0d52f60664518b3e2ced8aae815c8b44dde554ec5ddb05640ef20c2a266a40d4e242e67e1e4d797c2879121f28be8143a484605f70d494b63e1d346b4fe69cdb79ca220d4246368e7c507a2bcd9025f02d95d77e309b506cd98e9071e0dce02720ddce1215024c4edb89193248a132af81ab84a3ce887fb9b1735dad5fa370949ddf1776fba25c57c49ab190895f8e684f193cac4f54998d1453c96fd8bb4e09c72c8530ea66dad9f14dbfe00f50082a019d38d92f974d43b318849f8a5fdac1a758069c677e417f016179718564db1305bb0d86269743bf8bd493605f0ccca1cfcc4c682d345cadd2b74064f2b6126c3829c786ad5acc93991b33225e54ea340eb4d0088874f2615519748c4a01ffe4bc827b69f7fdd451167303d49aecde69e4136a1461479719217c3487f7b392c611ada78bab57a7ce3c4f36530f6e4b09d5e0398856b89e429c06afdeb72024928915e2cba0c5e94318a149628c6ea4dad7042a6bf9870358f7439f060e0134d3541e3f160006cc63495d7b87e739b94b1cd98dbcac8cf6faa5eaaefa85cdf7421e37086a008a4ef496e03c6d57e2cb3c72c55b83d98aa93c7ee3da0352776d9537d3ddbd0d30023a34edb16100dc24c67b3fa12c4859b55626bcb681bd88ee9648d88dbe31c344314b116e6b3bd853f53fe33363f5ed5cd89f055445715bbf7dbbeff3bb78d190313b59425f2902209b0d07f90e237a7a805dea163ba925b7daca365f5706e19d0308862a55a176dee05fefa8c15d6a2fdddb889a0797a47334046480799ea968fb663463afc31bc6cb2713da89f33804421807b9a2b5d169e63dfb1358d2a7500a6796b935fb4629ea30e4404d84326e4a864ab92d9529cc29a1202371a490dcbd5d90ff3c1f8f4599271b42f7a02d4e1d088bee835564fd385fa6b631b989c9821e4f9fe76e04ec5c1c722629fe24c3a2b316a66b101639bb3845fd5f23f6830da0c1906b08d663f5502ce40e9b66250b234a73b676057be9baa47a9b7872</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      私有文章, 请输入密码查看。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2022/06/28/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2022/06/28/Java 反射机制/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2024-03-19T03:23:36.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么叫反射"><a href="#什么叫反射" class="headerlink" title="什么叫反射"></a>什么叫反射</h1><p>Java中我们创建对象一般都是用“<strong>new</strong>”这个关键字的，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"Ervin"</span>);</span><br></pre></td></tr></table></figure></p><p>反射则是一开始不知道要初始化的对象是什么，所以没办法new出一个对象，这时候就需要用到反射，例如我们使用第三方SDK的时候有可能没有提供api，只能通过反射去获取类中的方法等。按照上面生成对象的例子，使用反射是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"com.ervin.entity.Person"</span>);</span><br><span class="line">Method method = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line"><span class="comment">//Object person = cls.newInstance();</span></span><br><span class="line">Constructor constructor = cls.getConstructor();</span><br><span class="line">Object person = constructor.newInstance();</span><br><span class="line">method.invoke(person, <span class="string">"Ervin"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>直接new对象是静态模式，在代码编译前就知道需要生成什么对象；反射是在运行时才知道要生成什么类，是动态的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么叫反射&quot;&gt;&lt;a href=&quot;#什么叫反射&quot; class=&quot;headerlink&quot; title=&quot;什么叫反射&quot;&gt;&lt;/a&gt;什么叫反射&lt;/h1&gt;&lt;p&gt;Java中我们创建对象一般都是用“&lt;strong&gt;new&lt;/strong&gt;”这个关键字的，例如&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>怎么看懂UML类图</title>
    <link href="http://yoursite.com/2022/05/19/%E6%80%8E%E4%B9%88%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <id>http://yoursite.com/2022/05/19/怎么看懂UML类图和时序图/</id>
    <published>2022-05-18T16:00:00.000Z</published>
    <updated>2022-05-19T13:05:47.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h1><p>请看一下这个类图，类之间的关系是我们需要关注的：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2dzjchqwhj20ns0bjt8w.jpg" alt="UML例图"></p><ul><li>车的类图结构为《abstact》,表示车是一个抽象类；</li><li>车有两个子类小汽车和自行车，它们之间的关系为<strong>实现关系</strong>，<em>使用带空心箭头的虚线表示</em>；</li><li>SUV是小汽车的一种，继承自小汽车，他们之间是<strong>泛化关系</strong>，<em>使用带空心箭头的实线表示</em>；</li><li>小汽车和轮胎和发动机为<strong>组合关系</strong>，表示轮胎是小汽车的一部分，<em>使用带实心箭头的实线表示</em>；</li><li>学生和班级之间是<strong>聚合关系</strong>（下面会介绍和组合关系的区别），<em>是用带空心箭头的实线表示</em>；</li><li>学生和身份证之间为<strong>关联关系</strong>（下面会介绍和组合关系的区别），<em>使用一根实线表示</em>；</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖关系</strong>，<em>使用带箭头的虚线表示</em>；</li></ul><a id="more"></a><p>下面我们来解释这六种关系</p><h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)，继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt><br>eg：汽车是一个抽象概念，在现实世界中有对应的实现，可以用汽车定义具体的对象；汽车和SUV之间为泛化关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt></p><blockquote><p>泛化关系在代码中表现为继承非抽象类（继承）</p></blockquote><h2 id="实现关系（realize）"><a href="#实现关系（realize）" class="headerlink" title="实现关系（realize）"></a>实现关系（realize）</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt></p><blockquote><p>实现关系在代码中表现为继承抽象类（实现）</p></blockquote><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；聚合与组合的区别在于，<strong>聚合的两个部分不是强依赖，即使A不存在了，B也仍然存在；例如，部门撤销了，人员还在。</strong></p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt></p><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；<strong>组合的两个部分是强依赖的，A不存在了B也就不存在了，例如公司不在了，部门也就不存在了。</strong></p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt></p><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；例如，乘客和车票之间是一种关联关系，学生和学校是一种关联关系，关联关系默认不强调方向，表示对象间互相知道。如果要强调方向，如下图则表示A知道B，但是B不知道A（直线加箭头）</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt></p><blockquote><p>在代码中，关联对象通常是以成员变量的形式实现的</p></blockquote><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt><br>与关联关系不同的是，它是一种临时关系，通常在运行期间产生，并且随着运行时变化依赖关系也可能发生变化；显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><blockquote><p>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从一个例子开始&quot;&gt;&lt;a href=&quot;#从一个例子开始&quot; class=&quot;headerlink&quot; title=&quot;从一个例子开始&quot;&gt;&lt;/a&gt;从一个例子开始&lt;/h1&gt;&lt;p&gt;请看一下这个类图，类之间的关系是我们需要关注的：&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h2dzjchqwhj20ns0bjt8w.jpg&quot; alt=&quot;UML例图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;车的类图结构为《abstact》,表示车是一个抽象类；&lt;/li&gt;
&lt;li&gt;车有两个子类小汽车和自行车，它们之间的关系为&lt;strong&gt;实现关系&lt;/strong&gt;，&lt;em&gt;使用带空心箭头的虚线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;SUV是小汽车的一种，继承自小汽车，他们之间是&lt;strong&gt;泛化关系&lt;/strong&gt;，&lt;em&gt;使用带空心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;小汽车和轮胎和发动机为&lt;strong&gt;组合关系&lt;/strong&gt;，表示轮胎是小汽车的一部分，&lt;em&gt;使用带实心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生和班级之间是&lt;strong&gt;聚合关系&lt;/strong&gt;（下面会介绍和组合关系的区别），&lt;em&gt;是用带空心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生和身份证之间为&lt;strong&gt;关联关系&lt;/strong&gt;（下面会介绍和组合关系的区别），&lt;em&gt;使用一根实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生上学需要用到自行车，与自行车是一种&lt;strong&gt;依赖关系&lt;/strong&gt;，&lt;em&gt;使用带箭头的虚线表示&lt;/em&gt;；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>消息推送</title>
    <link href="http://yoursite.com/2021/06/18/%E6%B6%88%E6%81%AF%E8%A7%92%E6%A0%87/"/>
    <id>http://yoursite.com/2021/06/18/消息角标/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2023-03-20T10:33:42.213Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de6fc2fc2e67b35badf9526d75d94b4099e25897edc1ed1cd27dfca66ff12468">ebb08aa0288e261ddeb0b4aadf3d63d97e083ffaa0d4fa6b0c85289138924abbcf55a51af6c61cc4e373f667829e744f297ead5b8ee0f05f1a1a314d5dcb43ec76920a6242ea186c7ac4c823ac240210604dd1f63554e8be529c7182901ec87e81a62424a23c4364a55f2f5cb46c75b0b4856ad7860f807f0fe8a3a7a093e5b9e2734dbcced5ce7b35f6a7d404fe0c2fe03565e36cf3390639c0ad9121691a3f3cc9f74975e2d7ceb1ae2f7d6976705f06c0d4b5532022cd04debf0b98463322dbe52640c64c6f9f382d86c5899a7c07b32e9c0ada1cffbd13689b7021b083c80b8131b0d6d8037f122a4254d5a19fff319731a42fb50bd4014c8dcf8841d9c564d9b1c649614e071aa0752b10698886f617c628f326792ff4373ab9ad7ff5119dcbcecbb0ac574fc259d399d118c8e9d64ad51cb2b05f557fa8d79d028218bb5137963848854014dc709240160001fb4e0ace1bbb80566921e18531973392d825445e6fd72d6df3e7d648c92b5acdb5d866e4a66d8bcc2dd8c9682aae048f644efc0f8ea40ffc7d0bc2ca23b23746e5082ffad301a82f04044604755d574eac68b3e49f2bfb104c47b94332e01523d60a5fcb020969458538203d72fd7676d7f65137ddc33ba48404257dad30eb8613ab55a6459a7dc8dff4e31e0f16073403f946bd08d317839f63994a55bf4a7f8fb8e19ff2f9c2f81b0b3ef81c1bc829dc9615eb71593a34e8282f9b7708251b55a9a8767467add8a3ecd091c48d249f91014099274ae89a6544cc873cd1a02b05346ed669aba0977b1bed5f2ba3c624db41c35e078b3db8faf672d2760710c3952c8cdd2877f43f4440d5eeb52255e32d4e54b2573d50cde71edacf8393108d77649136848532ff293d3051b04ea91eb737ab0a6d689325e9755b9ea29cb867158b6c8e922a33fbf5ef4e3c0de9a4450d82bfc3e71543c7a61fec53b88e97cc4080cc98f6272adf2ef7c7feb2128e192c1db289db60ec27cfd7115b4bb0ff0453c3fe3731bac12d1d667f024e11345c78eccf742b9d1c4ae079e109487609e6b03f8aa47bf565e1ca17e3fc308d44964647151a25a4ed09078a68b42cdf06c9f507a1d79924453f81a8f796c6a89ec7b0395ba0f5534eb95732fc3deb8d69f6bdd1b05a527d3efe70c70460e376d35212362d49a78f098679593920ebe9ff2e1c9cc90e80d15504749dbdfc1ea34a13863ce3789bd027d48e6b41773368af20ccf98c6458b661e8de933b18c2b38d582d9cc2b15888c84c961d3e950dff5694e77cddee13235f37605872f4e083f425c04b26410ea8fad146fbcab7a22c7ff90d337714bb7d20acae105fe5ffe95cf5e2d38c3e69e03507020a48fbda7d9cae636f2a4cff15a6c639e96a6a55cd040ad997f2b58e4c394275b4c43540ed7466e131abf8a4cb7e1e4cb9542099ca8c3430612e503c7833cbc8794478311729e110d922cc0c7de08edf21ba2c26a93f1e87799f5d79ca07c30d2a443e61906f43fa2d5090e7f39f39b8b49215a7778e6e456d6917e40888815c4b221226787e04fadc8b7ae531c56dfcb7f68f5ac4ad303e04a994f8ef0733852e69f1629c8d525a3ed6c15effff1b0cee7bf4ea686391470e905b92ba102fe03b6621cf2877eb9e449400666926675bd915f06533c4d718f1ea302ef2c82cce2f36bca792836b88d5d5882d3ba223b8c1dd034c2246e4efe4eab32ea8b19ff05e9b99c73d1004dee06fd57f784afd853e0f2f35ef91e32e115fdc4b0a1c7d1e9f0de41eda611585b5552c8c52a4c8afaedb2f58ecf74702b9ef07761aa56e2788daee33ae8bcbb6eb284d116690240be2667b1639328209922d36dcc836f9ff8755ff38e7af8c8740efe9a17621836b77dd63197fd265bf4b759559d0cb74eccee9733cd97860ac7b1ced4ddc388924c4605dbf6430c45b526416c01c9c505a5cd741dbc44008129915e8dc030b628bfa6bf490a9c79684e9176e770542e0f3b94f98b6a7394ebfd00b2f4033845df166f6f5e297f4df5210e495e01e799924f3bddfa06f8f63dd9fc8ed29c74ddc26e470d60e63481d7c9e99329e0fdbd2534b6e13ae9afbd60af003a22d4c902888612a9c6be0d14861e56538b5ecccc6d8eaa03fb1c7b6bb53eb114cb45bbcd941c4a592cf25f65d8bc9ff1f9de46e1f4bd967461ce053f3122641c477d4ee864c104f9af188682e64d33c9b3ae874f94298843fe530686283220f3b2fa91769ff59a956e24563370616215a0f42fb5095336fc3ebbf8106558d7ea42a560c1d7102c205ec10557615a2a502acf5a24bf19860e922943a0b00b8e978259b2e4e6321608b2a1c9394c38a4d7f8db48df1f49aa3863586f8c7077f97fa6f78e1b044b828c59dcbf31c7a040128aa43e8059f87793ef82c28941edc84d20f97b80445f5fb42153b61ea1207a819b1f2847662f2c5d6694b02347f5e9df1701a84c3d37bd9f4d48e6ebe66e3e15711820cb03b00ce6ee1f709e285b750a6c5ef28c03850c204b16e6f4e3889a72f4059b59816ada92abdbca3a307ee1fabbe1b7e995a5490bd7b85e5c716e26a702c02274134933756c61d56bd45170bbed30e85e8ba6dd35c2001d159c5197870675e728828be24bc9a0e7505873f31ccc09d32893b5c2dccca3b083ba7d8cb902fafcfe2b8bb7eabb0e97abd2d5c899715ca5b19b6e29f9b10d2db797e4bd5b800863a301bcdf96576e745b8ac37e4c0a75e6387a078e7015dc7ff9c9e264e19ed049b40a0dc2d9cb2146fec587a8309a137675f5fa9e5e832a13c78c74acb254369edfd8a7621c78d6bf60c8b85bf5fc52ed868a365b973597aee079dd814c9c8c9b77c3ca96546eb54ce5e51b93441fe9f2ceaebad9f5a8227696ccf2da9ca67dc2676ee03bf1c78231c33620e9157c92ecdd3a9bf778f0a55061ee959f7bd6a75118a9279d44dfca3a9a146c80752ea2db9c6df930010d44d7b055db4b239e101b0a61d6249435ca665c08719d42b5c9a309cc1f921443d4a414aebf4183a7555d4e60cb3fb546b9c962460daa0ab9d95460997b62dd7a5758cec0c4d5918d9c3c67e58fba9872d7cac13cb064a07c1b5fb9e7c53b13e4602f72d7dee8f1baa480b040ee1717e159f93fc179c5005190c8a9254dd4ae526cbcfe251a7b6a9673b3525f6fca7fc2c752bf60717d96b3613299bcbded852feff693bf7d8df3447148aa561004a5f5600d1eae76318829126a4e5381461d8667cb784a1ef63e1d4d8aab4650d3c1239b301edec2e20349cda440dcbc59719fb163185d56dd661a8d43d762db45d429793933bba3545f1b7505d583ab37a6c374587f41c9a66b3755ac84152b205f5f270f0bb22847f784009a07af7f2067baec08edadc70dd31cb2c61f9f3596ee8a423e2d5f91d323ff91b6e8eb2b87798ea0ab7cfbb112a56ce08e780c0501710113c146bbdc533c0291803ade7d573d4ca6b887bfbfcd491ec6e3ce3c3f71029e3afb991d67f52ab7df524a91a526392899fed6fb8d383a88e4b8e4a92b0405062c4a6518e32d780ad07340f5cf835f7c3bd1021987a275693d209efc0ea5054d0b2b5ea7496eac6f9b8195bd5361b411c610b299c107719b768e99980f70c3c2c7efe0c70375031f376144df7e4dc12764adc5036e8a0b3419b55a89b311bb20fa2e56510c54e2d08f7943274937650a0f554186cbf6453f4de7e7c6c48ad3c43eb4588cdb771c8c0548bb638756f78598e07da813f63f79b26a6416b80a83fe56087131b3de99788753dd957ce3018968914f67b1f9b0d5948d8df8f885b5db0fb28170dc5f2d004d6b520650e1a9462c02a7f67f03bf2d114a5c9b77dd3e3a5a2f6bf4a97c8a18ce3d2b5034dcc97739c932ebc8a881d6971c0404c242aeb4b12ac31fadd529b14bdd35bb43b0329388bfd39e74264a7cce099b4fc2c5ba800230df12cdfb0d5f364c05b091c3c26cdb03a2f089156bd2115221d6ca5452aa1a5ec79f304b6b7c6f760ad7e7aa0da94de716c3333803086d8fe5700fc996c551fc7fa81f6c1324e4f7eeaad5c6fea714858edbd8ee63119a7828eb8c28e56d13e291f9258e48dd3d458b3b443c5a476c0d4febb33b35d93d194393d34fa6d61f569685334d0857f10b78557738963386ddcc1796acf2bd86da9b051700697aacbe72c32a4c6a2c8a740971883e4817d4163de86551635a39b4f5414602bcc2a27ee21013b3f104aab74539d0291552a388065ae67ae7dd5417a64cfb5c6561490513d7711aa565645c7b77b71220a7332e8045eb3ec0cf7f338311e579770431c965cdc1080bf8f64d7a78e3df227f406074e237101be2dcfc6336d4afd58677c0f19c39d373f58d19f495195681e9e2cb8bc6f79438a3c876e67479b6e68fdf820ab0ae6216d3677447c589bf34039c1f4af232b22733f2724148525bfca1366c26641e6c8bacbcde294e704ef11b1cce7fc6850cca2c0d3bb2657dd6898c0e0475e229f5f098db4002f379555043fb513d82009e41fcfa440815690bed940f8b0517ef2ea314e2b8a9f13833fae5016035e3686d560bb4484c392553d515685706f2cef0a770f2a3164c8fd026ed0aa843e96ae6d18ec6ebea1e88a4bfc4fd31a7d01a885e31604ffb669cfbf2384911704962170e5a2d8276122d799a5a1ecc363067cb7326838ead311480682947d0bee87143e0ddea39d21f46a0783c43726e5622dc910464681168a215b1a7b3ec1dabe4b945cc5f96b39b113770bd20fcebb3b7e3b43b8061dbbc79604b96e7b76c17d23226d68d5fd2ad6c73713a148b210d490333de7d8ccca2889a55d776d736ad779f1bf5a3295b2d171f1020e2c0f94dec511f5efcee97557a3089d9da14bca53049a84a14d15c5f0e9eff1d5927f7e8033a96195673c0e090066c1a4fda8e9b2943f818076e33f0a1421f72de9d5d77cb9e64a2fc854e330f93e77421f73ed9c27438d8f5eb6f55030efaf5fb81bb63b0f6df4d2a6d45f190a28c3f75a1b543dcceddff4bba1fe60b75509a0274d0fbf8e31b4bd4ac4c2b97bb8a7063b982a46d552fd1ca980290f54f305482e2e6d7553df6c376636263ffb83409eabe573a50a68239f8b1d15676bf6a1fe4a426f76862cfc81958483efdcc9896e9b99eeed7fd635aa13c64b362c34d298aea25bc82c61ad81e256138d820decb08952ac47b88b01216281c0744ae760db93e38c834089482c8e5b1352e2cc72469a54c192c23117da9eec65377136fb557a991b38afb8ffaff6f394c3681d9a97548b51cdca1c13cc5587540d0bfd38df2d68462197a859f6042419af3bb613efcf9d427cabf3bd4b23733459fd5a45c2f5f79f848a8628e2ad89fd825d52a1970e529691e24003f14878fffc88c0c7d59921bb450772dbe061c880c848f2cba6c46dcfe57fcf3adbc3b24f4bbd6c05bff24088751e4ec880db13539ac747986799b17ef4a0cc97b15297002b059c1b0c72d26ee6accc6c78093826b21434b915ffc891b9369003d183ed6d1ab4d99b2a8e4c7d48f751a2a6937058c55d866cade33bb7a9a110f8806dd4d77036980f03765a911932e84b99ec630502b0fd429f062c27646b24433dabd0fec60322b641b499728995de132a1f34a15b7f92f9b7c72f2f88ca99a6ce1d3ffc1ab43b458a64bac3b3afc6bb9cd342b01b9400686a2d805618abb254799a092c69735c7d19524b8858d6ed0af57519a90eb5bae7fd3bcd351d745db39d66192a58ceb062ea52b913a1b418ce2eb9068d41a204ab2aa2351d144aa66976972725a732ec3455f132694c4dc0fb95a62240aad2eaff7e06368ecd49d760af311064c95768b1df1eff6a1ef5e8515f1bfdfaac169cdfed2ea185ff183ea0b32fcc5e742071c1eff0dac4fcb309a6d6799f86bc51d387bd1bdc3dceae802b010a10c9cab8f8c1f8272d22f0aea4c0ea1276452af30dbb1915a3d0c93d71299faf7a10eca8bc9eb9153af4361a4c9235a10afabc77e053ce0e8a8e9aafb44c7ee24bd3851ead18da66864260b1dad3ec16954a1524c243f22c65aa3ae81869b62f602273f0a27d1215b2e17c130d7e3c3df0a96b7cd7e707ebf325579703bad2b3d9d520fe8aa1c686f7f1c75297f9da0ebd950606259b831aaf2c1d6f560460e3453a6cdeceabb04c5635f9b126236d109ed291bf9ae10756c538e1dfd2f8ba5bdfec23a990bdd8de82e2ceed5b0ccf954708e6dd3ab3fde27539bc5262937189c55c023919363a20991f3d11e246a90f86c1cf788c45f1a77b07ad80949096238b7fd943b293edb536a78f1791aa608a571fc4cefdb4fe1856e79b1763bb4bf66e5dcd8035f0c4bd2306cb50bb2b3a29c6dea5be91cc7dc9d68bd4c507ebdd968ac5dd801cea602625edf1180f74ba43e5273ce19313b50596a0ddc6ca38c8df2aa4cac18bc57891fc85974026daef7a3de7619ac7a61a58b411eb68c6756ec2ab98cce661d9a197808eff2097a0882a6603bddbc6379a9f044614b152f1bfe1e57e54dd60cf8a0de95af7d59d172a56c2f2afa817d40fe7fd05ea0ba35e1d11badcd82092bafab49365c9921db585a175f2b7237cd9844d1eb4cf705cc73cb985a33166b8524f13e08a959b4c98b6bd0efa2ae8435ed4d2c68a453ab17d93a90ab00d3bf57e8eaa6b9e864819317d6631262c4cff2aa4624793d8961b4d01813c1a74e7f9420a94a41f86b2862f3df8ce213a62193b5dba5821fa1e2f815631f67ce7aa358610d2d64013f7be85035a3d5a13887e4334e57d728e2e1f75c8e20e39a3c0333748e102d044753e9838e19270a6b25553b3dbc2880fcae555e8da0272b4504263c97dedd6bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      私有文章, 请输入密码查看。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="私有" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>私有文章</title>
    <link href="http://yoursite.com/2021/06/18/%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1%E8%A7%86%E9%A2%91%E8%80%97%E7%94%B5%E5%8F%91%E7%83%AD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2021/06/18/网易云信视频耗电发热测试/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-07-13T06:19:44.445Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed5b4123d3dd01d0b4c26fc99d2677193a3d3ccb41059dd8e047dbdace86dd3b">ebb08aa0288e261ddeb0b4aadf3d63d97e083ffaa0d4fa6b0c85289138924abb58fc845e64c0eda53c9f4fcd54bf3827408f21a6ad76ce5425911ef71b0f09e723d169da98587c817a43570f7e7809670feab795c2445b2e3fdefd7c17e8e86b7212beb6c324748abb2bf27a6a09abf239f8c672a62c87341541007be7eaf829330fd67354180b7537fb8118be1da28fa39338be4ae42596ee1e0f8c29a5c8b60ee3010e769baa600cebd1cfeddccdd0db38bc76f0cff0b2d83a3cd308d0eb8bdce45c7c7b114e7e048b218e9d0bd62137de2ecc82a1dea264a6e23a6081e19ba49bb5e79396bf434e8d7c9281a138b008dbe2cb616c5c3e20600281dcaa9c93b5e5e3a4d225fe7263d3dc740b67b4ac285c60aadf0b2696ac1fe9d4bcfef3ea1c5aafe19c5fe0aca81db85bd3a3fa1a4931ebbce0fb0b9aef2571eba9887ce136697cbe3f8c472463d5e748aeff5e029ef28300271f66f1f7b151a40176ff49302cce536143f8ed48b4a22d004751536315129da5cdce793a1589b4139a65669f78250d13b0dcd8456c71daaa31fd7532e681a264153bfa0a24bf5c93146fe7bffbc72d105a27079780c7879d66710325e5e195c8efbc8a417074f3b09abaf368977fd4cc668810cd3a7dc753782c333b5b915fbd173b80390afc591bef62fda47ea928e5252e412de907fca7b388f880f7e827651b623cee3bcc8498698178f17430460db95f6c190d4fd8f539211c5095090253e4c0a55e0db5c4b735b481582bb5e18bc965c87c22ee910cb604d0b0d2551d4f2c8bdc5569c938aee2dc601a1e1a1eae3fe12c8a24159f608cf42a791287ca5112d315c69c4906344f2a702f5433862693eb303eb14a39234f9694de9bd0f74d40bb66f93d9f7bf74e91d969f5a9690aeded109b025c24d92f9666b4fa429409601fb7a257fc68e24475a9ddbee8e8240523af2c59ad8ff077a570578a7976c86a4bf10612eae84ce8dac3c7b69b321f7b09aadadb37ef8d918acb62e2a7fd97fc15b21e7ec9446c18bbd30d0c94f541f36561ebf08e39be1c160fe16acd70c34b004ec851d5b38bc3a849ad975413d23be403bb49a51fff51d98c7470a91ae5df8631826e4e89d8e9fc2e5d67b0e44fad1e32d90ebd3a1983e583f24858fc255540d8a9d26fa19af1045ebe8565e5b4954950016f3ae5b718e4b6e285aa593f8dce3518863e2c533c2191f680eb09a823c8a1874a042946fc153daa27f5e54dcb655a3f9170a1bb9b06783f7b94e7462c0992c2cb7469ac5a0750ae39319ebc1ee357eff995c62cd3a3a2e8d113441ba9411a7e1d30ed2216fea9cb94ee7cfffbabccb6e491fed263a7c7944eccfdb5d46a9a974f2f3a14445a239670667aa801ae5338cef76ec96d147e0441a52beb3d73496a07d189a078a6f4002684cae075683fc7b8b8c8fe4e55c3796fcae198ceceec5e6b2189268b373a4a330c869c21e5ef9449238b3e0c73fdd66058f730301f5c6e670ccaf2eda9992e61e515aad4eb7abcf17295888fb0cf32d5a476e8892f60241006644085339f2bf3e5c231547b372d89c4b30cc835906454ba48034d2ad0e771b8757dbae8421e46561533378c2632fb71c1a71dbe4e38c9da9f9a99d85a2328035f768496f0d0708940675ff30abcf246a7c55058dc08714340d10cd52645f29e17d1e314eb61ffbb5c407284e41af5fe54043b3e3fd75bd67825f011a1b8468c5e83b94f94ccec67598ae0e217bb499a1b9bd7dc1a358e301e302c61af34145aa21da58815944910531dee414570d22c20fc3543fae37c5f00d0f6890926b8baae725d6cc305915d8bc225f72f43a5606a87a0cdd8b958a9b190cdbc6fc4b3ba758aced4f1d072fbdb5c1101faab5c6a138dfa01229739d2ce7d1febc97a8eae39111647d6375e5408b60965c37eb30d16de9143faf8825997ce832039e036237c62d1ff4dfe8391e63d84c4519437662fa7d16cb9c0fb5bfd81643604621a469a2ea86afc31cbeeb8544b66f5ab6f6722c13d0d0863ed5371d23671bebc1ab21c19153802f0c22f2c294da442cb75624564159a86e903138c42111facda84fc05d4fda5a21cf0b684ccdbd3d0eb3e37ad5d18cf1d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看.
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="私有" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊LRU算法及LinkedHashMap</title>
    <link href="http://yoursite.com/2020/07/23/%E8%81%8A%E8%81%8AHashMap/"/>
    <id>http://yoursite.com/2020/07/23/聊聊HashMap/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-08-04T08:19:57.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以前聊过HashMap的数据结构，其实就是一个数组+链表<a href="https://ervinsae.github.io/2018/11/30/Android内存优化（一）/" target="_blank" rel="noopener">Android内存优化</a>。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。</p><a id="more"></a><h1 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h1><p>LinkedHashMap是Map接口的哈希表和双向链表实现，继承了HashMap，其基本操作与父类相似，采用的Hash算法和HashMap一样。<strong>其实其数据结构基本和HashMap是一样的，只是Entry不一样，除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链表列表。</strong>HashMap的Entry是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><p>而LinkedHashMap的Entry则多了before和after：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br><span class="line">Entry&lt;K, V&gt; before; <span class="comment">//上一个元素的引用</span></span><br><span class="line">Entry&lt;K, V&gt; after; <span class="comment">//下一个元素的引用</span></span><br></pre></td></tr></table></figure><p>next指针是每一个数组后面的链表，而before和after则是整个LinkedHashMap的元素顺序，看图可能更好理解：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheuq9kpiaj30kj0autae.jpg" alt><br>正是由于拥有before和after指针，所以LinkedHashMap是有序的而HashMap是无序的</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>先来看例子：HashMap是无序的，而LinkedHashMap是有顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己可以打印输出结果看到，它不是按照put顺序的，同样的数据我们换成LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果完全和put顺序一致。<br><code>key：name1，value：josan1</code><br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code></p><p>以上只是LinkedHashMap其中一种双向链表的存储顺序特性：<strong>插入顺序</strong>(输出完全和插入顺序保持一致)，并且这个为LinkedHashMap的默认顺序。通过默认构造方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure></p><p>我们看下同样的数据，换一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line"></span><br><span class="line">hashMap.get(<span class="string">"name1"</span>)</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多了一行代码，先get了一个元素<br>打印结果:<br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code><br><code>key：name1，value：josan1</code></p><p>这就是LinkedMap另一种牛逼的存储特性叫：<strong>访问顺序</strong> 其通过带参数的构造方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a>LinkedHashMap的实现</h2><ul><li>成员变量</li></ul><p>来看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。（默认为false）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表的表头元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedHashMap的Entry元素。</span></span><br><span class="line"><span class="comment">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，在LinkedHashMap的构造方法中，实际调用了HashMap的相关构造方法来构造一个底层存放的table数组。（如果没有指定initialCapacity的大小，系统默认是1&lt;&lt;4也就是16），这里需要注意的是accessOrder参数，如果不设置默认为false，代表按照插入顺序迭代，如果为true，则代表可以按照访问顺序进行迭代。（访问顺序迭代这个特性可以用在LRU算法中，这个后面单独弄一期）。</p><ul><li>初始化</li></ul><blockquote><p>这一块很多分析源码的都说有init方法，但是看了下发现没找到这个方法，先暂存</p></blockquote><ul><li>存储（PUT）</li></ul><p>LinkedHashMap并没有重现父类的put的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是重写了当key存在时的afterNodeAccess方法，这个方法在HashMap中是一个空方法，这个操作就是把节点移动到最后（看这个参数accessOrder），实现访问顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>LinkedHashMap 重写了父类 HashMap 的 get 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个 LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用带参数的构造方法。</p><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种特性很适合构建 LRU 缓存。LinkedHashMap 提供了 <em>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) </em>方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">LinkedHashMap 的实现原理</a></p><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">图解LinkedHashMap原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/93103619" target="_blank" rel="noopener">HashMap 最新底层原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;以前聊过HashMap的数据结构，其实就是一个数组+链表&lt;a href=&quot;https://ervinsae.github.io/2018/11/30/Android内存优化（一）/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android内存优化&lt;/a&gt;。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>AtomicBoolean详解</title>
    <link href="http://yoursite.com/2020/07/14/%E5%9F%BA%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84AtomicBoolean/"/>
    <id>http://yoursite.com/2020/07/14/基于CAS思想的AtomicBoolean/</id>
    <published>2020-07-13T16:00:00.000Z</published>
    <updated>2024-03-19T03:26:02.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。</p><a id="more"></a><h2 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h2><p>先看下AtomicBoolean的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(expectedValue, updateValue)</span></span>;</span><br></pre></td></tr></table></figure><p>我们看到了上面提到的一个在java并发中非常重要的一类算法：<strong>CAS：compare And set比较设置</strong>。我们用上面方法为例来解释下CAS的思想。当内存中可见的值如果和期望的值（expectedValue）一致，则将内存中的值修改为新值（updateValue），并且返回true。该操作是原子性的，意思是线程安全的。当多个线程同时访问某个对象时，如果其中一个线程通过CAS操作获得了访问权限，则其他线程只能在该线程处理完之后才能访问。<strong>这类似于同步关键字synchronized但是效率更高</strong>，因为没有锁的机制，即使在JDK7之后进行过优化。下面会举例子说明，在多线程中这种原子操作的必要性。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//demo.executeAtomicLogic();</span></span><br><span class="line">                    demo.executeLogic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//synchronized (this) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (bFlag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    bFlag = !bFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码是用一个boolea值来简单判断其它线程是否能进入业务代码执行，我们想看到的是线程1执行完后才能执行线程2，我们来看下结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggry7p6nl7j31780jaq5g.jpg" alt></p><p>可以看到这个结果是相当混乱，所有线程都抢占了资源。我们再看下使用了AtomicBoolean来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    demo.executeAtomicLogic();</span><br><span class="line">                    <span class="comment">//demo.executeLogic();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAtomicLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aFlag.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                aFlag.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrylt0w8sj30y20bo403.jpg" alt></p><p>和加锁的效果完全一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>八一八强引用、软引用、弱引用、虚引用</title>
    <link href="http://yoursite.com/2020/07/13/%E5%85%AB%E4%B8%80%E5%85%AB%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/13/八一八强引用、软引用、弱引用、虚引用/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T07:30:48.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们都知道JVM的垃圾回收机制中，GC判断<strong>堆中的</strong>对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。</p><a id="more"></a><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>先说说引用，Java中的引用，类似C语言中的指针。都知道Java分为基本类型和引用类型。有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的。JAVA中一切皆对象，无论你是直接操作对象本身，还是通过指向对象的引用来间接操作对象，都是采用统一的一种方法。</p><p>在 JDK 1.2 之前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 refrence 数据是代表某块内存、某个对象的引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。比如我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）<br>这四种引用强度依次逐渐减弱，Java中引入这四种引用的目的是让程序自己决定对象的生命周期，JVM通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。<br><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0519%2F5654b36aj00qakom4000jd200lw008lg00i90075.jpg&amp;thumbnail=690x2147483647&amp;quality=75&amp;type=jpg" alt><br>其中FinalReference类是包内可见，其它三种引用类型均为public，可以在应用程序中直接使用。</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在Java中最常见的就是强引用，就是直接new出来的对象都是强引用，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person就是一个强引用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person（）</span><br></pre></td></tr></table></figure><p>当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收器回收的，即使该对象用用不会被用到也不会被回收。当内存不足，JVM开始垃圾回收，对于强引用的对象，就算出现了OOM也不会对该对象进行回收，因此强引用有时也是造成Java内存泄漏的原因之一。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为null，一般就认为是可以被GC回收的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongRefenenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = o1;</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//null</span></span><br><span class="line">        System.out.println(o2); <span class="comment">//java.lang.Object@2503dbd3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尽管o1已经被回收了，但是o2强引用了o1，所以不会被GC回收。o1指向的内存为null，但是o2指向的原来o1的内存对象是不会被回收的。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对强引用弱化了一些的引用。它用来描述一些还有用，但是并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。</p><p>对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line">        System.out.println(<span class="string">"------内存不够用的情况------"</span>);</span><br><span class="line">        softRefMemoryNotEnough();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());<span class="comment">//不会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置`-Xms5m -Xmx5m` ，然后故意new一个一个大对象，使内存不足产生 OOM，看软引用回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get()); <span class="comment">//会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用通常在对内存敏感的程序中，比如告诉缓存就有用到软引用，内存够用的时候就保留，不够用就回收。Android中图片库Glide就是用到软引用，还比如Mybatis缓存类SoftCache用到软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    SoftReference softReference = (SoftReference)<span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (softReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = softReference.get();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.delegate.removeObject(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">                <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.size() &gt; <span class="keyword">this</span>.numberOfHardLinks) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。弱引用需要用WeakReference类来实现，它比软引用的生存周期更短。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakRefDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference w1 = <span class="keyword">new</span> WeakReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(w1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//被回收</span></span><br><span class="line">        System.out.println(w1.get());<span class="comment">//被回收 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方文档说弱引用常被用来实现规范化映射，JDK中的WeakHashMap就是一个这样的例子（ThreadLocal中也用到弱引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"k1"</span>);</span><br><span class="line">       String value = <span class="string">"v1"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       System.out.println(map);<span class="comment">//不会被回收</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       WeakHashMap map = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">       <span class="comment">//String key = "weak"; //key指向一个JVM字符串常量池中的"weak"字符串</span></span><br><span class="line">       <span class="comment">// 刚开始写成了上边的代码</span></span><br><span class="line">       <span class="comment">//思考一下，写成上边那样会怎么样？ 那可不是引用了</span></span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"weak"</span>);</span><br><span class="line">       String value = <span class="string">"map"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       <span class="comment">//去掉强引用</span></span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       System.out.println(map);<span class="comment">//被回收，因为只被一个弱引用引用（WeakHashMap的原理）</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也称为“幽灵引用”，是一种最弱的引用关系。顾名思义，就是形同虚设，与其它集中引用不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。如果一个对象仅持有虚引用，那么它就和没有任务引用一样，在任何时候都可能被GC回收，它不能单独使用也不能通过它来访问对象，虚引用必须和引用队列（RefenenceQueue）联合使用。虚引用主要作用是跟踪对象垃圾回收的状态，仅仅是提供一种确保对象finalize后可以做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p><blockquote><p>设置虚引用的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理。</p></blockquote><p>Java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phantomRefDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException  </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(o1,referenceQueue);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">    o1 = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll()); <span class="comment">//引用队列中</span></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。SoftReference,WeakReference,PhantomReference都有一个可以传递ReferenceQueue的构造器。创建引用的时候，可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们都知道JVM的垃圾回收机制中，GC判断&lt;strong&gt;堆中的&lt;/strong&gt;对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
</feed>
