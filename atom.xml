<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-04T08:19:57.431Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊一聊LRU算法及LinkedHashMap</title>
    <link href="http://yoursite.com/2020/07/23/%E8%81%8A%E8%81%8AHashMap/"/>
    <id>http://yoursite.com/2020/07/23/聊聊HashMap/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-08-04T08:19:57.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以前聊过HashMap的数据结构，其实就是一个数组+链表<a href="https://ervinsae.github.io/2018/11/30/Android内存优化（一）/" target="_blank" rel="noopener">Android内存优化</a>。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。</p><a id="more"></a><h1 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h1><p>LinkedHashMap是Map接口的哈希表和双向链表实现，继承了HashMap，其基本操作与父类相似，采用的Hash算法和HashMap一样。<strong>其实其数据结构基本和HashMap是一样的，只是Entry不一样，除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链表列表。</strong>HashMap的Entry是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><p>而LinkedHashMap的Entry则多了before和after：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br><span class="line">Entry&lt;K, V&gt; before; <span class="comment">//上一个元素的引用</span></span><br><span class="line">Entry&lt;K, V&gt; after; <span class="comment">//下一个元素的引用</span></span><br></pre></td></tr></table></figure><p>next指针是每一个数组后面的链表，而before和after则是整个LinkedHashMap的元素顺序，看图可能更好理解：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheuq9kpiaj30kj0autae.jpg" alt><br>正是由于拥有before和after指针，所以LinkedHashMap是有序的而HashMap是无序的</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>先来看例子：HashMap是无序的，而LinkedHashMap是有顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己可以打印输出结果看到，它不是按照put顺序的，同样的数据我们换成LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果完全和put顺序一致。<br><code>key：name1，value：josan1</code><br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code></p><p>以上只是LinkedHashMap其中一种双向链表的存储顺序特性：<strong>插入顺序</strong>(输出完全和插入顺序保持一致)，并且这个为LinkedHashMap的默认顺序。通过默认构造方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure></p><p>我们看下同样的数据，换一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line"></span><br><span class="line">hashMap.get(<span class="string">"name1"</span>)</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多了一行代码，先get了一个元素<br>打印结果:<br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code><br><code>key：name1，value：josan1</code></p><p>这就是LinkedMap另一种牛逼的存储特性叫：<strong>访问顺序</strong> 其通过带参数的构造方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a>LinkedHashMap的实现</h2><ul><li>成员变量</li></ul><p>来看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。（默认为false）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表的表头元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedHashMap的Entry元素。</span></span><br><span class="line"><span class="comment">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，在LinkedHashMap的构造方法中，实际调用了HashMap的相关构造方法来构造一个底层存放的table数组。（如果没有指定initialCapacity的大小，系统默认是1&lt;&lt;4也就是16），这里需要注意的是accessOrder参数，如果不设置默认为false，代表按照插入顺序迭代，如果为true，则代表可以按照访问顺序进行迭代。（访问顺序迭代这个特性可以用在LRU算法中，这个后面单独弄一期）。</p><ul><li>初始化</li></ul><blockquote><p>这一块很多分析源码的都说有init方法，但是看了下发现没找到这个方法，先暂存</p></blockquote><ul><li>存储（PUT）</li></ul><p>LinkedHashMap并没有重现父类的put的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是重写了当key存在时的afterNodeAccess方法，这个方法在HashMap中是一个空方法，这个操作就是把节点移动到最后（看这个参数accessOrder），实现访问顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>LinkedHashMap 重写了父类 HashMap 的 get 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个 LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用带参数的构造方法。</p><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种特性很适合构建 LRU 缓存。LinkedHashMap 提供了 <em>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) </em>方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">LinkedHashMap 的实现原理</a></p><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">图解LinkedHashMap原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/93103619" target="_blank" rel="noopener">HashMap 最新底层原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;以前聊过HashMap的数据结构，其实就是一个数组+链表&lt;a href=&quot;https://ervinsae.github.io/2018/11/30/Android内存优化（一）/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android内存优化&lt;/a&gt;。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>AtomicBoolean详解</title>
    <link href="http://yoursite.com/2020/07/14/%E5%9F%BA%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84AtomicBoolean/"/>
    <id>http://yoursite.com/2020/07/14/基于CAS思想的AtomicBoolean/</id>
    <published>2020-07-13T16:00:00.000Z</published>
    <updated>2020-07-15T13:06:40.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。</p><a id="more"></a><h2 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h2><p>先看下AtomicBoolean的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(expectedValue, updateValue)</span></span>;</span><br></pre></td></tr></table></figure><p>我们看到了上面提到的一个在java并发中非常重要的一类算法：<strong>CAS：compare And set比较设置</strong>。我们用上面方法为例来解释下CAS的思想。当内存中可见的值如果和期望的值（expectedValue）一致，则将内存中的值修改为新值（updateValue），并且返回true。该操作是原子性的，意思是线程安全的。当多个线程同时访问某个对象时，如果其中一个线程通过CAS操作获得了访问权限，则其他线程只能在该线程处理完之后才能访问。<strong>这类似于同步关键字synchronized但是效率更高</strong>，因为没有锁的机制，即使在JDK7之后进行过优化。下面会举例子说明，在多线程中这种原子操作的必要性。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//demo.executeAtomicLogic();</span></span><br><span class="line">                    demo.executeLogic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//synchronized (this) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (bFlag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    bFlag = !bFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码是用一个boolea值来简单判断其它线程是否能进入业务代码执行，我们想看到的是线程1执行完后才能执行线程2，我们来看下结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggry7p6nl7j31780jaq5g.jpg" alt></p><p>可以看到这个结果是相当混乱，所有线程都抢占了资源。我们再看下使用了AtomicBoolean来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    demo.executeAtomicLogic();</span><br><span class="line">                    <span class="comment">//demo.executeLogic();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAtomicLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aFlag.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                aFlag.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https:<span class="comment">//tva1.sinaimg.cn/large/007S8ZIlgy1ggrylt0w8sj30y20bo403.jpg)</span></span><br></pre></td></tr></table></figure><p>和加锁的效果完全一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java并发，能力提升" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%EF%BC%8C%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>八一八强引用、软引用、弱引用、虚引用</title>
    <link href="http://yoursite.com/2020/07/13/%E5%85%AB%E4%B8%80%E5%85%AB%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/13/八一八强引用、软引用、弱引用、虚引用/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T07:30:48.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们都知道JVM的垃圾回收机制中，GC判断<strong>堆中的</strong>对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。</p><a id="more"></a><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>先说说引用，Java中的引用，类似C语言中的指针。都知道Java分为基本类型和引用类型。有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的。JAVA中一切皆对象，无论你是直接操作对象本身，还是通过指向对象的引用来间接操作对象，都是采用统一的一种方法。</p><p>在 JDK 1.2 之前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 refrence 数据是代表某块内存、某个对象的引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。比如我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）<br>这四种引用强度依次逐渐减弱，Java中引入这四种引用的目的是让程序自己决定对象的生命周期，JVM通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。<br><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0519%2F5654b36aj00qakom4000jd200lw008lg00i90075.jpg&amp;thumbnail=690x2147483647&amp;quality=75&amp;type=jpg" alt><br>其中FinalReference类是包内可见，其它三种引用类型均为public，可以在应用程序中直接使用。</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在Java中最常见的就是强引用，就是直接new出来的对象都是强引用，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person就是一个强引用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person（）</span><br></pre></td></tr></table></figure><p>当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收器回收的，即使该对象用用不会被用到也不会被回收。当内存不足，JVM开始垃圾回收，对于强引用的对象，就算出现了OOM也不会对该对象进行回收，因此强引用有时也是造成Java内存泄漏的原因之一。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为null，一般就认为是可以被GC回收的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongRefenenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = o1;</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//null</span></span><br><span class="line">        System.out.println(o2); <span class="comment">//java.lang.Object@2503dbd3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尽管o1已经被回收了，但是o2强引用了o1，所以不会被GC回收。o1指向的内存为null，但是o2指向的原来o1的内存对象是不会被回收的。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对强引用弱化了一些的引用。它用来描述一些还有用，但是并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。</p><p>对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line">        System.out.println(<span class="string">"------内存不够用的情况------"</span>);</span><br><span class="line">        softRefMemoryNotEnough();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());<span class="comment">//不会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置`-Xms5m -Xmx5m` ，然后故意new一个一个大对象，使内存不足产生 OOM，看软引用回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get()); <span class="comment">//会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用通常在对内存敏感的程序中，比如告诉缓存就有用到软引用，内存够用的时候就保留，不够用就回收。Android中图片库Glide就是用到软引用，还比如Mybatis缓存类SoftCache用到软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    SoftReference softReference = (SoftReference)<span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (softReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = softReference.get();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.delegate.removeObject(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">                <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.size() &gt; <span class="keyword">this</span>.numberOfHardLinks) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。弱引用需要用WeakReference类来实现，它比软引用的生存周期更短。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakRefDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference w1 = <span class="keyword">new</span> WeakReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(w1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//被回收</span></span><br><span class="line">        System.out.println(w1.get());<span class="comment">//被回收 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方文档说弱引用常被用来实现规范化映射，JDK中的WeakHashMap就是一个这样的例子（ThreadLocal中也用到弱引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"k1"</span>);</span><br><span class="line">       String value = <span class="string">"v1"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       System.out.println(map);<span class="comment">//不会被回收</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       WeakHashMap map = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">       <span class="comment">//String key = "weak"; //key指向一个JVM字符串常量池中的"weak"字符串</span></span><br><span class="line">       <span class="comment">// 刚开始写成了上边的代码</span></span><br><span class="line">       <span class="comment">//思考一下，写成上边那样会怎么样？ 那可不是引用了</span></span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"weak"</span>);</span><br><span class="line">       String value = <span class="string">"map"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       <span class="comment">//去掉强引用</span></span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       System.out.println(map);<span class="comment">//被回收，因为只被一个弱引用引用（WeakHashMap的原理）</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也称为“幽灵引用”，是一种最弱的引用关系。顾名思义，就是形同虚设，与其它集中引用不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。如果一个对象仅持有虚引用，那么它就和没有任务引用一样，在任何时候都可能被GC回收，它不能单独使用也不能通过它来访问对象，虚引用必须和引用队列（RefenenceQueue）联合使用。虚引用主要作用是跟踪对象垃圾回收的状态，仅仅是提供一种确保对象finalize后可以做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p><blockquote><p>设置虚引用的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理。</p></blockquote><p>Java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phantomRefDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException  </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(o1,referenceQueue);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">    o1 = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll()); <span class="comment">//引用队列中</span></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。SoftReference,WeakReference,PhantomReference都有一个可以传递ReferenceQueue的构造器。创建引用的时候，可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们都知道JVM的垃圾回收机制中，GC判断&lt;strong&gt;堆中的&lt;/strong&gt;对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin内联函数</title>
    <link href="http://yoursite.com/2020/05/30/Kotlin%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/30/Kotlin内联函数/</id>
    <published>2020-05-30T09:16:33.000Z</published>
    <updated>2020-05-30T09:16:09.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin中内联函数的理解"><a href="#Kotlin中内联函数的理解" class="headerlink" title="Kotlin中内联函数的理解"></a>Kotlin中内联函数的理解</h1><p>kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。即那些在函数体内会访问到的变量。内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。</p><p>调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针移出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。</p><p>来看一个官方的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(l: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</span><br><span class="line">      l.lock()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> body()</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          l.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用这个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(l, &#123;<span class="string">"do something!"</span>&#125;)<span class="comment">//l是一个Lock对象</span></span><br></pre></td></tr></table></figure><p>对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果只要函数体类似这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l.lock()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"do something!"</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制大量重复代码，那么有没有一种机制，又能少些重复代码（变成一个可供调用的方法）又不会在调用过程中频繁压栈出栈影响性能呢。有的，这就是kotlin的内联函数inline所拥有的能力。</p><a id="more"></a><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>使用inline声明的函数，会在编译时将会拷贝到调用的地方。</p><h3 id="inline-function"><a href="#inline-function" class="headerlink" title="inline function"></a>inline function</h3><p>定义一个sum函数计算两个数的和</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为Java代码看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var1 = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的样子，在该调用的地方调用函数。</p><p>然后为sum函数添加inline声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void main(<span class="meta">@NotNull</span> String[] args) &#123;</span><br><span class="line">   int var1 = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   System.<span class="keyword">out</span>.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> int sum(int a, int b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再反编译为Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> var4 = a$iv + b$iv;</span><br><span class="line">   System.out.println(var4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sum函数的实现代码被直接拷贝到了调用的地方。上面的例子其实并没有体现inline的优势，因为拷贝代码和在调用的地方调用方法没有本质区别，但是如果你的函数中有lambda形参数，或者是参数为函数的时候，inline的优势才会体现（因为不会新建函数对象，可以减少内存损耗）。</p><h3 id="inline-function-with-lambda-parameters"><a href="#inline-function-with-lambda-parameters" class="headerlink" title="inline function with lambda parameters"></a>inline function with lambda parameters</h3><p>再来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123; <span class="comment">//sum方法中有一个函数参数</span></span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, @NotNull Function1 lambda)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">int</span> r = a + b;</span><br><span class="line">   lambda.invoke(r);</span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   sum(<span class="number">1</span>, <span class="number">2</span>, (Function1)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(Function1）null.INSTANCE，是由于反编译器工具在找不到等效的 Java 类时的显示的结果。</p></blockquote><p>我们传递的那个lambda被转换为了Function1类型，它是Kotlin函数的一部分，它以1结尾是因为我们在lambda函数中传递了一个参数。</p><p>再来看一个代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在循环中调用sum函数，每次都传递一个lambda函数打印结果，反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> var2 = <span class="number">10</span>; var1 &lt;= var2; ++var1) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, (Function1)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在每次循环里面都会创建一个Function1的实例对象，这里就是性能的优化点所在，如何优化呢？</p><ul><li>在循环外部建立lambda对象</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l: (r: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> = &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function1 l = (Function1)<span class="keyword">null</span>.INSTANCE;</span><br><span class="line"><span class="keyword">int</span> var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> var3 = <span class="number">10</span>; var2 &lt;= var3; ++var2) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只会创建一个Function对象，优化了原来在循环内部不停创建对象。</p><ul><li>使用inline</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">byte</span> var2 = <span class="number">10</span>; var1 &lt;= var2; ++var1) &#123;</span><br><span class="line">     <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">     String var9 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">     System.out.println(var9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda函数对象在编译的时候被拷贝到了调用的地方，避免了创建Fuction对象</p><h3 id="inline使用注意事项"><a href="#inline使用注意事项" class="headerlink" title="inline使用注意事项"></a>inline使用注意事项</h3><ul><li>public inline函数不能访问私有属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> title: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(l: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        println(<span class="string">"Title: <span class="variable">$title</span>"</span>) <span class="comment">// 编译错误: Public-Api inline function cannot access non-Public-Api prive final val title</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的没问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(l: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        println(<span class="string">"Title: <span class="variable">$title</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意程序控制流程</li></ul><p>当使用inline的时候，如果传递给inline函数的lambda，有return语句，那么会导致闭包的调用者也返回。</p><p>看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Start"</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 这个会导致 main 函数 return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)<span class="comment">//不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   String var1 = <span class="string">"Start"</span>;</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">   String var7 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">   System.out.println(var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译之后也能看到，lambda return之后的代码不会执行。（println（“Done”）没有执行）。怎么解决这个问题呢，不要使用return可以使用return@label语法，返回到lambda被调用的地方。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Start"</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)<span class="comment">//会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h2><p>当一个inline函数中，有多个lambda函数做为参数的时候，可以在不想内联的lambda函数前使用noinline声明。不会被拷贝代码到被调用的地方。</p><p>看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> lambda2: (result: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    lambda2.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">"Invoke lambda2: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, @NotNull Function1 lambda, @NotNull Function1 lambda2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> r = a + b;</span><br><span class="line">   lambda.invoke(r);</span><br><span class="line">   lambda2.invoke(r);</span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">byte</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   Function1 lambda2$iv = (Function1)<span class="keyword">null</span>.INSTANCE;<span class="comment">//lambda2新建了对象</span></span><br><span class="line">   <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">   String var8 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">   System.out.println(var8);</span><br><span class="line">   lambda2$iv.invoke(r$iv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译代码中可以看到使用inline声明的lambda形参函数被搬到了被调用的地方，而被noinline声明的函数则生成了Function对象。</p><h2 id="crossinline"><a href="#crossinline" class="headerlink" title="crossinline"></a>crossinline</h2><p>声明一个lambda函数不能有return语句（可以有return@label语句），这样可以避免使用inline时，lambda中的return影响流程导致某些语句没有执行。被crossinline声明的lambda函数如果有return语句会在编译时报错。</p><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, <span class="keyword">crossinline</span> lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 编译错误: return is not allowed here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 inline，内联函数到调用的地方，能减少函数调用造成的额外开销，在循环中尤其有效。</li><li>使用 inline 能避免函数的 lambda 形参额外创建 Function 对象。</li><li>使用 noinline 可以拒绝形参 lambda 内联。</li><li>使用 crossinline 显示声明 inline 函数的形参 lambda 不能有 return 语句，避免lambda 中的 return 影响外部程序流程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin中内联函数的理解&quot;&gt;&lt;a href=&quot;#Kotlin中内联函数的理解&quot; class=&quot;headerlink&quot; title=&quot;Kotlin中内联函数的理解&quot;&gt;&lt;/a&gt;Kotlin中内联函数的理解&lt;/h1&gt;&lt;p&gt;kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。即那些在函数体内会访问到的变量。内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。&lt;/p&gt;
&lt;p&gt;调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针移出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。&lt;/p&gt;
&lt;p&gt;来看一个官方的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(l: &lt;span class=&quot;type&quot;&gt;Lock&lt;/span&gt;, body: ()&lt;/span&gt;&lt;/span&gt; -&amp;gt; T): T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      l.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; body()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          l.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用这个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lock(l, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;do something!&quot;&lt;/span&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;//l是一个Lock对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果只要函数体类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;l.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;do something!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    l.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制大量重复代码，那么有没有一种机制，又能少些重复代码（变成一个可供调用的方法）又不会在调用过程中频繁压栈出栈影响性能呢。有的，这就是kotlin的内联函数inline所拥有的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（三）</title>
    <link href="http://yoursite.com/2020/05/27/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/27/Java线程池实现原理（三）/</id>
    <published>2020-05-27T02:20:00.000Z</published>
    <updated>2020-05-27T02:20:30.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">转自美团技术团队</a></p></blockquote><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>上一期讲了线程池生命周期管理的任务管理，对于线程池来说，任务管理和线程管理是它必须关注的事情，而线程管理比任务管理则更复杂。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="Worker线程（工作线程）"><a href="#Worker线程（工作线程）" class="headerlink" title="Worker线程（工作线程）"></a>Worker线程（工作线程）</h3><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker，先看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker这个线程，实现了Runnable接口，并持有一个线程thread变量，一个初始化的任务firstTask，thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值时非空的，那么线程就会在启动初期立即执行这个任务，<strong>也就是对应核心线程（corePool）创建时的情况</strong>，如果这个值时null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，<strong>也就是非核心线程的创建</strong>。</p><a id="more"></a><p>Worker执行任务的模型如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png" alt></p><p>线程池需要管理线程的生命周期，需要在线程池长时间不允许的时候进行回收。<strong><em><em>线程池使用一张Hash表去持有线程的引用</em></em></strong>，这样可以通过添加引用，移除引用这样的操作来控制线程的生命周期，这个时候重要的是如何判断线程是否在运行。 </p><blockquote><p>Worker是通过继承AQS，使用AQS来实现<strong>独占锁</strong>这个功能（每次只能有一个线程能持有锁，是针对共享锁而言的，AQS源码中其内部类Node定义来两个常量SHARED和EXCLUSIVE，分别就是共享模式和独占模式，标示了AQS队列中等待线程的锁获取模式），为的就是实现不可重入的特性去反应线程当前的执行状态。</p></blockquote><p>下图是Java中主流锁的分类：（锁的概念有很多，但是其实各种锁的维度是不同的，后面会详细深入了解）</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="java各种主流锁分类"></p><p>那么如何判断线程是否正在运行呢：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中</li><li>如果正在执行任务，则不应该中断线程</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</li><li>线程池在执行shutdown方法或者tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法使用tryLock方法来判断线程池中的线程是否空闲状态；如果是空闲状态则可以安全回收。 </li></ol><p>会在线程回收过程中也使用到了这种特性，回收过程如下图所示：<br><img src="https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png" alt></p><h3 id="Worker线程增加"><a href="#Worker线程增加" class="headerlink" title="Worker线程增加"></a>Worker线程增加</h3><p>增加线程时通过线程池中addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成，<strong>该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</strong> addWorker方法有两个参数：firstTask，core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空（和Worker线程中的firstTask差不多），<strong><em>core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize（核心线程数），false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize（最大线程数）</em></strong>，其执行流程如下：</p><p><img src="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png" alt></p><h3 id="Worker线程回收"><a href="#Worker线程回收" class="headerlink" title="Worker线程回收"></a>Worker线程回收</h3><p>线程池中线程的销毁依赖于JVM自动的回收，线程池做的工作时根据当前线程池的状态维护一定数量的线程引用<strong>（前面提到的用Hash表）</strong>，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<strong>Worker被创建出来后，就会不断的进行轮训，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。</strong>当Worker无法获取到任务，也就是获取的任务为空时，循环就会结束，Worker会主动消除自身在线程池内的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务（循环）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可以看出线程池回收时在processWorkerExit方法中完成的，下面是线程回收流程图：</p><p><img src="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png" alt></p><p>实时上，在这个方法中，将线程引用移除线程池就已经结束线程池销毁线程的工作了（等待JVM自动回收线程）。但是由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的状态，是否要根据新状态，重新分配线程。</p><h3 id="Woker线程执行任务"><a href="#Woker线程执行任务" class="headerlink" title="Woker线程执行任务"></a>Woker线程执行任务</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法执行过程是：</p><ol><li>while循环不断通过getTask方法来获取任务</li><li>getTask方法总阻塞队列中获取任务</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li><li>执行任务</li><li>如果getTask方法结果为null，则跳出循环，执行processWorkerExit方法，销毁线程</li></ol><p>流程图如下：</p><p><img src="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线程池生命周期管理&quot;&gt;&lt;a href=&quot;#线程池生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;线程池生命周期管理&quot;&gt;&lt;/a&gt;线程池生命周期管理&lt;/h1&gt;&lt;p&gt;上一期讲了线程池生命周期管理的任务管理，对于线程池来说，任务管理和线程管理是它必须关注的事情，而线程管理比任务管理则更复杂。&lt;/p&gt;
&lt;h2 id=&quot;线程管理&quot;&gt;&lt;a href=&quot;#线程管理&quot; class=&quot;headerlink&quot; title=&quot;线程管理&quot;&gt;&lt;/a&gt;线程管理&lt;/h2&gt;&lt;h3 id=&quot;Worker线程（工作线程）&quot;&gt;&lt;a href=&quot;#Worker线程（工作线程）&quot; class=&quot;headerlink&quot; title=&quot;Worker线程（工作线程）&quot;&gt;&lt;/a&gt;Worker线程（工作线程）&lt;/h3&gt;&lt;p&gt;线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker，先看一下源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractQueuedSynchronizer&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread thread;&lt;span class=&quot;comment&quot;&gt;//Worker持有的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runnable firstTask;&lt;span class=&quot;comment&quot;&gt;//初始化的任务，可以为null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Worker这个线程，实现了Runnable接口，并持有一个线程thread变量，一个初始化的任务firstTask，thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值时非空的，那么线程就会在启动初期立即执行这个任务，&lt;strong&gt;也就是对应核心线程（corePool）创建时的情况&lt;/strong&gt;，如果这个值时null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，&lt;strong&gt;也就是非核心线程的创建&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（二）</title>
    <link href="http://yoursite.com/2020/05/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/20/Java线程池实现原理（二）/</id>
    <published>2020-05-20T02:13:00.000Z</published>
    <updated>2020-05-20T02:13:58.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">转自美团技术团队</a></p></blockquote><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由线程池内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><strong>ctl</strong>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含了两部分的信息：运行状态（runState）和线程数量（workerCount），高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。这样做的好处是：源码中经常出现要同时判断上述两种状态的情况，这时候通过一个变量就可以获取，而不用为了维护两者的一致去占用资源锁，然后线程池也提供了很多方法供用户获取当前的运行状态和线程个数。这里都是用位运算，速度会比基本运算快很多。下面代码是一些线程池的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; //计算当前运行状态</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;  //计算当前线程数量</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;   //通过状态和线程数生成ctl</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：</p><table><thead><tr><th>运行状态</th><th>状态描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>能接受新提交的任务，并且也能处理阻塞队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</td></tr><tr><td>STOP</td><td>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程</td></tr><tr><td>TIDYING</td><td>所有任务都已经终止了，workerCount为0</td></tr><tr><td>TERMINATED</td><td>在terminated()方法执行后进入该状态</td></tr></tbody></table><p>其生命周期转换如下所示：</p><p><img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt></p><h2 id="任务管理机制"><a href="#任务管理机制" class="headerlink" title="任务管理机制"></a>任务管理机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。先来介绍一些基本概念：</p><p><strong>corePoolSize:</strong></p><blockquote><p><strong>线程池的基本大小</strong>，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。（线程池本身也要创建线程去执行任务，只是线程池维护了这些创建线程的生命周期，看什么时候需要创建，什么时候要销毁）</p></blockquote><p><strong>maximumPoolSize:</strong></p><blockquote><p><strong>线程池中允许的最大线程数</strong>，线程池中的当前线程数目不会超过该值。若果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largesPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么生活曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()来改变这个最大线程数目。</p></blockquote><p><strong>poolSize:</strong></p><blockquote><p>线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；poolSize也不会超过maximumPoolSize.</p></blockquote><p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在的线程池的运行状态、运行线程数目、运行策略、决定接下来执行的流程，是直接申请线程执行，缓冲到队列中执行，还是直接拒绝执行。参看上图任务分配机制。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount（线程数量） &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列（BlockQueue）没有满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize,且线程池中阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize,并且线程池内的阻塞队列已满，则根据<strong>拒绝策略</strong>来处理该任务，默认的拒绝策略是直接抛出异常。</li></ol><p>其执行流程如下图所示：</p><p><div align="center"><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" alt></div></p><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理</strong>，其中任务的管理相对是一件容易的事情，复杂的是线程的管理，这会涉及到线程池数量，等待/唤醒，同步/锁，线程创建和死亡等问题。线程池中以生产者消费者模式，通过一个阻塞队列来实现将任务和线程两者解耦的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p><p><strong>阻塞队列（BlockingQueue）</strong>是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者时往队列中添加元素的线程，消费者时总队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只是从容器里拿元素。下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p><p><div align="center"> <img src="https://p1.meituan.net/travelcube/f4d89c87acf102b45be8ccf3ed83352a9497.png" alt></div></p><p>使用不同的队列可以实现不一样的任务存取策略，在这里，我们可以再介绍下阻塞队列的成员：(针对不同场景使用)</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁</td></tr><tr><td>LinkedBlockingQueue</td><td>一个由链表结构组成的有界队列，此队列按照先进先出的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong></td></tr><tr><td>PriorityBlockingQueue</td><td>一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序</td></tr><tr><td>DelayQueue</td><td>一个实现了PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素，只有延迟满后才能从队列中获取元素</td></tr><tr><td>SynchronousQueue</td><td>一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个只用场景是在线程池里。Executors.newCachedThreadPool()就使用了这个队列，这个线程池根据需要（新任务到来时）创建新线程，如果有空闲线程则会重复使用，线程空闲了60s后会被回收（需要关注使用场景）</td></tr><tr><td>LinkedTransferQueue</td><td>一个由链表结构组成的无界阻塞队列，相比与其他队列，LinkedTransferQueue队列多了transfer和tryTransfer方法</td></tr><tr><td>LinkedBlockingDeque</td><td>一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半</td></tr></tbody></table><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>由上文的任务分配部分可以知道，任务的执行有两种可能：</p><ol><li>直接创建新的线程来处理。（在线程初始创建的时候）</li><li>线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次从队列中申请任务去执行。（大多数时间线程池工作的情况）</li></ol><p>线程需要从任务缓存模块中不断的取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现。其执行流程如下：</p><p><img src="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png" alt></p><p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态，如果线程池现在不应该持有那么多线程，则返回null。工作线程Worker会不断接收新任务执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。（怎么判断线程是否为可回收）</p><h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量（maximumPoolSize），当线程池任务队列已满，并且线程池中的线程数目达到最大容量，就需要拒绝执行该任务了，采取任务拒绝策略来保护线程池。</p><p>拒绝策略需要实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p><table><thead><tr><th>序号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>ThreadPoolExecutor.AborPolicy</td><td>默认方式，直接丢弃任务并抛出RejectedExecutionException异常。在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现问题</td></tr><tr><td>2</td><td>ThreadPoolExecutor.DiscardPolicy</td><td>丢弃任务，但是不抛出异常。使用此策略，可能使我们无法发现系统的异常状态。</td></tr><tr><td>3</td><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</td></tr><tr><td>4</td><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由调用线程（提交任务的线程）处理该任务，这种情况是需要让所有任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线程池生命周期管理&quot;&gt;&lt;a href=&quot;#线程池生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;线程池生命周期管理&quot;&gt;&lt;/a&gt;线程池生命周期管理&lt;/h1&gt;&lt;p&gt;线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由线程池内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（一）</title>
    <link href="http://yoursite.com/2020/05/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/13/Java线程池实现原理（一）/</id>
    <published>2020-05-13T02:57:46.030Z</published>
    <updated>2020-05-18T02:49:08.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h2><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，或者涉及到一些复杂线程操作需要重复开启线程。线程过多会带来额外的开销，包括创建线程的开销，调度线程的开销等等，同时也降低了计算机的整体性能。<br>线程池能维护多个线程，等待监督管理分配可并发执行的任务，这种做法一方面避免了处理任务时创建销毁线程开销的代价，另一方面也避免了线程数量膨胀的过分调度问题，保证了对内核的充分利用。<br>Java中对线程池的实现都是基于ThreadPoolExcutor类，它能带来一系列的好处：</p><ul><li><strong>降低资源消耗：</strong> 通过池化技术重复利用已经创建的线程，降低线程创建和销毁造成的损耗</li><li><strong>提高响应速度：</strong> 任务到达时，无需等待线程创建就可以立即执行（前提是线程池中有可用的线程）</li><li><strong>提高线程的可管理性：</strong> 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。不用开发者自己去维护这一整个流程。</li><li><strong>提供更多更强大的功能：</strong> 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><a id="more"></a><h2 id="线程池能解决什么问题"><a href="#线程池能解决什么问题" class="headerlink" title="线程池能解决什么问题"></a>线程池能解决什么问题</h2><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。这种思想也广泛应用于计算机的其它领域中：</p><ul><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。例如Sql连接池</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。例如String。</li></ul><h1 id="Java线程池核心设计于实现"><a href="#Java线程池核心设计于实现" class="headerlink" title="Java线程池核心设计于实现"></a>Java线程池核心设计于实现</h1><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>Java中的线程池核心实现类是ThreadPoolExecutor，首先分析UML类图，如下：</p><p><img src="https://p1.meituan.net/travelcube/912883e51327e0c7a9d753d11896326511272.png" alt="ThreadPoolExcutor UML类图"></p><p>具体分析：</p><p><strong>Executor：</strong> ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦，用户无需关注如何创建线程，如何调度线程来执行任务，用户只需要提供Runable对象，将任务的执行逻辑提交到执行器（Executor）中，由Executor框架完成线程的调配和任务的执行部分。<br><strong>ExecutorService：</strong>接口增加了一些能力：</p><ol><li>扩充执行任务的能力，补充可以为一个或是一批异步任务生成Future方法</li><li>提供了管控线程池的方法，比如停止线程池的运行。</li></ol><p><strong>AbstractExecutorService：</strong>是上层的抽象类，将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法即可。<br><strong>ThreadPoolExecutor：</strong>最下层的实现类实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时还需要管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>下图是ThreadPoolExecutor的运行机制：</p><p><div align="center"><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt></div></p><p>从图中可以看出来，线程池内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p><p>线程池的运行主要分成两部分：<strong>任务管理</strong>，<strong>线程管理</strong>。<br>任务管理：充当生成者的角色，当任务提交后，线程池会判断该任务后续的流转：</p><pre><code>1. 直接申请线程执行该任务2. 缓冲到队列中等待线程执行3. 拒绝该任务</code></pre><p>线程管理：线程管理部分是消费者，他们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务，线程就会被回收。</p><p>下一节继续按照下面三个部分去介绍线程池的运行机制：</p><ol><li>线程池如何维护自身的生命周期</li><li>线程池如果管理任务</li><li>线程池如何管理线程</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h2 id=&quot;线程池是什么&quot;&gt;&lt;a href=&quot;#线程池是什么&quot; class=&quot;headerlink&quot; title=&quot;线程池是什么&quot;&gt;&lt;/a&gt;线程池是什么&lt;/h2&gt;&lt;p&gt;线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，或者涉及到一些复杂线程操作需要重复开启线程。线程过多会带来额外的开销，包括创建线程的开销，调度线程的开销等等，同时也降低了计算机的整体性能。&lt;br&gt;线程池能维护多个线程，等待监督管理分配可并发执行的任务，这种做法一方面避免了处理任务时创建销毁线程开销的代价，另一方面也避免了线程数量膨胀的过分调度问题，保证了对内核的充分利用。&lt;br&gt;Java中对线程池的实现都是基于ThreadPoolExcutor类，它能带来一系列的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗：&lt;/strong&gt; 通过池化技术重复利用已经创建的线程，降低线程创建和销毁造成的损耗&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高响应速度：&lt;/strong&gt; 任务到达时，无需等待线程创建就可以立即执行（前提是线程池中有可用的线程）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高线程的可管理性：&lt;/strong&gt; 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。不用开发者自己去维护这一整个流程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供更多更强大的功能：&lt;/strong&gt; 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaGuide之AQS</title>
    <link href="http://yoursite.com/2020/05/12/JavaGuide%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2020/05/12/JavaGuide之AQS/</id>
    <published>2020-05-12T06:21:34.000Z</published>
    <updated>2020-05-12T07:18:30.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">文章转载：一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</a></p></blockquote><p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p><p>本文关注以下几点内容：</p><ol><li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li><li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li><li>深入理解 Java 线程中断和 InterruptedException 异常</li></ol><p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">上一篇文章中对 AbstractQueuedSynchronizer 的介绍 </a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p><p>其实这篇文章的信息量很大，初学者估计<strong>至少要 1 小时</strong>才能看完，希望本文对得起大家的时间。</p><a id="more"></a><!-- toc --><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 <a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer</a> 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p><p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。</p><p>2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue</p></blockquote><p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/" target="_blank" rel="noopener">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p><p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。</p><p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">  <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p><blockquote><p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p></blockquote><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="condition-2"></p><blockquote><p>这里，我们简单回顾下 Node 的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表</p></blockquote><p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p><ol><li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li><li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li><li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ol><p>上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p><p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 </p><p>这个图看懂后，下面的代码分析就简单了。</p><p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到 condition 的条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class="line">    <span class="comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p><h3 id="1-将节点加入到条件队列"><a href="#1-将节点加入到条件队列" class="headerlink" title="1. 将节点加入到条件队列"></a>1. 将节点加入到条件队列</h3><p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class="line">    <span class="comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t 此时是 lastWaiter，队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。</p><p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p><p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全释放独占锁"><a href="#2-完全释放独占锁" class="headerlink" title="2. 完全释放独占锁"></a>2. 完全释放独占锁</h3><p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p><blockquote><p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">// 那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">// 相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p></blockquote><h3 id="3-等待进入阻塞队列"><a href="#3-等待进入阻塞队列" class="headerlink" title="3. 等待进入阻塞队列"></a>3. 等待进入阻塞队列</h3><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p><h3 id="4-signal-唤醒线程，转移到阻塞队列"><a href="#4-signal-唤醒线程，转移到阻塞队列" class="headerlink" title="4. signal 唤醒线程，转移到阻塞队列"></a>4. signal 唤醒线程，转移到阻塞队列</h3><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。</p><p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待了最久的线程</span></span><br><span class="line"><span class="comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class="line"><span class="comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// true 代表成功转移</span></span><br><span class="line"><span class="comment">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class="line">    <span class="comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class="line">    <span class="comment">// 否则，将 waitStatus 置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class="line">    <span class="comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p><h3 id="5-唤醒后检查中断状态"><a href="#5-唤醒后检查中断状态" class="headerlink" title="5. 唤醒后检查中断状态"></a>5. 唤醒后检查中断状态</h3><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p><p>等线程从挂起中恢复过来，继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断，返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p><p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p><h3 id="6-获取独占锁"><a href="#6-获取独占锁" class="headerlink" title="6. 获取独占锁"></a>6. 获取独占锁</h3><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p><h3 id="7-处理中断状态"><a href="#7-处理中断状态" class="headerlink" title="7. 处理中断状态"></a>7. 处理中断状态</h3><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p><ul><li>0：什么都不做，没有被中断过；</li><li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li><li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。</p></blockquote><h3 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h3><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p><h3 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h3><p>关于 Condition 最后一小节了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，贴一下代码大家就都懂了，我就不废话了。</p><h2 id="AbstractQueuedSynchronizer-独占锁的取消排队"><a href="#AbstractQueuedSynchronizer-独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer 独占锁的取消排队"></a>AbstractQueuedSynchronizer 独占锁的取消排队</h2><p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p><p>接下来，我想说说怎么取消对锁的竞争？</p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的。</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了。</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p><hr><p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p><h2 id="再说-java-线程中断和-InterruptedException-异常"><a href="#再说-java-线程中断和-InterruptedException-异常" class="headerlink" title="再说 java 线程中断和 InterruptedException 异常"></a>再说 java 线程中断和 InterruptedException 异常</h2><p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p><blockquote><p>Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p></blockquote><p>关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">   doWork();</span><br><span class="line">   System.out.println(<span class="string">"我做完一件事了，准备做下一件，如果没有其他线程中断我的话"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。</p></blockquote><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p><p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p><ol><li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p><p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p><blockquote><p>这几个方法的相同之处是，方法上都有: throws InterruptedException </p><p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p></blockquote></li><li><p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p><blockquote><p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p></blockquote></li><li><p>Selector 中的 select 方法，参考下我写的 NIO 的文章</p><blockquote><p>一旦中断，方法立即返回</p></blockquote></li></ol><p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。</p><p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p><h3 id="InterruptedException-概述"><a href="#InterruptedException-概述" class="headerlink" title="InterruptedException 概述"></a>InterruptedException 概述</h3><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p><p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p><p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 </p><p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了。</p><h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p><p>我们经常会这么写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go on</span></span><br></pre></td></tr></table></figure><p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p><p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span></span><br><span class="line">        <span class="comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span></span><br><span class="line">        selfInterrupt();<span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p><p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"> ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。</p><p>欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md" target="_blank" rel="noopener">推荐系列</a><br><a href="https://juejin.im/post/5c6e7dcf51882562547ba9f9#heading-17" target="_blank" rel="noopener">推荐系列2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/AbstractQueuedSynchronizer-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章转载：一行一行源码分析清楚 AbstractQueuedSynchronizer (二)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。&lt;/p&gt;
&lt;p&gt;本文关注以下几点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深入理解 ReentrantLock 公平锁和非公平锁的区别&lt;/li&gt;
&lt;li&gt;深入分析 AbstractQueuedSynchronizer 中的 ConditionObject&lt;/li&gt;
&lt;li&gt;深入理解 Java 线程中断和 InterruptedException 异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本上本文把以上几点都说清楚了，我假设读者看过&lt;a href=&quot;http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章中对 AbstractQueuedSynchronizer 的介绍 &lt;/a&gt;，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。&lt;/p&gt;
&lt;p&gt;其实这篇文章的信息量很大，初学者估计&lt;strong&gt;至少要 1 小时&lt;/strong&gt;才能看完，希望本文对得起大家的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot之事务</title>
    <link href="http://yoursite.com/2020/03/03/Spring%20boot%E4%B9%8B%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/03/Spring boot之事务/</id>
    <published>2020-03-03T08:24:41.861Z</published>
    <updated>2020-03-04T08:18:00.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的事务机制"><a href="#Spring的事务机制" class="headerlink" title="Spring的事务机制"></a>Spring的事务机制</h1><p>所有的数据库访问技术都有事务处理机制，这些技术提供了API用于开启事务，提交事务完成数据操作，或者在发生错误的时候回滚数据。Spring的事务机制是用统一的机制来处理不同数据访问技术的事务处理，Spirng的事务机制提供了一个PlatformTransactionManager接口，不同的数据访问技术的事务使用不同的接口实现，如下表：</p><table><thead><tr><th>数据访问技术</th><th>实现</th></tr></thead><tbody><tr><td>JDBC</td><td>DataSourceTransactionManager</td></tr><tr><td>JPA</td><td>JPATransactionManager</td></tr><tr><td>Hibernate</td><td>HibernateTransactionManager</td></tr><tr><td>JDO</td><td>JdoTransactionManager</td></tr></tbody></table><a id="more"></a><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>Spring支持声明式事务，即使用注解来选择需要使用事务的方法，他使用@Transactional注解在方法上表明该方法需要事务支持。备注解的方法在被调用时，Spring开启一个新的事务，当方法无异常运行结束后，Spring会提交这个事务。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveStudent</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，@Transactional注解来自于org.springframework.transcation.annotation包，而不是javax.transaction。</p></blockquote><h2 id="注解事务行为"><a href="#注解事务行为" class="headerlink" title="注解事务行为"></a>注解事务行为</h2><p>@Transactional有如下表所示的属性来定制事务行为</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>Propagation</td><td>事务传播行为</td></tr><tr><td>isolation</td><td>事务隔离级别</td></tr><tr><td>readOnly</td><td>事务的读写性，boolean型</td></tr><tr><td>timeout</td><td>超时时间，int型，以秒为单位。</td></tr><tr><td>rollbackFor</td><td>一组异常类，遇到时回滚。（rollbackFor={SQLException.class}）</td></tr><tr><td>rollbackForClassName</td><td>一组异常类名，遇到回滚，类型为 string[]</td></tr><tr><td>noRollbackFor</td><td>一组异常类，遇到不回滚</td></tr><tr><td>norollbackForClassName</td><td>一组异常类名，遇到时不回滚。</td></tr></tbody></table><h2 id="类级别使用-Transactional"><a href="#类级别使用-Transactional" class="headerlink" title="类级别使用@Transactional"></a>类级别使用@Transactional</h2><p>@Transactional不仅可以注解在方法上，还可以注解在类上。注解在类上意味着此类的所有public方法都开启了事务。如果类级别和方法级别同时使用了@Transactional注解，则使用在类级别的注解会重载方法级别的注解（也就是已类级别的注解最终生效）。</p><h1 id="Spring-Boot的事务支持"><a href="#Spring-Boot的事务支持" class="headerlink" title="Spring Boot的事务支持"></a>Spring Boot的事务支持</h1><ul><li>自动配置的事务管理器，在使用JDBC作为数据库访问技术时（现在一般很少），配置如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(DataSource.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(<span class="keyword">this</span>.dataSource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用JAP作为数据持久化技术时，配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(PlatformTransactionManager.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Bean注解可以参考Springboot注解详解，大意是Springboot启动后扫描的一系列组件的标识</p></blockquote><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>演示如何使用@Transactional使用异常数据回滚与使用异常导致数据不回滚</p><ul><li>实体类（Entity）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据持久化层（Dao层）<br>这里使用的是JPA</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Service层</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">saveStudentWithRollBack</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Service实现层（Impl）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">// 直接注入 StudentRepository 的 bean</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Transactional 注解的 rollbackFor 属性，指定特定异常时，触发回滚</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithRollBack</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        Student s = studentRepository.save(student);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"高斯林"</span>.equals(s.getName()))&#123;</span><br><span class="line">            <span class="comment">//硬编码，手动触发异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"高斯林已存在，数据将回滚"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Transactional 注解的 noRollbackFor 属性，指定特定异常时，不触发回滚</span></span><br><span class="line">    <span class="meta">@Transactional</span>(noRollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        Student s = studentRepository.save(student);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"高斯林"</span>.equals(s.getName()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"高斯林已存在，数据将不会回滚"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller层（接口调用层）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入 studentservice 的 bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试回滚情况</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/withRollBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithRollBack</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.saveStudentWithRollBack(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试不回滚情况</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/withOutRollBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.saveStudentWithoutRollBack(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试结果：有异常回滚成功后，数据并没有写入数据库；不回滚，有异常数据也会插入数据库</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring的事务机制&quot;&gt;&lt;a href=&quot;#Spring的事务机制&quot; class=&quot;headerlink&quot; title=&quot;Spring的事务机制&quot;&gt;&lt;/a&gt;Spring的事务机制&lt;/h1&gt;&lt;p&gt;所有的数据库访问技术都有事务处理机制，这些技术提供了API用于开启事务，提交事务完成数据操作，或者在发生错误的时候回滚数据。Spring的事务机制是用统一的机制来处理不同数据访问技术的事务处理，Spirng的事务机制提供了一个PlatformTransactionManager接口，不同的数据访问技术的事务使用不同的接口实现，如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据访问技术&lt;/th&gt;
&lt;th&gt;实现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JDBC&lt;/td&gt;
&lt;td&gt;DataSourceTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JPA&lt;/td&gt;
&lt;td&gt;JPATransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hibernate&lt;/td&gt;
&lt;td&gt;HibernateTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDO&lt;/td&gt;
&lt;td&gt;JdoTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring boot" scheme="http://yoursite.com/tags/Spring-boot/"/>
    
      <category term="后台" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot之事务传播</title>
    <link href="http://yoursite.com/2020/02/25/Spring%20boot%E4%B9%8B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2020/02/25/Spring boot之事务传播/</id>
    <published>2020-02-25T11:43:00.000Z</published>
    <updated>2020-03-06T05:56:54.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为，这是Spring为我们提供的强大工具箱。使用事务传播可以为我们开发提供许多便利。但是人们对他的误解也很多，你一定听过“service方法事务最好不要嵌套”的传言。要想正确使用工具首先需要了解工具。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="什么是事务传播行为"><a href="#什么是事务传播行为" class="headerlink" title="什么是事务传播行为"></a>什么是事务传播行为</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另外一个方法时事务如何传播。<br>伪代码说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span>(Propagation == XX)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中methodA()方法嵌套调用了methodB()方法，methodB()的事务传播行为由@Transaction（）设置来决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring boot" scheme="http://yoursite.com/tags/Spring-boot/"/>
    
      <category term="后台" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot之JPA</title>
    <link href="http://yoursite.com/2020/01/21/Spring%20boot%E4%B9%8BJPA/"/>
    <id>http://yoursite.com/2020/01/21/Spring boot之JPA/</id>
    <published>2020-01-21T05:54:53.729Z</published>
    <updated>2020-01-21T09:21:05.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-boot连接数据库背景知识"><a href="#Spring-boot连接数据库背景知识" class="headerlink" title="Spring boot连接数据库背景知识"></a>Spring boot连接数据库背景知识</h2><ul><li><strong>JDBC</strong><br>Java DataBase Connectivity是Java连接数据操作的原生接口。JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为各个数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准的方法。<blockquote><p>一句话概括：JDBC是所有框架操作数据库必须要用的，有数据库厂商提供，但是为了方便JAVA程序员调用各个数据库，各个数据库厂商都要实现JDBC接口（提供统一的标准）</p></blockquote></li><li><strong>JPA</strong><br>JAVA Persistence API是JAVA持久化规范，<strong>是ORM框架的标准</strong>（注意，它是一种标准），主流ORM框架都实现了这个标准。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有的JAVA EE和JAVA SE应用开发工作；第二，Sun希望整合ORM技术，实现统一化操作。ORM是一种思想，是插入在应用程序与JDBC API之间的一个中间层，JDBC并不能很好地支持面向对象的程序设计，ORM解决了这个问题，通过JDBC将字段高效地与对象进行映射，具体实现（ORM框架）有：hibernate，toppling，spring data jpa，open jpa等。spring data jpa是对JPA规范的再次抽象，底层还是用的实现JPA的hibernate技术。本文讲的JPA就是其具体实现：Spring data jpa。</li><li>hibernate<br>一个标准的ORM框架，实现了JPA接口</li><li>mybatis<br>一个持久化框架，但是不完全是一个ORM框架，不是依照JPA规范。</li></ul><a id="more"></a><h2 id="Spring-Boot-JPA"><a href="#Spring-Boot-JPA" class="headerlink" title="Spring Boot JPA"></a>Spring Boot JPA</h2><p>Spring Boot Jpa是Spring基于ORM框架，JPA规范的基础上封装的一套JAP应用框架，可以使开发者使用极简的代码即可以实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。Spring Boot JPA让我们摆脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>基本查询也分为两种，一种是默认实现，一种是根据查询的方法来自动解析成SQL。很好很强大。</p><h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>Spring Boot Jpa默认预先生成来一些基本的CURD的方法，例如：增、删、查<br>首先，继承JpaRepository，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就只是实现一个接口，PersonRepository便拥有了很多能力。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       personRepository.save(person);</span><br><span class="line">       personRepository.count();</span><br><span class="line">       personRepository.delete(person);</span><br><span class="line">       personRepository.deleteAll();</span><br><span class="line">       personRepository.findAll();</span><br><span class="line">       <span class="comment">//等等，上面这些都是默认提供的。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>是不是很爽，啥都不用写，就给你赋予了这么多操作数据库的能力。</p><h3 id="自定义简单查询"><a href="#自定义简单查询" class="headerlink" title="自定义简单查询"></a>自定义简单查询</h3><p>自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是：findXXBy，readXXBy，queryXXBy，countXXBy，getXXBy后面跟属性名称，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByAddress</span><span class="params">(String address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByNameAndAddress</span><span class="params">(String name,String address)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过方法名就知道什么意思，能实现什么操作了</span></span><br></pre></td></tr></table></figure><p>基本上SQL体系中的关键词都可以使用，如Like，IgnoreCase，OrderBy等。具体的关键字，使用方法和产生SQL如下表所示：</p><table><thead><tr><th>KeyWord</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>Where x.lastname =?1 and x.firstname =?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>where x.lastname= =?1 and x.firstname =?2</td></tr><tr><td>Is,Equals</td><td>findByFirstnameIs,findByFirstnameEquals</td><td>where x.firstname = ?1</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>where x.startDate between ?1 and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>where x.age &lt; ?1</td></tr><tr><td>GreaterThanEqual</td><td>findByAgeGreaterThanEqual</td><td>where x.age &gt;= ?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>where x.startDate &gt; ?1</td></tr><tr><td>IsNull</td><td>findByAgeIsNull</td><td>where x.age is null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>where x.firstname like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>where x.firstname like ?1 (parameter bound with appended %)</td></tr></tbody></table><p>具体更多参考官网</p><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><p>在实际开发中我们需要用到分页，删除，连表等查询的时候就需要特殊的方法或者自定义SQL</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页查询在实际使用中非常普遍了，Spring Boot Jpa已经帮我吗实现了分页的功能，在查询方法中，需要传入一个参数 <strong>Pageable</strong>，当查询中有多个参数的时候Pageable建议作为最后一个参数传入。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findALL</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByUserName</span><span class="params">(String userName,Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>Pageable是Spring封装的分页实现类，使用的时候初始化参数为：页数，每页条数，排序规则，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonByPage</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"id"</span>);</span><br><span class="line">    Pageable pageable =  PageRequest.of(page,size,sort);<span class="comment">//new PageRequest(page,size,sort);</span></span><br><span class="line">    Page&lt;Person&gt; personPage = personRepository.findAll(pageable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> personPage.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制查询"><a href="#限制查询" class="headerlink" title="限制查询"></a>限制查询</h3><p>有时候我们只需要查询前N个元素，或者取前一个实体，这时候可以这样操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>这种操作也很常见，这样就很方便了。</p></blockquote><h3 id="自定义SQL查询"><a href="#自定义SQL查询" class="headerlink" title="自定义SQL查询"></a>自定义SQL查询</h3><p>其实Spring data绝大部份的SQL都可以根据方法名定义的方式来实现，但是总有情况我不想用自带的，就是要手写SQL，它也是支持的，使用@Query注解就可以做到，若果涉及到删除或者修改再需要加上@Modifying注解，也可以根据需要添加@Transactional对事物的支持，查询超时设置等。看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update User u set u.userName = ?1 where u.id = ?2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modifyByIdAndUserId</span><span class="params">(String  userName, Long id)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"delete from User where id = ?1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteByUserId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Transactional</span>(timeout = <span class="number">10</span>)</span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u where u.emailAddress = ?1"</span>)</span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select p from Person p where p.name=:name and p.address=:address"</span>)</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">withNameAndAddressQuery</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String Name, @<span class="title">Param</span><span class="params">(<span class="string">"address"</span>)</span>String address)</span>;</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。</p><p>首先需要定义一个结果集的接口类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HotelSummary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">City <span class="title">getCity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Double <span class="title">getAverageRating</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Integer <span class="title">getAverageRatingRounded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAverageRating() == <span class="keyword">null</span> ? <span class="keyword">null</span> : (<span class="keyword">int</span>) Math.round(getAverageRating());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的方法返回类型设置为新创建的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select h.city as city, h.name as name, avg(r.rating) as averageRating "</span></span><br><span class="line">        - <span class="string">"from Hotel h left outer join h.reviews r where h.city = ?1 group by h"</span>)</span><br><span class="line"><span class="function">Page&lt;HotelSummary&gt; <span class="title">findByCity</span><span class="params">(City city, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select h.name as name, avg(r.rating) as averageRating "</span></span><br><span class="line">        - <span class="string">"from Hotel h left outer join h.reviews r  group by h"</span>)</span><br><span class="line"><span class="function">Page&lt;HotelSummary&gt; <span class="title">findByCity</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;HotelSummary&gt; hotels = <span class="keyword">this</span>.hotelRepository.findByCity(<span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">10</span>, Direction.ASC, <span class="string">"name"</span>));</span><br><span class="line"><span class="keyword">for</span>(HotelSummary summay:hotels)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Name"</span> +summay.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在运行中 Spring 会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用 getXX的形式来获取</p></blockquote><h2 id="多数据源的支持"><a href="#多数据源的支持" class="headerlink" title="多数据源的支持"></a>多数据源的支持</h2><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-boot连接数据库背景知识&quot;&gt;&lt;a href=&quot;#Spring-boot连接数据库背景知识&quot; class=&quot;headerlink&quot; title=&quot;Spring boot连接数据库背景知识&quot;&gt;&lt;/a&gt;Spring boot连接数据库背景知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JDBC&lt;/strong&gt;&lt;br&gt;Java DataBase Connectivity是Java连接数据操作的原生接口。JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为各个数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准的方法。&lt;blockquote&gt;
&lt;p&gt;一句话概括：JDBC是所有框架操作数据库必须要用的，有数据库厂商提供，但是为了方便JAVA程序员调用各个数据库，各个数据库厂商都要实现JDBC接口（提供统一的标准）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JPA&lt;/strong&gt;&lt;br&gt;JAVA Persistence API是JAVA持久化规范，&lt;strong&gt;是ORM框架的标准&lt;/strong&gt;（注意，它是一种标准），主流ORM框架都实现了这个标准。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有的JAVA EE和JAVA SE应用开发工作；第二，Sun希望整合ORM技术，实现统一化操作。ORM是一种思想，是插入在应用程序与JDBC API之间的一个中间层，JDBC并不能很好地支持面向对象的程序设计，ORM解决了这个问题，通过JDBC将字段高效地与对象进行映射，具体实现（ORM框架）有：hibernate，toppling，spring data jpa，open jpa等。spring data jpa是对JPA规范的再次抽象，底层还是用的实现JPA的hibernate技术。本文讲的JPA就是其具体实现：Spring data jpa。&lt;/li&gt;
&lt;li&gt;hibernate&lt;br&gt;一个标准的ORM框架，实现了JPA接口&lt;/li&gt;
&lt;li&gt;mybatis&lt;br&gt;一个持久化框架，但是不完全是一个ORM框架，不是依照JPA规范。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring boot" scheme="http://yoursite.com/tags/Spring-boot/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局之Position（定位）</title>
    <link href="http://yoursite.com/2020/01/15/CSS%E5%B8%83%E5%B1%80%E4%B9%8BPosition%EF%BC%88%E5%AE%9A%E4%BD%8D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/01/15/CSS布局之Position（定位）/</id>
    <published>2020-01-15T10:03:07.892Z</published>
    <updated>2020-01-17T06:07:58.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS重点属性之Position"><a href="#CSS重点属性之Position" class="headerlink" title="CSS重点属性之Position"></a>CSS重点属性之Position</h1><p>position属性指定了元素的定位类型，它有5个值</p><ul><li>static（默认）</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><p>元素可以使用的top / bottom / left / right的属性进行定位。然而，这些属性无法正常工作，除非先设定position属性。他们也有不同的工作方式，这取决于定位方法。</p><a id="more"></a><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>HTML元素的默认值，没有定位，遵循正常的文档流对象。静态定位的元素不会收到top，bottom，left，right影响。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.static</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: static;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#73AD21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/try.php?filename=trycss_position_static" target="_blank" rel="noopener">运行效果</a></p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动，这个类似于Android里面某个某个悬浮控件，屏幕滑动时该控件的位置也不变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.pos_fixed</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/try.php?filename=trycss_position_fixed" target="_blank" rel="noopener">运行效果</a><br>可以滑动浏览器看看效果。</p><blockquote><p>Fixed定位使元素的位置与文档流无关，因此不占据空间，Fixed定位的元素会与其它元素重叠。</p></blockquote><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>相对其正常位置的定位（正常文档流是从上到下从左到右）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_left</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_right</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/try.php?filename=trycss_position_relative" target="_blank" rel="noopener">运行效果</a></p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><p><strong>绝对定位的元素位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html></html></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/try.php?filename=trycss_position_absolute" target="_blank" rel="noopener">运行效果</a></p><blockquote><p>同fixed定位一样，absolute定位使元素的位置与文档流无关，因此不占据空间，和其它元素会有重叠。</p></blockquote><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>基于用户的滚动位置来定位，粘性定位的元素是依赖于用户的滚动，在position：relative与position：fixed定位之间切换。它的行为就像position：relative；而当页面滚动超出目标区域时，它的表现就像position：fixed；它会固定在目标位置。固定的位置指的是top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sticky</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: -webkit-sticky; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#4CAF50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/try.php?filename=trycss_position_sticky" target="_blank" rel="noopener">运行效果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS重点属性之Position&quot;&gt;&lt;a href=&quot;#CSS重点属性之Position&quot; class=&quot;headerlink&quot; title=&quot;CSS重点属性之Position&quot;&gt;&lt;/a&gt;CSS重点属性之Position&lt;/h1&gt;&lt;p&gt;position属性指定了元素的定位类型，它有5个值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static（默认）&lt;/li&gt;
&lt;li&gt;relative&lt;/li&gt;
&lt;li&gt;fixed&lt;/li&gt;
&lt;li&gt;absolute&lt;/li&gt;
&lt;li&gt;sticky&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元素可以使用的top / bottom / left / right的属性进行定位。然而，这些属性无法正常工作，除非先设定position属性。他们也有不同的工作方式，这取决于定位方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局之Flex布局</title>
    <link href="http://yoursite.com/2020/01/08/CSS%E5%B8%83%E5%B1%80%E4%B9%8BFlex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/01/08/CSS布局之Flex布局/</id>
    <published>2020-01-08T03:17:38.077Z</published>
    <updated>2020-01-15T06:01:48.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">文章来源</a></p><p>前面讲过CSS基本的布局方法，默认排列位inline（行内元素）和block（块状元素），传统的布局解决方案，基于盒装模型，依赖display属性+position属性+float属性。它对于那些特殊布局非常不方便，09年，W3C提出了一种新的方案–Flex布局，可以简便完整响应式实现各种页面布局。目前已经得到了所有浏览器的支持，小程序也是支持Flex的。</p><a id="more"></a><h2 id="flex布局是什么"><a href="#flex布局是什么" class="headerlink" title="flex布局是什么"></a>flex布局是什么</h2><p>Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    //行内元素也可以使用Flex布局</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-flex</span>;</span><br><span class="line">    //webkit内核的浏览器，必须加上-webkit前缀</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-flex</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，设为Flex布局布局以后，子元素的float , clear和vertical-align属性将失效。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用Flex布局的元素，成为Flex容器（Flex container），简称“容器”。它所有子元素自动成为容器成员。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gap0ktn5isj30fn099q2x.jpg" alt></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置叫做main start，结束位置叫做main end;交叉轴（垂直于水平主轴）,交叉轴开始位置叫cross start，结束位置叫cross end。<br>项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。下图是Flex布局属性脑图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gax7jkndnvj30u0188dhn.jpg" alt></p><h2 id="Flex容器布局属性"><a href="#Flex容器布局属性" class="headerlink" title="Flex容器布局属性"></a>Flex容器布局属性</h2><p>以下六个属性设置在容器上</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-item</li><li>align-content</li></ul><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt></p><p>它有四个值</p><ul><li>row(默认值)：主轴为水平方向，起点在左端</li><li>row-reverse：主轴为水平方向，起点在由端</li><li>column：主轴为垂直方向，起点在上沿</li><li>column-reverse：主轴为垂直方向，起点在下沿</li></ul><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线上（又称“轴线”）上，flex-wrap属性定义，如果一条轴线排不下去，会自动换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有三个值</p><ul><li>nowrap: 不换行</li><li>wrap：换行，第一行在上面，从上到下换行</li><li>wrap-reverse：换行，第一行在下方，从下到上换行</li></ul><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row || wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p>justify-content属性定义了项目在主轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt><br>它有五个值</p><ul><li>flex-start: 默认值，左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两段对齐，项目之间的间隔都相等</li><li>space-around：每个项目两侧的间隔都相等。所以上图里面元素之间的间隔比元素与边框之间的间隔大一倍。</li></ul><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p>align-items是针对纵轴元素的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt></p><p>它有五个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下</p><ul><li>flex-start: 交叉轴的起点对齐</li><li>flex-start: 交叉轴的重点对齐</li><li>center: 交叉轴的重点对齐</li><li>baseline: 项目的第一行文字的基线对齐</li><li>stretch: 默认值，如果项目未设置高度或者设为auto，将占满整个容器的高度。</li></ul><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p>align-content属性定于你了多根轴线的对齐方式，<strong>如果项目只有一根轴线，该属性不起作用</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt><br>它有六个值</p><ul><li>flex-start: 与交叉轴的起点对齐</li><li>flex-end: 与交叉轴的终点对齐</li><li>center: 与交叉轴的中点对齐</li><li>space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布</li><li>space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li>stretch: 默认值，轴线占满整个交叉轴</li></ul><h2 id="Flex元素（项目）的属性"><a href="#Flex元素（项目）的属性" class="headerlink" title="Flex元素（项目）的属性"></a>Flex元素（项目）的属性</h2><p>以下6个属性设置在项目（元素）上</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)</span><br><span class="line"></span><br><span class="line">### <span class="selector-tag">flex-grow</span>属性</span><br><span class="line"><span class="selector-tag">flex-grow</span>属性定义项目的放大比例，默认为0，如果存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt></p><h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，如果空间不足，该元素将缩小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span> (default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其它项目为1，则空间不足时，前者不会缩小。负值对该属性无效。</p><h3 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余的空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">300px</span> | auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设置为跟width或height属性一样的值（比如350px），则项目（元素）将占据固定空间。</p><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性时flex-grow，flex-shrink和flex-basis的简写，<em>默认值0 1 auto</em>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto(1 1 auto)和none（0 0 auto）</p><blockquote><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></blockquote><h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p>align-self属性允许单个项目有与其它项目不一样的对齐方式，<em>可覆盖align-items属性。默认值为auto,表示继承父元素的align-item属性，如果没有父元素，则等同于streth。</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt></p><p>该属性可取6个值，除了auto，其它和align-item一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flex布局&quot;&gt;&lt;a href=&quot;#Flex布局&quot; class=&quot;headerlink&quot; title=&quot;Flex布局&quot;&gt;&lt;/a&gt;Flex布局&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面讲过CSS基本的布局方法，默认排列位inline（行内元素）和block（块状元素），传统的布局解决方案，基于盒装模型，依赖display属性+position属性+float属性。它对于那些特殊布局非常不方便，09年，W3C提出了一种新的方案–Flex布局，可以简便完整响应式实现各种页面布局。目前已经得到了所有浏览器的支持，小程序也是支持Flex的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot初解</title>
    <link href="http://yoursite.com/2019/12/25/Spring%20Boot%E5%88%9D%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/25/Spring Boot初解/</id>
    <published>2019-12-25T11:43:00.000Z</published>
    <updated>2019-12-27T08:42:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot是什么"><a href="#SpringBoot是什么" class="headerlink" title="SpringBoot是什么"></a>SpringBoot是什么</h1><p>从本质上来说，Springboot是一个专注于框架的框架。Spring Boot就是对各种框架的整合，让他们集成在一起更加简单。目前ssm框架还是比较常用的，其中ss指的无非就是Spring和SpringMVC，我们可以简单的认为“Spring Boot &gt;= Spring + SpringMVC”。Spring Boot的配置极其简单，可以让你不用或者只需要很少的配置就可以快速运行项目。</p><a id="more"></a><h1 id="Spirng-Boot的优缺点"><a href="#Spirng-Boot的优缺点" class="headerlink" title="Spirng Boot的优缺点"></a>Spirng Boot的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>快速构建项目</li><li><p>对主流开发框架的无配置集成</p><blockquote><p>spring-boot-starter-web启动器自动依赖其它组件，减少了maven配置</p></blockquote></li><li><p>项目可以独立运行，无需外部依赖Servlet容器（自带一个Tomcat）</p><blockquote><p>内嵌离各种servlet容器，Tomcat，Jetty等，现在不用打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行了（java -jar <strong>.jar）,所有的依赖都在一个jar包内。可以以下命令修改tomcat的端口号：（java -jar </strong>.jar –server.port=9090）</p></blockquote></li><li>提供运行时的应用监控</li><li>极大提高开发部署效率（还是因为配置简单）</li><li>与云计算天然集成</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>Spring Boot作为一个微框架，离微服务的实现还是有距离的。没有提供相应的服务发现和注册的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际URI的规范化工作。</li></ol><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>上面提到使用Spring boot可以让你不用或者只需要很少的配置就可以让项目快速运行，说的就是使用代码注解来取代xml配置。其实从Spring3开始就已经提供java配置方式，使用java配置方式可以更好的理解你配置的Bean，如今Spring4更是推荐使用java配置方式，java配置方式可以完全替代xml配置，下面看两个最基本的注解</p><ul><li>@Configuration 和 @Bean<br>Spring的Java配置方式时通过@Configuration和@Bean来实现的<ul><li>@configuration作用与类上，相当于一个xml配置文件</li><li>@Bean作用与方法上，相当于xml中的<bean></bean></li></ul></li><li>例子<ul><li>这是一个简单模拟从数据库取User数据的Dao类（注意代码，它没有使用过任何注解，也就是说UserDao目前没有交给Spring容器管理）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">"User "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个常见的service，通过注入UserDao，使用UserDao的方法获取用户数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = userDao.queryUserList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就开始和Spring不一样了，这个类使用了两个新的注解，其中@Configuration表明该类相当于Spring的一个xml配置文件，@Bean将一开始的UserDao配置给Spring管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">// 通过注解来表明该类是一个Spring的配置，相当于一个xml文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">// 这里要注意,方法名"getUserDao"将作为UserDao在容器中的id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就时获取Spring容器，从容器中拿到UserService，并调用其获取用户数据的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext acac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        UserService userService = (UserService) acac.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.getUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-boot注解"><a href="#Spring-boot注解" class="headerlink" title="Spring boot注解"></a>Spring boot注解</h1><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h2><p>是Spring boot项目的核心注解，主要目的是开启自动配置。后续详解原理。</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>该注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都是以json格式输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot是什么&quot;&gt;&lt;a href=&quot;#SpringBoot是什么&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot是什么&quot;&gt;&lt;/a&gt;SpringBoot是什么&lt;/h1&gt;&lt;p&gt;从本质上来说，Springboot是一个专注于框架的框架。Spring Boot就是对各种框架的整合，让他们集成在一起更加简单。目前ssm框架还是比较常用的，其中ss指的无非就是Spring和SpringMVC，我们可以简单的认为“Spring Boot &amp;gt;= Spring + SpringMVC”。Spring Boot的配置极其简单，可以让你不用或者只需要很少的配置就可以快速运行项目。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring boot" scheme="http://yoursite.com/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>JS事件循环</title>
    <link href="http://yoursite.com/2019/12/16/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2019/12/16/JS事件循环/</id>
    <published>2019-12-16T01:15:58.130Z</published>
    <updated>2019-12-16T09:29:22.078Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？</p><a id="more"></a><p>关于执行中的线程：</p><ul><li>主线程：也就是js引擎执行的线程，这个线程只有一个，页面渲染，函数处理都在这个主线程上执行。</li><li>工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取，网络请求灯异步事件。</li></ul><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yd9c7ijxj30u00vhgmp.jpg" alt></p><p>从上图我们可以看出，<strong>js主线程</strong>它是有一个执行栈的，所有的js代码都会在执行栈里运行，在执行代码过程中，如果遇到一些异步代码（比如setTimeout，ajax，promise.then以及用户点击等操作），那么浏览器就会将这些代码放到另一个线程（工作线程）中执行，在前端由浏览器底层执行，在node端由libuv执行，这个线程的执行不阻塞主线程的执行，主线程执行栈中剩余的代码。</p><p>当工作线程里的代码执行完成后（比如setTimeout时间都了，ajax请求的到了响应），该线程就会将它的回调函数放在任务队列中（又称为事件队列，消息队列）中等待执行，而当主线程执行完栈中的所有代码后，它会检查任务队列是否有任务要执行，如果有任务要执行的话，那么久将该任务放到执行任务栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。跟大部分框架的消息队列其实本质原理都是一样的。下面我们来具体分析这套机制的运行过程。</p><h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>那么，问题来了。如果任务队列中，有很多个任务的话，那么要先执行哪个任务呢？js是有两个任务队列的，一个叫做Macrotask Queue（Task Queue）大任务，一个叫Microtask Queue小任务。</p><p>Macrotask常见的任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>用户交互操作，UI渲染</li></ul><p>Micraotask常见任务：</p><ul><li><strong>Promise</strong></li><li>process.nextTick(nodejs)</li><li>Object.observe（不推荐使用)</li></ul><p><strong>重点来了</strong><br>事件循环执行流程如下：<br>主线程在执行主流程</p><ol><li>检查Macrotask队列是否为空，若不为空，则进行下一步，若为空，则跳到第3步；</li><li>从Macrotask队列中取队首（在队列时间最长）的任务进去执行栈中执行，执行完后进入下一步；</li><li>检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到第一步（开始新的事件循环）；</li><li>从Microtask队列中取队首（在队列中时间最长）的任务进去事件队列执行，执行完后，跳到第3步中，<strong>在执行过程中新增的microtask任务会在当前事件循环周期内执行，而新增的macrotask任务只能等到下一个事件循环才能执行。</strong></li></ol><p>来看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//settimeout1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//setinterval1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//settimeout2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//promise1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">12</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">13</span>)</span><br><span class="line">    clearInterval(intervalId)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><blockquote><p>1,9,7,8,2,3,10,11,12,13</p></blockquote><p><strong>运行结果分析</strong></p><ul><li><p>第一次事件循环： </p><ol><li>console.log(1)被执行，输出1</li><li>settimeout1执行，加入macrotask队列</li><li>setinterval2执行，加入macrotask队列</li><li>settimeout2执行，加入macrotask队列</li><li>promise2执行，它的两个then函数加入microtask队列</li><li>console.log(9)执行，输出9</li><li>根据事件循环定义，接下来会执行新增的microtask任务，（上面标记的：在执行过程中新增的microtask任务会在当前事件循环周期内执行），按照进入队列的顺序，执行console.log(7)和console.log(8),输出7和8，microtask队列为空，回到第1步，进入下一个事件循环，此时macrotask队列为：settimeout1，setinterval1,settimeout2。</li></ol></li><li><p>第二次事件循环：<br>  从macrotask队列里面取出队首元素：settimeout1并执行，输出2，microtask队列为空，回到第1步，进行下一个事件循环，此时macrotask队列为：setinterval1，settimeout2。</p></li><li><p>第三次事件循环：<br>  从macrotask队列里取位于队首元素：setiverval1并执行，输出3，然后又将新生成的setinterval1（间隔生产）加入macrotask队列，mincrotask队列为空，回道第1步，进入下一个事件循环，此时macrotask队列为：settimeout2，setinterval1。</p></li><li><p>第四次事件循环<br>  从macrotask对列中取出队首元素：settimeout2并执行，输出10，并且执行new promise内的函数（new promise内的函数式同步操作，并不是异步操作），输出11，并且将它的两个then函数加入到microtask队列中，再从microtask队列中（当前事件循环周期内执行）取队首的任务执行，直到队列为空。因此，两个新增的microtask任务按照顺序执行，输出12和13，并且将setinterval1清空（不会再产生setiterval1的事件）。</p></li><li><p>结束<br>  此时，mac和mic队列都为空，浏览器会一直检查队列是否为空，等待新的任务加入队列。在第一次循环中，<strong>为什么不是macrotask先执行呢</strong>？因为按照流程的话，不是应该先检查macrotask队列是否为空，再检查microtask队列吗。<br>  原因：<strong>因为一开始js主线程中跑的任务就是macrotask任务</strong>，而根据事件循环流程，一次事件循环只会执行一个macrotask任务，因此，执行完主线程的代码后，它就去从microtask队列中取首任务来执行了。</p></li></ul><blockquote><p>注意：由于在执行microtask任务的时候，只有当microtask队列为空的时候，它才会进入下一个事件循环，因此，如果它源源不断地产生新的microtask任务，就会导致主线程一直在执行microtask任务，而没有办法执行macrotask任务，这样我们就无法进行UI渲染/IO操作/ajax请求了，因此，我们应该避免这种情况发生，在nodejs中process.necttick就可以设置最大的调用次数，以此来防止阻塞主线程。</p></blockquote><h1 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题"></a>定时器问题</h1><p>由上，我们来引入一个新的问题，定时器的问题。定时器是否真实可靠呢？比如我执行一个命令：settimeout（task,100）,他是否就能准确的在100ms后执行呢，如果知道上面运行机制就知道答案是否定的。</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Ran after "</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds() - s) + <span class="string">" seconds"</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds() - s &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Good, looped for 2 seconds"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主线程跑了2s后才结束while循环，这才去执行macrotask中的settimeout回调任务。其实，你执行setTimeout（task,100）后只是确保这个任务会在100ms进入macrotask队列，但并不意味着他能立刻运行，可能当前主线程正在进行一个耗时的操作，也可能目前microtask队列有很多个任务，所以用setTimeout作为倒计时其实不会保证准确。</p><h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><p>关于 js 阻塞还是非阻塞的问题，我觉得可以这么理解，不够在这之前，我们先理解下同步、异步、阻塞还是非阻塞的解释，在网上看到一段描述的非常好，引用下：</p><blockquote><p>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。<br>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。（轮询）<br>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗最蠢）<br>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</p></blockquote><p><a href="https://www.zcfy.cc/article/node-js-at-scale-understanding-the-node-js-event-loop-risingstack-1652.html" target="_blank" rel="noopener">理解 Node.js 事件循环</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。&lt;/p&gt;
&lt;h1 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h1&gt;&lt;p&gt;首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（三）</title>
    <link href="http://yoursite.com/2019/07/18/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/18/日本游记（三）/</id>
    <published>2019-07-17T23:14:30.856Z</published>
    <updated>2019-07-26T15:19:30.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行程（2019-06-03）"><a href="#行程（2019-06-03）" class="headerlink" title="行程（2019-06-03）"></a>行程（2019-06-03）</h1><h2 id="京都"><a href="#京都" class="headerlink" title="京都"></a>京都</h2><p>行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下：</p><p><img src="https://lh3.googleusercontent.com/BHMX3bN7AhJEWmFzL4FAxc1Y8L-oci5khvjwNN3TzPQI6gaGDcNvCo8bqhDRL4cXagfrSUtR55sgbu2gHQXqDBVOngGcBYBiuFaAKgW5IWM3vhrE3xVw3UUw4Fur66KFkcWH5F4zsVfOpmu6QbzFwb1rt9Srr2U8ssojJI6Hzu5M4oTHfqUskJmSMg-3EDFTxK_sUZHvaHn19Ot5mqNRddF1cs-R0YCcuXAzT_CPm4uKc8nJUWPwPqU0mJCexkWNZSdQXhvzuy2Bl1X2VSAsHniWJmaEdgjjqyEyBMr6yObu_hTm13uNVLLMWmnsbMnz56qR8L4ubykpZSKVmmEciM4JujPQB1LCI1dsSpaXrmqlU0JSyjQWQCg9QCVcTFsdx6SNVCI1tvn3gUGmThGTflFmEE9_mxAwfQ85o82QmaVIQlnz8aKAEApGsIKMEYO3y2Tn1OUn6YRKCq5cvG67Kq97W4JOLyTsDwWeJVojTHrMA0tw81DEqfyEl9yA2c7X2PWK8VqhEv9hnOLyKxrUJdZpge3GJ3--01TnqmYZqHjHTjS_9hkHfxVrrDWYzIWwEI610OxrABLj5PPsGgmS0k1w4zZ_VSC7TI1Cirwt-y82zkTLfNGlIzwBB2MQwx-WHxZpEJOdj7mOUyLKAYbjSLEQWhjDhR8T=w1082-h1442-no" alt></p><a id="more"></a><p>这里竖着的带有颜色的竖条代表了各种线路（普通/快速/特快），横着的表示这条线路会停靠的站名。<br>我们坐地铁从九盯木到淡路，然后坐阪急线到乌丸。这里还是要感叹一下，日本的地铁很准时，所以你要上对车，GoogleMap也是利器，标明了每一趟车的到站时间，分秒不差。经过大概1个多小时的车程终于到Kyoto了。</p><p><img src="https://lh3.googleusercontent.com/uytr9kgOuCkAQOG9jcZ7GdomW4q0uwX507T8XpW-4IH9D5NQKHPLgJ8aLOAWtt81BUlsq13uX9kRkU994D_Q1rd_q9wI_psimJP0vM4ko-29bXYzrZAKpMb_qxqfpGF6ulPPKGRl7b7PDLfMGzo6p3YfJ5JOTaXN1VF5P2HX-qU33ezLeWiOn32kwL_1L2sq_JPTTwzjkzqW8JYUQb3X78-4ERS2Fs29205VpzSxvy0_bCmMIrajiKCWXuA-lTC08VfFFsyiP37YonV6pYccyGF1mB6TgGB6GaT8AB8__W2cMroObJpzLXTDJyoAll5tPRLqqSB5n3cu4t3C76wnUXZwt86Jp2wLqYsYeJ9bvdVpQ8GgKN3Od73W6xocTmq_uyKUp8NLitEEUTFg_YB9HStDY0yD7OcxpkqetUsobv3DEW0NzTOTCr3Nrah9lFHmvd1AHG0_XZUIIFTJLQg5xp0K7M8J-GMcOcEZldG97T44Yars1E1f5DHWXfdKarcNOwXJjUSewUUJon8MnlrZtM6occfcjQCDXIy5fB4p_g9Kw3F7JRKavbMGvkJDYNtQ-DrRJ3m3R6AUpM_KmnqokPGbPtehAS8I20Dp8oZUoNhwBStkZ_SLbGkktoqy77pRwwQwfaVRtYgUSrpGzPJyBTVJS4vW6gLt=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/IhiCrbpCcGPHTScgpknrgUy6uaHhXssCvjtVIi0XTTRdH4vbL_BGQ_XeVJMSJhxxaDA5-IzyTEEQNumPU4jxlxBlQ1mu-5E7Glr_l2Lov0yF8kwfupAAu5LyBEjKMlXftV-PDcvKFc3KTNmMmtU9kD6z0vdaa2ZwaO_XjhaZ7nth1ei4OxxPr0c1pleT1nTTZeAc_gS9enywLkK3frI7G8DvoHRi5S6al3qHTCUVS6Cg3pduW65CuU1lPsolMepIsIQUz_wdara0rmm_6gMVSRNhj19hl_EoAOsVJhYYD-UfrBtgxGPrDUZ2naRQQur6lnPhkeS_U6jWmEixWfe-FQVlW2MluN_DtWDSeow0slf7BV3QovTZGJycAiCWbukD66keXuYo2nWlEUiazu1hclVQWGzNJxgPdmSHbbvAUB8DWJ-cUobtBHvkyckMK4Ipez-j9AyG77bgzC0xoQn7a5XmQUH5cD6fRvN8tFmtDhvKZmfyTufDmut8I3v72tm06aS2FlZrcn4fif_FOXWRJpLp2L-bB2AoNlg5uJfvDHcDxLJ5mQuizdf0BaoUNAwgp3MxZKuFT7cNDmyAD_VAbgAyUTn2L_QMIzEVYAKqvVZAZTMMO8_dohoB_Nbsqsd46J6xGQQqk1Cc30d1LUTZdPf0dIJ1O7DN=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/TJstyC14yu61H7q05mjbkIZjZBqqXbFRwUajeAFw6yu4QAsP5rU05896Yv9Wo0nxQWNvH-43PcK7jCpRw321Hp9RBX_xF2tONf81M1CsIONTeKlw3OWkcxjyFsLmi6R_VehKLNOmzTVmoqtoj2Rky1XU6AGko1_ETQ7OjOZD3kkmrYL3S3IW4X-Ou2hSYoyGvI8b4FI4amu4Ahbm4IizmOKx0inEtW_2oqyuFFmfrIlEDMv0FLyZB8kAX9RXdKtzM91IpWRGadTBqRw6Ohk2H0-XuCOWYlAOevzjx5k4UxeMT9EMwlMbEJdBcnj-jbYIBYBkmiPdEyRDvrVq1slwM_m-VpcqhY4s3722uRWudjWystATWBjifbAoW9yvvxiRQyH-E_DFWWvevWubtX-XZKhQwx-EASMvTKhkurpxq-z3FJ7hpiBXnRlRnIYV9DeGFiMFcCnEmdkm5GafX91o0MeHjqDdGwnv6Jx1qdSnIR2MQHQ2KWGAJXkVZ4SykCKH4lIjqmZsWLE57x0OqWYyWNuxxbjk-sJWuVdHPiAT0r7aC7NzukQRXTiwG11o-uIy_JwvmVMJbxbksJ-4P0Puk8CSxFGEfj4kFS5I3sounTC_N5bsOuQuUqwCusI5o3uvSm6goyxxIz--HZtN8hwzzKedMUoaBygi=w1082-h1442-no" alt></p><p>京都给人的感觉更像是大城市，大阪是一种生活的城市。</p><p><img src="https://lh3.googleusercontent.com/9DWtI7aj0sOY1mqh53MqGKnXboTjLT_qc_YmnLvawRN9bkfpxvXv1XwFuFlqFQyW_Igthki1uqvBsum3TFqnKc3eLXHAzvY2exZ0bGIil6vAd3xlsnsO4i_rJoRDTli2vG2wY4iotdlzqYNpkPFAt6-8lFZ6rVHCNGV8qGFqXhmXk2isI-bkXHv5cSPCtqbObvPFJHJ3nqks5MJRs50aP09YB9AqYZ_zYojmEvp05Jt5bL5v0VzlIqBNccOd9ax4oDdn_C4nsysooAxdax0tj4dwe743RjR7bO6BIuzWln1u6Zt0J62CvgnPdTVdXIlCmtPcETelv5Js2O56grIxwKdOKZrLenfYoTCw4cbjbNSYv33ZeovWMvv9-SLeoDvj-CwHeXToaChYKKVh4ETs1bZT0So6kEwuRihDjczRo0Pv6IJtfYJSdw4mGvUt2JqFKCWwQE7uUOPvq4MeGzvk7Jl3FxP2fouzgsC5ZUfIhJfoWdPW81QdP_1W1STEXrIb8t5ppc_PiutfkXnQ4tju_U3NiGFotoCPd8yfO9yH2iOw8QYWKW7DzmoG6ZPLcblj1hacbH2AglgrzWUu2IlNC4bDd8e_eBiW2rnBzXESaGLrB-qRorufqaYPgB9r6HFTAdaauXzcwCje75Rx8fDrlhjfD5OkcrKg=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/glJrNFabUM2i5CxkvJKECnF8YZGZKOE6MKuzpsZ1PlfYacPyU09mJrjuMwUHkz_9EsTljqEtdDXM2C-PB4FYkUWqc_LNkL2J4HHtHUESDvPUVPcksB-wbGVjdZt7-PtaIQ2FemG_18ZBuI5iFPpWLSkGMRHmCCw2cMqL884_T8tAVgjP5aQ7YORC2nALkqMlfvyly3tSgFyjMWMCrPfjvFIcUkx8IwW7ACjcKvJbTFMuLIcGxX9H1H_aNkujsaPdQH3Bq8D-wfHGqrK0aSStxu-GSqC2HhKPU6RElhnrpDBWumSCqnLCkJBwZAF92aihvzSDi67icPcI3Qd332kZHQ1zKxslH4LeP2JsZ9Sc7kW0OZ1HSrrJnM1tJJuPhD2f7ANxNNtPP_xC95IZWgdDTUNsApuPYwszPYtvGFkchDK3DD_GBpbjGsKjcY8ODif-a2zWJHIVbK63z7sMMcpIwOGc_M8V-tAyCYHUWtrU-Bs6ZE4rI-AYfoHLn3W_5oLlUIzFQwa5jVqCk9kWus6zpU_k96SwwB8eW0eZvwxOkFArU9gdAJwJQLAEfd1Mby50SjC4zb9OxvEfj2AncVJJRaaI96RXew4RstFrjZ4KJvAiyv64P5O4YH161lQf3ByZeTFR-L3nRvUYttfia_V3QtDvlXDErpSb=w1924-h1442-no" alt></p><h2 id="清水寺"><a href="#清水寺" class="headerlink" title="清水寺"></a>清水寺</h2><p>来了京都，checkin酒店后，就抓紧时间去附近景点了，防止后面没有时间，选定了不远的清水寺，出发！日本的公交车很贴心（对残障人士），靠站后，整个上车一侧的车身会倾斜下来靠近地面，大家跟容易上车（老年人），而且日本的公交车是前门下车，后门上车的（我觉得很合理）。</p><p><img src="https://lh3.googleusercontent.com/G4MlLHBGbe26ye2Loq_b5S715b3BZchkS4SCuua-WZaPBTlMqUGvVZjeTeH4eEJ7P5NaUN34QXy_z6Imx_BMtoXMIEYV1XlEmjyaJP4PKDduSA08isMQp02DiyXKQDNj6FCdoM_90ES1fjDYVAaXpX30diTj1WKVp0-Qz8RvNF7dgTn6LKo4pdUjWPw4Rl7F5Y1Dh3jdUXaLNgtXArohLDjCVChrqIMIL22cQnKp5JYoLu-P_1_lNVU62IRd3kuFiZ6Rze_8WKxC1HKW902R6JvF0Sk2e3zKi_lML9QExjBeDrcQO6mPvBFTeCRRB8eWjjkN1FKV79S2KJfoaaco-UMDEj3oyjPFQU6FG9BvNWiDmMnV5KnU0-ta8X3WYFSUHMw0CQswaQE6gGYtkg7aejot6UBDSPjhKJAZU3h0IehB74yLjGoWwq-wzzsqnvFaJkHduoor9fIw8p6_pcsyb_zfHlUw534UKHR7_BL1XtRMY7FwLJ7o5BLKJ4FU-Ku9lj83iW56yQHIrlAD9uKJi5xz3E67Ue3EIfxsmWSnF1nxKqyvDV8cfEjld4IpSdulQMN4fzBMAGk8XQwJHG6oCTRo_BAanJT37_5AnFTK-sdioM2VvXgNWk4qec11fCYLzSC3oS3syt7KWnWhz9iqOfnsROFM7Yb4=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/yziGHtcpKxSYgiFtlOXiQwYtHpXQgu39iAQ7i6n4EzvHNn_x_ddV832WlH6XGvv7AzlPiYuM-M4R6C_jaRazDT_hRZ4ve_GRcjiVzjuGMILhPPGvZq7j_F6px-sFDkNRvXc9nRvk0YiPoKGpy_yRFfifXEbIKxLe_8aoRSGmwVq9ZRDDfvxTkiup6TTeK-4GNNVmyUCk1zgEax9tr4hExGjVOsoWBoYbKOFEwrCPq6aeAQyp6N8610NrC8Ycl44zucLjSMYNCxLfr0cTEdMfUYThhOrdErKgZHgttsAWmOFe8EBfgwKlVECO2WfmRswiL9GYYgh8-5Y2mKi7rnuxcgESrPNK5aypbTgjlFo4N9IerRVWeyytTOdqf6419EqxAOquJ4jUuOVrqmQvWhL9zG6bMZaFc7PDgEpnEy0plDRmMNyGWS7DoBEJjD_hCv-pTiFQGoI5ZVy05F5a5GWn-bJKhcW_RWSn88jXMXCG-LlhtflkKugDkBeExmj5IPhdpkelAAfAN6wrV6DetzkAe9sm4g-OyRvTPwuv2Zm6qf-fLJeftqaKAf4ucIvL3iL6r7yAqnMLStOGYrk_YLZattyo56tD51t2Esm9nWlJ65QLkC7t7SuIXHKLPHr0AZGbKMvyAWxt_vy92oBBrYWjAKGA70rk13CD=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/NZ3mByMUZR0dlar2XUgrBSJ_OtPR-3yBJVKJJSix888bf2pKAJ9C9wadQFeAjvfqw-LN0vQ7npUfPOU8D_7qar4p55xhBY9AWT3zX3NVhXb5bdzrTVVATcIRJL1ykrW6bd0nEXmiAtWGGtZaeVlXMlvc7r7kxp27WEKxETPy0nN7R-6qpQghhrT2Jnf1tZoTPAUPe6jBT83Il4nqR1jFQaltQqOdRAQklw50ETse0unlFeZkJ4020i8x3qWDy5R858Pgvop3yXjZMX3PThhZv1UMndHQfJ4yI-7Hq9aVnuc6FD2imou1G5FGwp4ysvH-wSEiQ1JiYhNAf0iR15zUvrLrxnBviDwrf9-Ltx2RBARXrpVxvJsnvvUTNZL2hAyM1U2BVo4nhAwLzrH4u9vS4H3hYAWvi6r-llphqj-4PDTC-NRytSuWRGe0s_yHUmflr10DbqXqTNXswH8pj_f7HMucMJma-_XWTY0EZQ18v4syJHGoQg5mmb-q0dcVo9gP8axdhdrNaD09wDxL1qL7k9y1Hh99JpHHRWRh9p6G-ltPandfW6Mi2abtQMnLm-QguJLRI3dhvJs2kcGZYPFkHW0mY9eHg1HdKIuWWgU0Lw6SwPq6xLWS3wS06kzyHjWJG8bE3Xax4v-WIrh0OXmS4E5qjScpclLA=w1082-h1442-no" alt></p><p>游客众多，天气也比较热，但是新鲜感让一切都变得那么美好</p><p><img src="https://lh3.googleusercontent.com/CFIH1lM56hivagAjDvZdEFMBmrFDk-3BA9fNpmpmTcMMppo3AHI2_OLHGqwUWF8zZZ5A4GUBCLNLbTs4Lo-eU1cyVST507oMAboN8IuMmzM2HKI5PKuKG-oqhsS2vhGUQZ7HJTpbk10Z74MG_j3Dv267vfTaPtX0pT-FsRPEOCKXO73Iz6CR_aZpeQL8tUj4iuT3BOeaYw0HM_k2s0PPKulcx-sPgXSEIrvMazTHjAZEKX8C5KheRezCZNvF_VK5WCDyYK9TuO9OM2hhABtFDSPAyahbIkgj6eQ_vJiB7NnpE3pB2Fh5n_Nwta93bOwQVRFq0SLUldv6tNz27PEv4bzKNjxgpvEOCVznRKVnEh5ALWEVkhTYiXDDtOXE2OhfnEGn-KelgFn1gambw-QtUZ-wSvdf6bI0c_bjDt3tKUOu8Brzwr59CT9ID9eYokoSmXJ1-LmhwLHAsd8pztA6X-R3e-hlOI6qWSXx5meS4lAJXn3RqKPMtNZ89t_IMORMT-F1pR_LV4Cu3C2PuC7eVS635bzm2eVOILGVhsmYXOGh20BK82sePt13ntqxI7EzheXmhZ57ffMRoZniATIlgZXbVbihNfwRa9R3SXuc5TT0mxNYmpWJMgx4vW5B35vnmaWGnljYlo7MD-NKnAxaEXTUk3ibbMSU=w1924-h1442-no" alt></p><p>正门，其实日本的各种神社，就是类似中国的寺庙<br><img src="https://lh3.googleusercontent.com/PLf91ZQTz9pM0jTHm91bnHjArBjjuzDSHZ1LrMPeDwSc4GuHXNk6c9wrO1_GKWFR4km3Ky55LM2x2dFjTspbNmE22SFhqSmvND_Wa34Ouy3glLscPEt1OawwmgDPryJydqOsnIIHcN-yV46Pg3y6A76mI6C5K32iTlK0iidAOd4gi8vmyvZDsbG032HSO-ofLdkTpZcsv2I_xbXJ024ffcTTT0uVY7nP9X5Mubx1QcGdB-4JxU0vZ6tw6AyMDHcZ6s91hcFxW-KvrAn_HY20MVBkek07QmhtxPVggmGi1KRrwtiAzkWoOoLiQyMLJB86SBgUQIGsuoy0ObWcDe4r3DIffqKvt_L_SpvRp6igxYcr2P6RsxONCPyjZC6VgmmtnAkoWqjvLtnZ8jPUkHOjRRLoKNzGEVOkWY_c-rssJcCLtTv5G_vpOFN5HTp_hAzCbj7rkb95zu6R6qRjNT8nFLACZDwCY_ywW1iH9m_00DHZvYcK5ryKjpLDMSZ4j-1FfZ_ieC-cbUygolz3tsLFPbuvkAL9wTKPMj8LJhjx_NnjbpvZCLMNQ1N7lT185Onvh_pPLAVayNcpK8YeVatv0i6gPOhFBMVipZYCvr9KjbwfLRWoGWkv5vEo1WHYU9UiSrjIN4hVhmiPQQegARVQ5tgly1z42p0F=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/L5B8BSoPN6JrATEPuAQwKVj3rs4E9E8GINWKLgjwGhAPI1wUWGYU9lps1usNYK1B7CaNMBDWzwTavUd0ua7yJef2luZX7AagVpVRmSZra2EZihkK73unEesneTA8jAzKXOxFW9z_0t6Dl1P02kxfgOBqnDDrXnJMOBrt_2SPZEhZXA-rcpNWFGlUyUFWgwcYUeET62lQ0XfsowDVf7CV9uEShJDy6MoGtmQYqtsGHOF8J3PdxqTqxvpv496vCSejtzeXn22vq1fRObhkgi92hYZOcFjAFGhc68-VBn5E5_nrPeug0MOCJhD5n7qAQUU6gMFPcT_StTW0uq7CCPv_5kFsGzOxNg93AxdecERpktvTM4vfGAaIGQ99xp_b3U9jEbb94yaTAvNdbSgdorCdQgfqVAXEWhE9dGv-2qg56QxaSDxhAvuVt9bavYHdgs3ALpduK9ZDRAbOUv-UM3dlKkOngqEBjoTycgYYC6fe6kpzEj6ZrVZotQXZRprEu21-wuF0NbQiME8lf7XzPpX2y5MHnVmxPeCfT92mXXYpSl0nDZHDE989VqB9VLbSv4qvPa2SLvWPGdv_4k_KRUENGoqqBEJAxGd5mgDHWOCbNgvycnKpnJW7gPGnew3X-tiw_8Acppz8SmaK5RtBVYeNMapNyInSgvfi=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/BdH8k7fBHz5RrCMqZ985Ax66zxK00O0xd8a_BPk3yfVM1Cr-qExRZ_bnnIQszj2tinSixXbozd_bg9O_pWRaPSoplvHH3HOfdpT3O9-0xvxGnbP3_11yyiVHFWkHdcvXZ0pPoNSyfa0zxKZr3nFwFDcmMMbK7bcWpVDWBNScANhV-a9l8-Epbna7Bwp7WL4i970WMi5EJhtLu7kUcItHUqT7O9Ridl0AoH3Cm45_TzVeqSrpLdh7N-DfDdfVDAGe8E88nwAwtmGI_AhsY78LEFTnQwFV-4dNbCa4IWsl_z7rS2oXNmhknnBwo-FdMczcdGSangwkz37yIUHgTBFokTYptcY_-3RxAgE2db7eZbnXN1KfNJOPOPJQR8Qgr0NAjTpGxIxIFJZ79LO6lAz0v-AKX4MQc4Zb-7ZlCd36eZr194ciTRt4y6RK1onb0BHnnGAcQPblqqikvaGDweYxLG3GyVmEpyVQ5-BSW2BxSoaKHZKd8fHyMr92NPKgfS198sf76yNz0CTrl7DXAo5RVynz-J9cosFvzFYYw_5dqVubdKS59NdWqo_Vkq7KMMKqTVV5ZXrACrXVFNl1HIUHggLTfhwWJ5DUF2uPkfQuL13K9p6IvifuPjC7LfCwJjnNfaS987zwJahPXsvOtSjuYQgBFH8_lPRk=w1082-h1442-no" alt></p><p>从清水寺回程，我们选择了步行，这个选择我觉得非常正确，可以沿路看到普通的日本人的生活方式和街道等，套用一朋友的话，走在日本的街道上就像是小时候看的日本漫画一样。感觉，整齐，有序。<br><img src="https://lh3.googleusercontent.com/T5VbSqQ6TVPMEqfvUkL3W0yZZ76lp9j1hHys-w8Bk_jLQNaYSQS_VZIZMhrGVGNDQYb09ehfL7R0O2Jil3wX8v6cmDvL--CuxLX9C9NlMn5k9QQBY_vsJz6JS6XZU9Fp8V9z9p4M6IPalGU-OF9FUAjd6c-06HAsON9FtXC4xFEp6wErXshtXVhmpdD9V4Nd-3ZdZpKnv3ojXKoyLE4cLXZB6-y3768g9oREqEqwTZti1ckg9nbugn17sWuCVgKtBR2XQb4FY-Z9qOIu37NMMjdPBgDyzgmBQJIg9F8jGjF42dDGGE75dD-GGrQsuiYxM-_3Qo36lw1ETuRTMp8cpP8GLmmhETQnNdpzIong7pN7VBKR7eShnQgOnVjpI39vALluD_rvLJqz1w2nlupaaauZw_9sg8pOYhJh1nDRaVd3snFBL5zKtmcO4s_1IgXzJBc9aKLXA30Lf3jdbFWzuxVIC_8O1aU8zdJxBvHGg5QnIVnR0RBy1CVsTrH0e78U-bYkjleeQTU0gXq_BIefBPj1iKEBbpwqXFmzYcI8hUdY4x0_kHL3dw8jbuxgjmf9hj0Ul5VX4zYkkC4Ycv4_SMdhnlfl_MFulHi1wJHv-faUTlVW0_OSEw_A_WAjxJQdVd5_5q4PDH9DZI_GVWsX62Yf45WUzso1=w1008-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/ZSWhTqD9y4TakMx_gNeDIEiYSaq7W_jKq_WqzlXqMxMsJxliDs3XrxiSNLEpmsNCYd2lsvTq6VdoymgwNVufgxMzFz4JH_gtRJxgSNdkZ9oGcaNSIOqUXpzf_A5PAu9522RkSrbiktZZptbWFMkrr_7wMLtiZDOoantdHei8mVo-ekjK1_-hxKUZ6UrtCNtrKEEgWwjIAsQn12H_-i0KSbn1eWd9d2-zf6z_P6cLP-XBsSuJ-_IP6RswHs9ml_-PxKG7IDgbU4eH8P-vyjNcOrDDYVfaCs438iwYZudv8vOATGcWRMfypxI8-chWcEI1MQiLqu2MND5-O6xgRLCP4d1WjW1mA0PW7J4D5m8ibUnh1x7T25eZnvMFZP7E2enNpeb_EUAfEtww1YJuPcLslJRvaYL-sosGHssyGimcZvj1XIH4P_rbzDstly9Uj2Ad_ZlMDx_GTyrG_jGDHIICS7La8EUtQUj37Cu0AG2QXAnBkhr5S2NXhlLBIdzwkfgW5pVZdvNnZ_BMKEKcePHy_QeG8VSelLpjoMj7nF3wnoFRjMaiEiRrzw8253ayCnXdjWJKzNpEIw0CZf_nwbXT5ITnLxzkdayUnzzbQUl9ExNRedVBpueSPWY9qP4SqFfIvb7iDbsRwdz7q0ULZFBzdMvx5GWmy3B6=w1792-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/6Lh2dQuF6WrvR0hg5kYffT-lPAUm-6gmf4WwHqEH6kxOsswagiBkqled-y46EVSQMnIunpAFGUw8dG3M0PZF5gxVHKC_u-fOywg2Jx-WYc3HeDeYJiKWpFjAovzLSf6eQ13vLeCIkCUxwsB8QQ-hvmDj9twW-Ec0zTOa1J47tMtYJMQo-h8pCLx6NmNpOS5eV_4wylxydtALEtGD0gIXe6f7cGefub8qcnmAKXawzxqSBKhHgrB3sVXKaQLPRDKekLQW_w8ns2Ft_tbHtrs-GNK0DPRniCBkUOQ-KuDBj7jmgQrq_I_yYiIhgOZY36KxGPUfZdlfstZMjLkjcqdP-cU4q6VDhjjB2O2eG_gxdsMjGqXeEWMvkNWI6ia_xL36GwXn9_UQOt4-nmPHcj4jG4IDiI-WOdIGZAX-W9ao_c-u_tgZHdOIoPla7nSXPz-88hW8D1Ewmv3kJVPxOucqQQeBYbBOFjATEziNQJQQ5mY9zSt5m3ubRVqviVJ0udd7F-dAQsYNI8xVQSV8YiNWBsj7Je-PSDHupiKA3zMN3TeXnG_F528kfhatyiA0ewzhu3KanHTkx8DHkYkPDgyzyamN72w1WTcDonvDZXC14koaBu3UE46MPMyOHu6YBoxQmfSynUNLlSz1rr-dgulRVl7AThiA3yk8=w1008-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/6rzKbTpPW7zPTYoYqwZLy5r9uPKWqRlBzJ6ZQw1MOPurOVdTO9Bh3MOdMKZChyZtlj_97DAmDQPi_YgoQr71DFhfInE0dbRsquoRT-mH60Zr3-JX1e0SFbtSm5KoiGnRwHfZNRnLi-xrlc_TTuBimvd1NIUmMV6ngIioc6STXPZ6FhKkMtlVOslfiJminfS2QU3yQterFW9mDBjJiUhWcHLINolhcfplm-w6U3AK5G5yoo_b-4lTQHBqC7o5rMb7QDzSmgUH686hrc4Gptb01nqmv0fhKWKtm4_EeNpodLiTcxVsatNh3GJsjwz2h64myKV9WIt6WqqiNpFL8XPxaKqFrbwM4WzvThsgKPwHDP3A8ma6Bk0bdWC29Qdx9d8jyB3xE67mqYLQ9E4qcqE_Y-JO9Q-q7w-lYJMoE0zO5AsYFSStx6RWQRTGj4jys0QumzLHsDtNN_JcEynoczou_4Jh5zeEHJIeB-o2iQZ2OPa4kcoBnyDaqlokjjlBCrdPT-NNF1IHig2x4EVgUG3y214Fb6WS8Mt1Kk___6xRDJjAOU02a9DdfCZvMde7i6nsm3JoGYusmm-gDeWeJQj7kmD0GXuktO2x95Y4bARJJzHeCh1JD2hqf1U790QLIUfQhNzizT1235GS23EcXmJFV4dRdQ-QIQrp=w1008-h1344-no" alt></p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;行程（2019-06-03）&quot;&gt;&lt;a href=&quot;#行程（2019-06-03）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-03）&quot;&gt;&lt;/a&gt;行程（2019-06-03）&lt;/h1&gt;&lt;h2 id=&quot;京都&quot;&gt;&lt;a href=&quot;#京都&quot; class=&quot;headerlink&quot; title=&quot;京都&quot;&gt;&lt;/a&gt;京都&lt;/h2&gt;&lt;p&gt;行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/BHMX3bN7AhJEWmFzL4FAxc1Y8L-oci5khvjwNN3TzPQI6gaGDcNvCo8bqhDRL4cXagfrSUtR55sgbu2gHQXqDBVOngGcBYBiuFaAKgW5IWM3vhrE3xVw3UUw4Fur66KFkcWH5F4zsVfOpmu6QbzFwb1rt9Srr2U8ssojJI6Hzu5M4oTHfqUskJmSMg-3EDFTxK_sUZHvaHn19Ot5mqNRddF1cs-R0YCcuXAzT_CPm4uKc8nJUWPwPqU0mJCexkWNZSdQXhvzuy2Bl1X2VSAsHniWJmaEdgjjqyEyBMr6yObu_hTm13uNVLLMWmnsbMnz56qR8L4ubykpZSKVmmEciM4JujPQB1LCI1dsSpaXrmqlU0JSyjQWQCg9QCVcTFsdx6SNVCI1tvn3gUGmThGTflFmEE9_mxAwfQ85o82QmaVIQlnz8aKAEApGsIKMEYO3y2Tn1OUn6YRKCq5cvG67Kq97W4JOLyTsDwWeJVojTHrMA0tw81DEqfyEl9yA2c7X2PWK8VqhEv9hnOLyKxrUJdZpge3GJ3--01TnqmYZqHjHTjS_9hkHfxVrrDWYzIWwEI610OxrABLj5PPsGgmS0k1w4zZ_VSC7TI1Cirwt-y82zkTLfNGlIzwBB2MQwx-WHxZpEJOdj7mOUyLKAYbjSLEQWhjDhR8T=w1082-h1442-no&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（二）</title>
    <link href="http://yoursite.com/2019/07/04/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/04/日本游记（二）/</id>
    <published>2019-07-04T14:17:22.464Z</published>
    <updated>2019-07-04T14:49:35.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行程（2019-06-02）"><a href="#行程（2019-06-02）" class="headerlink" title="行程（2019-06-02）"></a>行程（2019-06-02）</h1><h2 id="高津宫"><a href="#高津宫" class="headerlink" title="高津宫"></a>高津宫</h2><p>住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。</p><p><img src="https://lh3.googleusercontent.com/XkWYXNFkvUF5q6r2CX8IKlNPqwdjQ-byij-IM_cFAByHSdIfilYGjE_nvk3vDt4iAMwpVCRwKMiQmDmMqfSlzf2v4Tup8ungxMl9Tu9hZS3bZaucfzWtNNoJIEErPrmUDBUNNhjjIGzY1gQARe9Eu3ZMqYqLUyo4QlkOVr38s-TX-Q4-WVkdgSLT2IKAPdCCLQOVT7cVCf8LzT0ZNTSfFn0g3agxJ2cZEUxZhFF0QUK21g6BG4Ea7tdI5xlc0ocJoeuhnin0TFgJAumJefMDXFme-viHcU38wGK80YqFWRnMTlkgH5Yvdzwe8OmeXFSg1t6c2xjNyN1a7EuSnm8cEFCmx0yFxLZmlwd5_Kxo5NAowwQw0_pOWb7zThp5Sp_mSAidKDNKS6JDqi40jNxbLPZN5ixW3Prx_OZCW1GRkMMNtJHxX9S_bix7_mQsz_QTiMZRtiInW0jZ-cOSPwsv8fTP8b6Fa6MWz0LYfi7eDolikaczgkIvoEQS8v73Lbi2qIbHw34Glk9v0T7SPAWMf4baGf_LRTicwU6u-0xecj8kZiLl169B47Hq-EX43CNyUH6T7e6HrArP1ECNbazS-k8Hi0saLiBV65P28zcBn17yFBfJ1yckE1mgzplKDQel6TY_MEa11d7ZMBOcd5jnciXUJFy9zLVl=w1102-h1468-no" alt></p><a id="more"></a><p><img src="https://lh3.googleusercontent.com/XZi798Rf9OcAazrwTqpduAuk42-Qxr3AqlQlfW5oCp_ckNv7jcvBcnJvqpiaRNz2QHDFjRGIzwGcox1FvWrvq2pgypYz8RH-1A6PBZkwL28q2C5tsHOLUWZHjTw9q5t7AJYYmPqzapOWhGpOgyeK7Pe4_aKgAZzs4avhluj_1fOh2Ez9G3T5rnFX88B9Z4Yc2dCHpBGLyxGl03KGizYCm1Ot2t7FIqCdvTesHksvZ_hJ6JHnBnDGnm-nT0NkoP9mreMbnZ4TroRFb3DDFPza4hJZ-AIU07P6Md0lKhcUksGbQHBVG7fsomXiasA4TWvTq95-sijRYLMg88-tSiPgKvInytanNDoBu5LObQ1-bFYFgYuWZEAM9iiQiNTqH5eRoQjM6lyCFIYoXkmmyPOgOXmzkqWsb5EWa0ymQrqAfRBMhOmODYFR8EjwxWtP1i_wnc1-TYG_Y8KVT-VlDWjx2uRgtT7MO1hstLLyhuPVH4DrI9aTOuEa68z2JlPwICkbZsrP6cIox-JpfcMUmqvv99CdtG1Tij9q14OGaMMits82oBhBovFoyJaiH8aaijQpRcjvawR1yNP-GHUQXXw8ROYhtyqz6t1UML-En3KcalUVCXYACbMrh50ErV4fddt5kr6i05GV8WRVdCvxBJeiKTpBWs3elu06=w1958-h1468-no" alt></p><p>貌似日本人结婚也会来这里祈福或者直接就在这里举行仪式</p><p><img src="https://lh3.googleusercontent.com/GL53pgMO6ff3eN8EGlwRQvFY68NbgUyb0LqArrQlv_gCIV2HwMCVsgijJwEbMcnGH5ZH0v2JjF9_F6JnXTl1iY654AVWH4M_DVZu_Q05HQzt7KAh46NBHjJPziVKmwUhXjV-RM-GFrHCFU8r-BX2X4-qZ2J4_OyYbk4aZhY4laS_BLjpPVqsSpSubyWtNjCyMbTNMEsXMQ8lwry_1EScN4mQ09o8ExfQ00hW8CwJkp2TjR_nBjRkwKxGUvNdE54O2mwPorpoT1zSyZKWsNKFbh9vJSIsAilPvdaywzukg6k7rVjiGVFW7lRasRd126KsHym_t1zPt4Qv2CtGGCF2UfUW4Ysskw8dicZ0lzaD4YWbMivHPHRH2XqkfZ_C3t054ZukTD923VSCNk5FuCbvkUtW3jW_D8iGssviUI23scQaQU1lfGKryDCg-ejAbTgDu-yzr_W9cls2sppfkXs5C1ybnQYVSskocxz_dpWFAIP0wFLC_bQZ2Y5WsW_3mv-Kl482xnr9heCV09cnymwlDzUDM4hDbT6MEr8l7NJ8jhXnPkRYto6sSD8GwgI-KyKStq1bkin849VYSHHHlQCJZvmkwqcRi05R2gR8YUvhxj-04B9bkBajVoV1UXmaup4YxAjkXXyCw87i3wgAYd8fAMyV2PYCYSLw=w1958-h1468-no" alt></p><p>一个老大的墓碑</p><p><img src="https://lh3.googleusercontent.com/hE2TJZb01NYEI9cmJwRkaFqvjK6-q3tQ3grTMXpmdjQfwXIgTOL_d_NpYiCaDXrMxhsnhwBGRJLylH2FSeuzvaSIscyIiAN8Qh7UFN-b5Ch1yqHru5yKZx1umvpSJ_E9RcJb_57UJesBxjWbXjxEY0VPgP-KzNXcB2McTA_5OrVnl1Ah6DKJ5kLzSnz-zZiU5Ok6fcV-2QgTiLeUlpH8w3kjWIHnR6Li-zeJK4Huynzi5JdqbzQCznsZJne1sONZYXT1Ayt6EKtE5J9qBwCeiy8LQkZTDcYjT4YsJJgPjNb5MlmeXivh_IBoGQ2BWe5WWaKYFdvo1hlkZiPYt5G5qEj8ZdI3ezaAqdAlokgTRYboZqKHDRH3vjiLC12Kz4YSe2jmNaUyi_jBFLxI54Dg55XbErXxv_HsGG_SgI_Hz8kH-ahoQC9JMi3zYDBiYO3iZZ2v8w1zf7o8n5tTokKoZp8EqZESYEhg5hPbElIZeV30oGLWZ66z3P2-r3VIUPr0qHN2Lhw66M1S4fSNHVtQhoXz5rvScrhuzcg9QSww1rLTUtrQisQcaGXH7N5_m7D9DmgazpiFufKxvt6M74jN6_KcdxBGPEuPj_XeKeGfhNh3NgVJMJATQqcrO3DE6u_XiD8PV6S6oudpisN8q1g-ur7jna7Bz37K=w1958-h1468-no" alt></p><p>日式微缩版的小桥流水人家</p><p><img src="https://lh3.googleusercontent.com/4p84_9xr0lr_7XTa-B4pjB97WL3WHFqbtQjnoIgdPxV1QZo8kbI4hwktRsxjsgqJX1XmnSAsGtiDexWx82-HnghYIZs6380McCn_6KtBKPl79sBc2DNP8_ESRECe-JL9T6Rroj9VE3JlRYskWJ0qycvV2BNazviqT3-DmCeNqt65DLFzWIrahilyUGNnsgpAIoO9oxhnhe0jTZ5etSkDKyTTKrcU-b8vO5Oxx4MYiG96s3sFA1AtYfSFXeKQT0ix2nLgw5BjelFaSQa77bN25SZRK15OSB4Rserc511MxW1J25uU_h77iSCchLR5PnA-YF0un4oiTgGYsY1iiECHEYFNSSPIQbHIYzbl6ECiJHAjT2eQRbeNXNAuzjbHAprlcy2nZZywnc9JSToNv0wvJ6GKL5ucS5BXMdL4XkPyaVx0yQG48jzW1LmuryrDnumdPi6P_sklwuw-RrenknvlvL3u8fkHg_sDrPMipJYokRy1y6HBKPR-9ubOhNzytrGJbXKVGjF1G8ovz8m9asq9-W913CKmqR1JUYckVjqzYhSQnRKgCgt8XUt-e8HLgQKBhzQfwqKzEaECxnNvjzN67ue_YnGU5andFbIdSDSbLO-AkO95le33_SIawk9WECWJthaeA2YHWINCCJ7Qa0PHPdNkVN_qbuAe=w1958-h1468-no" alt></p><p>典型的日本神社⛩️，门很有特色，然后也有神兽，不知道是狐狸还是狗</p><p><img src="https://lh3.googleusercontent.com/12PnBpVVmDcuGkGrsAaR3WInXVeRsgmldPCz1cpfL3jqvz1wXOj__rQYikIqRAIVRKub8DXQbN6OEk97S1Y0J8M69wXxXfxcsOTgOpnDEOXRctDy1mM6mPiXEorYeHAjN9MImQucCOMIWyaVSknBpHpIW8aN_Pg8j24jQUzxgtnlTwsxzzQJjevy_znaU1_zbZMeuxdWgcahXIkbmhrHIn5uP91hbhWCfSBjl_FCdnUHRE7Sn_luXRJYECXQqrNcpu0dREe3MRVCy1smG4-HO1Dtormn0pc4VGCT8VuVGJh2U2dQygsxN1eqv2uqSb-8gqKIJHyj_PaHaP6OvqUmbVDc67rpGJM7YqBU57QPAclY7uCSoIc-tF9FiPZ2fXzQQxSwzCN6atmsLyFENBSd46OPsSWM6ZKid5SrkV64N794-Jl2eHra-vNFmqWGysIP7H0bU0MkTC-HNrP8xFoJAFLXyeIeWnu4Vnoc3bMJ4Gxydvw2S5NbKWuE80Xl4cE7MKBRP4tq1XnoZK-Zxh4B1UkLu3zZvQoRHAWvZcrvIG0X75cfewHOD-U7ES_KLIoKHASfA9UFMpNCAcvI6h8_Z4neGGYUbqP3Pt7rWM50xTG7dj2UjBvjQevbR4lvfne5YqxY0jukjNLKnheXHKnYOK6Ykv9bROCC=w1102-h1468-no" alt></p><p>神兽<br><img src="https://lh3.googleusercontent.com/TLl2I69ZgpbGP4xi0Bvlr2Fx8hOP7xIp8RF81q6eBvwTPGyp0bKQtUdrHOidEqvmQXgR5k_0JgmdMiGiQj5Buzy4wdAtbfbQul8pHaCL6A4EaKVUlfl74u3Z1_gAquiti6VMnd6MMB-U5UgQiiATm53wpcsrPHFK1j9ZqrqpuRU3WF_hldXCxRzeOOQ14dE-uPooqwHilj0oZgFvThSqIQheMXyFLcpAkx3gqoB00q42Xd78hnhF5Xrb_X2Ddy83Y-8PCgaRZJJWl3CuyCZR45u0qSZcqygmQlr-teYaI8uQ-8-bqJIWbbbD5p4m8b4gS6zc2pPA7BfLVFolYMqmPm8HFwzwYjWr2UDT_VfLF8CbxNVBgrbxjAR5zmr5GSHj3GvjWiE6WnvmiZkiIawm3TJicyHFonSQgWCWGIsKtTAXCQW8BVSoSStrCjh_-ixdRSUou4j7Ds_7svhLTuDfuO2PG0cyADTmMvk55ckqo2HbUyQbmvTXfC7dxb1E_M-S5r9wtJ0py8ukvLWA2boSnI7vvh8H_HyedVufe6-9RsdhRqm2BbQpF0yYofFTCwX_0bW0gwvrX8nvDDwe5yxaX6-SBjfDoXksPJwNs6j8PtDweNIDQl-BaCeZ64Dw2tgWSxdv5gflkDZbQZ-PKjUr8_rWfUn9GksS=w1102-h1468-no" alt></p><p>初来乍到，感觉什么都很新鲜，一路上用手机记录下沿途的风景，拍的有点多，后来去了京东清水寺，伏见稻荷神社发现高津宫就是小case，不过这个神社是日本人自己会来的（看见很多日本人来这里祭拜，投币拍手👏然后双手合十祈福），而那些都是游客去的，各有特色吧。</p><h2 id="黑门市场"><a href="#黑门市场" class="headerlink" title="黑门市场"></a>黑门市场</h2><p>来大阪怎么可能不吃小吃，吃小吃怎么可能不来黑门市场（小吃一条街），我们大概吃了5，6种小吃，由于是吃货，吃完才发现没有拍照。评分很高的章鱼小丸子我倒是不感冒，不过和牛倒是值得一试，特别是网上查的这家店（黑门市场几乎也都是中国人，大众点评很流行）</p><p>黑门市场<br><img src="https://lh3.googleusercontent.com/FYpRyKjXUEDiYqVZWE755jLkYezKwWl_xGj0DaTO_TetX16PZRxtR2WH2s2AF9ZFbymUMtjbaoAYClqlvJkiDfRyuybKW1QdLcTZHA2T-rGJvZpNjIN3gbfot6BOXHlpq7VJW8NS1vQ33cfI0BgbPE-GbUzaWgLQ01-13e9j7jT4mUOCcVAMW_3ilwyZNWDV46Mn8xrMZ_cPcqMAo6Am66UwgRuNr95ben-7mia8qEtu29rnf1BlWFRNQNkqU7N4JZHOhk-JFunEu2uD8E8VPNjAPB-7dAWKNDrMs-jXh7t_YD1XCAiChefCHRuZKQEMhoNr92T-2e_rF8HWO7DseFAuHXKDCQLUAr-epT0ratJDDfkofRqT7EaYi31p2opomA7OHDmQVxHaodG9ni1PD_yzSAMYP6Lmh8Df_v6MEQ4M9n5nO5_h1mo91KRWrLJphm-Dmtl7aLzDAtF_g6eq7el-cH419a4wBnc_dFaLXo7YhJg9OR9mWdjcD1kwvPuHfNZxVEkG5mEU5jTXGRNByfhE6muoVUFRXyC5QsA7jd0byVjy0Zy3eLjhWm3k6UgJkJB_LIkfltrvhiRpcy5gJaqvWj_a6ofIYYFZustkBRwZDn0qq49xWlh3RPewWuEXGstCo6hWHLGijOyJk2Gge1vLf-1JHte5=w1102-h1468-no" alt></p><p>和牛（贵呀）<br><img src="https://lh3.googleusercontent.com/TVCRSvDqtkxSLwrZ2xi2rivgXBT3RZojNFoAAcStLG0wAnps7xvzrHZeHRKP970EbTnh33RGhiujL1qRwnCnthySObvXU1gHZ1lakLKjWd5yWI-ksSHIdetYaUnZWrZV_EHgRoqApN53ymQYS8WRsxxd81MBU7MEA3Q6yLm1Q7OimBqrV9tu-IuraUQJWq_RThRZoMB2gN_ChLyEeg3qeLtIsR8oDtx15R1e-lJblVxe-tMJzT1hgt9sqYEMJ0SDvn0usb-QI-5EugYyyx6hIrtmTNYTbq4ao6ETbdgx_if_sE7NuV4P91YZG_C-mMhdRpAJ6jCILzvW1F1SjWX891ZFIxPnWpWze1_dfg6q_VZdZCCe7657LhRVniIQHdtk41H5Qht7qEyNWJIn3-edismGGo8Lvt25d1fxzg78l2BNu94LnnqyammG3AVtWGP19Ww5XwXc2qV7q05BqvipKZi5-g9qXR6s6ezVmYbRwaXNChCd-T0zWPnRVHOpuYyG06DiRQ4MofJr1XuCnP1grPsK7X1r-oD4NbiNmwxmoZZFFDk4tobuxqN5OtQ6hLozaSovcLpnT_K4fDFIslBUEdRm-dkpX90PWql9ErWhnaixYI8kK0pD3KHMwWwAegoUjsFXXRQ2jNQwZmpSlt0kZwGRto7WehJI=w826-h1468-no" alt></p><p>来一片，就是这家店的牛肉还有食客证。拍照</p><p><img src="https://lh3.googleusercontent.com/LVEpwSv2WpxIDMB4GI3TJRSl_PEOPc3m_ljHDvPmZMn4fsVMTIN-lumfRJvim2C4SD1aQAjBj-H75vuKIz82ee4TImn9VAK1QSwNJNVMHFUm099CteFGlA5ltV30LiJkTCcIZXq-4Nd5rpBXvb2CKDbj5bbt--NHECgGgpxL5azCAFcp_tb19fZrj2j19FiDX9QxEcLoSo0Y_ZdghLOSBqtoJC5Fn2jvQ5pybPReW6N-XqSeWc1XTyQq8qB_YBnUfyLveXujdrcKwQaMNCjUbHUfCu04KZdxfmrgxtypoI9n7-lmxbpKl8HuLR7FN18EvLxuShfopkhfhxvabWnpDPNZ3cfP9-PqfeKJSTKH-K7UrRQ4L0oZvyoQiu5tO6GwORzjpdBML8j8_Z5LJECpdOBbKnKJ4I7xp3VkkyNaqHVZRkjolRuQvU0iGAudUMeFvWvnzi1xjqsibRQb4M713UuvZz5X56-j4ig19fPG2z3VLwRt_UB_KC1XsFFg3cKbX9EC-Z5RhKCUUxCXC75RR1fIR7w2UQvU_iL9vJXQbn6IyJ6ARr45znPhvW7A9dujqXYeww2xjvqTt_BKzxuMyCGFjoCbUHmlMiNN29GR7hewUsUy2QCd64vCH1dwzUXiMOwelb3zOSvTK-xSySv_hTf4XMxctyeH=w1958-h1468-no" alt></p><h2 id="大丸百货"><a href="#大丸百货" class="headerlink" title="大丸百货"></a>大丸百货</h2><p>吃完就是shopping了，来到了心斋桥附近的大丸百货，途径道顿掘<br><img src="https://lh3.googleusercontent.com/N5SpLQMl88Ane-M-Jtiwj9cuRA_qSwc-xonm0GSy7HV0WfunC4miJgjerZZsLSICs5FJwqVtv5mQndh20INBGmgcfMdhMmA27gC0BaC8xyvPZRPrMI0DuImCcsE7cOHTPv5decTw6nKa3QDOCTVMFm2ErIVgTlImS1QxVcnL1K2QcS9uKEYwrthRKEV2ZXkifnnmegbxUARqm2f7OK2-dZSIikDLbznFHrl815kQ1j2dT25G9UHZAq1oDPUpE3q2NHS8q_IZLKOxVWZqhJrzHATR76mw02RR_RTJpUk8Ow0cL5771YkVhHOqzEU7RaaFTueVNviOG1IAfCf4BJZorD5YglIrQ7928hF3Qh6qKZ0-dRBJVHGGMRazMMlNc80UcPWjknGl6YFeDjyvJX2QB6dDbfxSf_EP4OXU7utLYfuHza3ddX16-qC5xIyf-ll6fn42_lakLNetBeDbMKJqGq2vM2nIzQCrRu0pUJ2KuYTtGpD82ii5_hXJ_D_oD_eMiFH2Qeeq3shd_YflqJwrExMBMl8YvAUNQTrvODQnGpizUZGznXbrv7kNIviAb3nLvCdtYLm6B_E4TYbw40n1PnQb5fTpZ3S-uk1NcjIQRdLbkhC-D1LSsZNcU3FH97CJ6m-upz-i8oZS5WHz6EZykUKmuX9PLijl=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/uA0qikR3xcN-My-BK8-qo4E3wdWFxasHLCC8w2rMRs4uWFaJslAyRhkdgxuqlFa7RTYUNsSMwwVy8xgbaja_j5Y89HkQ9bjXklsz4mamwaPMnZ1wLo1FXF3kqveCjPzFdUvzaEJJwbkcIrxRkKjdDK-Xw3NX_IAhVQksMdOXYESTydtHq2za2AQ-u7OzH42K2ipfgJOfrAjo2tmAe6dZC5Hn2PkTnivauj-Vlhfg4NmYTcsnVsHAKSxUQzxxQD2WiYtIgZPmpoTmOeutrD_XFK1zd3wCSD5TYei5zwX2XjEOQ9b1HaER1NvwPCEplUoMtNWQ7GhldlKxL6AQXiQ8mMoMf3DEocy88_GVbKRSURYcLcgsGAc6kyD1Fffi8JqAVOH7Ywmez8wfvWvCTGR5x40ubJ_n4vf7ESW3uzEmJuzYsgYkSA-sLsbzQjZtibishtsTt3e1gDM-JgFlRzrWr6dx90yF-mXUUk-KcAerRlwPIRWiqVnJioYhdL0Xx4Zb92yvlpR4irRi4ojE-0qf2jSahD2jf52Fb5S7I0zl09_qkcxHrgPEqRDfQWOSyq0LKTBmMl_nMcR9rLSyxGH7YYfaRcheTuSCAkidoKiXBXEtLwwdTeBMHoZ4Kl0nrN0_h6zIxuTxq6xezSTtrK1aynK54fgESe8r=w1102-h1468-no" alt></p><p>天公不作美，下雨了。</p><p><img src="https://lh3.googleusercontent.com/a6sNYW6B-Kk9DJoImuWqVehF6PLtKomWEoHZRPXqh2carYDP9axAAgLOOr4RqVQ6uAowzS9dlKK3eUR5vHnMCsWWBVV0o73ubPCSk4PW9wA36eYFHkVzDbDn19cZ1oOepiup-ap8U4lsaRGg3lWovUVpTBhZL1rLYjGxtlczcAXRQ2C2iKQhySWNNONrDIFHe2boHCIU6BDrep3M_SRIGEovjDdw4TZqwhtM48ctaBbYjqcIqi5TI4v3Nq5o0OXN-C_HzAdCzg75rl-Mfcw10Q4nmeYkSVFWt6SzMTs2Vb_cUD4SPpNqP1Z9Ly01HklG-PpJ7xJTiQoRoXdxIHlgK5MxrVCKmc_grFRbH1sKR2a8L0xVQTgDqnd00QSvR5F0rA1BQxe0yHYLUJ9JSq75bH2POfk9shIMMjDSA0mZQYyACEXU2R_g9QvXMI1PxhS8l2SDyN7Iu7NDiMmyj4d4jW4idmLvLL5LyeVyPODrX9Yn7iCaOzC59TSQXrFa7EYOXAyQwfPCD7D6DTZzVTYBpONJpiIAy2P_zMGMeWPyk2iwY9cFvTw2rbSwNssr-xpwVsCBTZqPSMNF-_Yn6fMsrZLnGqIpEKAR_bzjQeQJLw0cz0oMy_XUlU-feBPSXQoIyr6lztSoBGjoJNEfc5J_HiDFDVbkRaPD=w1958-h1468-no" alt></p><p>道顿掘怎么可能少得了这个标志呢，哈哈，感觉他跑很久了</p><p><img src="https://lh3.googleusercontent.com/mXk1wnnmtp8_0wtSYZoyKYvNNrWqlPNB_GETGS0YPsZ96bDMBHGhBigU95wR1b5YsKo_C4KdmY7Vt3A9zPhe-wJttGVoYaNB82QUI8Bi90CDQZzKewZsYK_48-4SgBb3kbAZSPUpMsxaSS7sYQAWyWh2x70M2Gk4-nrt39Wi4BPK3GhkT0mkwiPDGx43qAlejg-RVzbL_X1WoxdWFuFKLWrELD-eXQ0nKqJyBuDeqWA6yBIxjzbrkBise5zj_Nx7anbmKV-nAhuGCG9kaIK-hrf9upw_rn_KOj3UaIIKquM6_0krTNZLja-wdCLgbf3nb6arTMsaRuuy4Rj6qhai17fNV_fEKKUgjgEbvXswsXWmHN63y0NOjBKWm0FdsZjV981nmSlbDGfVBnmC0lJiYRRQNYwTMMYJIBow2pwdVOwBhZIBmWPMgBPqqhTMNAJXQZr22hmy-KZmAL79i3rH1k-KNZ1Uq_Zw31pPqU5HbamW8MxQJgKgRh7ZFU5cCh3SdJldndCeh50OGesvd9grZa_eRB-3y0IXYd-sh2jE7V0Uwxq3lZI3ERUucC3E3oaXJXJQsBKmG_7Qj-0N3xi-dVC_0RU0dlb_2mmBFK7YtxuyfjuRkLCG4KQsxg39NEgbNk0_jLI-ED13Jmdz2uvdWo-FCnt1aqH5=w1958-h1468-no" alt></p><p>好了，购物的就不看了，附一张老婆要的阿尔滨吧，后面的每天在补blog。</p><p><img src="https://lh3.googleusercontent.com/nyKIrfqkGeW74PhEgRUNGrYm7sqg4XP7Sb3Z4nkI3GQnU8urtVHFmTppQVpwU3ezGE2mfk6tXbL3s9cukT2aJl6YRCF9JuNbBxRusNf-GLFtgno3dEyskINOS0yj2jSt12hgtJv4PMaCHh4JPSUZUNZ3p_pvR8ffnmgCDwhQ3s16xhtqCS9dlSiMJCGr7lZ73nghTbgEbBhtKxDkJLW_JlOqo82QJF_9BDzQ_a4gDn2HgppY351z3XzOqDo4dc9C2f1QNjcfRJ99DJ1TCDEt4mTWlCSTaFHsILO0detaWw5tVJL8_6TwI6TjNLyUPUnN1OhdnEttYOhgTSB60TcPAADisev-jF6v3bFDJ0ct5VghTNMV5hQfu8imHl_USFNtxwQpAjJhhuvH8eq2AyZsj9TARm4aP5LlF4dh80VFXMtVdt2F1IwdPWibtWiHK1V5HUjQb_TCnnnH47cX33mMmCtoWfsN8GSulY3JO-HU0wEZL-I6Qsu6_X9cnO9-U0c4oCOg7rAyQrC9tnL_PdOb-yaSbDucKXwbYIul4POIDi3N8kQKEL5RDhbUjIUiedCfPL5vvFesYDOHuR7oeyBXu8ZcNzUa_USjoBTRfXy34WG2oWuXMqi9Kj9_VMCg72BRghxd6VHiv08S0K7CBUQAk0HsCl8QnjKM=w826-h1468-no" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;行程（2019-06-02）&quot;&gt;&lt;a href=&quot;#行程（2019-06-02）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-02）&quot;&gt;&lt;/a&gt;行程（2019-06-02）&lt;/h1&gt;&lt;h2 id=&quot;高津宫&quot;&gt;&lt;a href=&quot;#高津宫&quot; class=&quot;headerlink&quot; title=&quot;高津宫&quot;&gt;&lt;/a&gt;高津宫&lt;/h2&gt;&lt;p&gt;住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/XkWYXNFkvUF5q6r2CX8IKlNPqwdjQ-byij-IM_cFAByHSdIfilYGjE_nvk3vDt4iAMwpVCRwKMiQmDmMqfSlzf2v4Tup8ungxMl9Tu9hZS3bZaucfzWtNNoJIEErPrmUDBUNNhjjIGzY1gQARe9Eu3ZMqYqLUyo4QlkOVr38s-TX-Q4-WVkdgSLT2IKAPdCCLQOVT7cVCf8LzT0ZNTSfFn0g3agxJ2cZEUxZhFF0QUK21g6BG4Ea7tdI5xlc0ocJoeuhnin0TFgJAumJefMDXFme-viHcU38wGK80YqFWRnMTlkgH5Yvdzwe8OmeXFSg1t6c2xjNyN1a7EuSnm8cEFCmx0yFxLZmlwd5_Kxo5NAowwQw0_pOWb7zThp5Sp_mSAidKDNKS6JDqi40jNxbLPZN5ixW3Prx_OZCW1GRkMMNtJHxX9S_bix7_mQsz_QTiMZRtiInW0jZ-cOSPwsv8fTP8b6Fa6MWz0LYfi7eDolikaczgkIvoEQS8v73Lbi2qIbHw34Glk9v0T7SPAWMf4baGf_LRTicwU6u-0xecj8kZiLl169B47Hq-EX43CNyUH6T7e6HrArP1ECNbazS-k8Hi0saLiBV65P28zcBn17yFBfJ1yckE1mgzplKDQel6TY_MEa11d7ZMBOcd5jnciXUJFy9zLVl=w1102-h1468-no&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（一）</title>
    <link href="http://yoursite.com/2019/06/27/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/27/日本游记/</id>
    <published>2019-06-27T14:34:56.375Z</published>
    <updated>2019-07-04T14:47:06.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。</p></blockquote><h1 id="行程（2019-06-01）"><a href="#行程（2019-06-01）" class="headerlink" title="行程（2019-06-01）"></a>行程（2019-06-01）</h1><p>此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。</p><a id="more"></a><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><p>我们是从香港出发的，为了赶上12点多的飞机，早上起了个大早去深圳湾过关<br><img src="https://lh3.googleusercontent.com/9mnhn5QKimcMCZk3KeJCAMrALDZAOPKZZZ7SlJ6edv_68WbYZg0BwmRwliDj5l2AZXTGgEodICoXDNN-5JkCJ0pfdwqCEM8wO2zfkwTsdiukhjU4U0-N3U1LQN7tzOfegsS5wuUQXkXHzrCg8pox_9wA00X3t7P58HRVO5luhk1-vmch4ppO8DQg81kvAx6-DxQu1wYfKYBsiPfqXnsvwbQz69liDsMcbzhfcsPAWU549cko145bGC5nHJBYFGKv83ZvafViuj7FmrSHv0uV5g7d9Rb-bWDOKayKSzqlwHAD4yKj949VTPSc1RwNnD_G9S1UrzduUj_WvULvgT76yyScCWV1eMGZmrNJOGRWkOnBFLGP9gkc4_ugh1dDYBdocIg-_QHHSs6vJ9-cIcF771qAxCGz23J_eDTP7yIFROS88Wow18dgMQMg2bIqc93OLW2Noqy6ggzefUgaKSEVWoUU5N5dvtOVDsa1dMY0kcNAJOgEkEK7bkhz4L1RCOeD7dJHkylnIn-EPLz8FlycLLrvAPCBbR_pXehuRzC70ZCM87dnRwAtBbmGWTSAnEj6BOHIyQTz-BR61fYQXbUKQHPF-G2wqKTPIHsTnfX9tFCZp4Gec8h2uHBBejIxGxpTD9e1663nygkwOa66hAobG2zXEwHt5r89=w826-h1468-no" alt="行李"></p><p>坐了个商务车直达香港机场</p><p><img src="https://lh3.googleusercontent.com/1bhd_wB-fdsvJYWrzT8q2_s_2ky5U4S7Tk6aFAuQcBS5lR5aVZaattG0OT8ZOWxd7zzvgFoICnb9Qzcdk7y0yxp3Ni0S8_6a4PHh8EpIi1q6FEYfcZ5c6xaO5gjtZVIT0Fvgw9VFTFEfGAIVkB6KNdW9CnSwh3cvxAUw0FmOv_Dp0uY3IOmpiIOxH3OVZbvgN4Pe6dUVNacNOqSxnfDZXR3BgLmUkn-R2YPDgY1PAp8NoEoNYKuorDGncvE9YRRhfU-6nePsJDEUMDdLeSc-o_CsSvLzUmSpU2FjT2HcvV9HhAFXyaOi6dRpvZX4TWfgmsSPwD2CyW551ZFt5TJ_EE84bMD82NfreJedXQMs6xHhvsujzZvdZQgfNHR3ZVsAH0xEaAjUsxUY1pxyV2DZRxNI-7wYa5C6PYIvefy4mxr1DW-We7yaqKLRbh0voPdB0DV_fPohXCwhT0tAC32bZ3l0oFcBsfnc4ESSHLi9y9IJ7cqXEq8Sn-rSTTbi1nGrb9aGpBgU9Fkwhqx2XzIsUnSsqDoJ3kKvbmrkOsOdw5K8-0-PuuryyrJz_YXvBalkZMsOzue3piaZM3zmH68IJL28C8UufB4UsMsye3IjRmn4gFTd44N2CJ-60z-QJ5T8ErLvuSkO6WQebqBpOp9ZyuQNQWsi3LjJ=w1958-h1468-no" alt="香港机场"></p><p>接着就是托运行李等飞机啦。。。。。省略一万字，怀着不那么激动的心情终于降落到了关西机场</p><p><img src="https://lh3.googleusercontent.com/ExoMihsAtfuA7kkf7OpdGdn_NdFiR0wnxMXpMQN_kKoQL8V3Q5IaefTCtUMxKOORmMiuF9FblbMpHG2RoxaWenwp-mCGp01Zac8WFAcmGIeBhHpAaE0n1tUHf1Tke0GE9rPgAWS9aroQescIAA6ipe2R2nZhT-XRpcRQQ_gV3DBXGAH7vBli6iBHbWYBeAknYGQf8rynlw3jQNKIqtrrqwwkiX-j0eC8vt11uknglOX9MY5IZ0TGRj89DFLXk6b48hzlfR4ErX3ueK0OPOUi0HA_zoyrdl4fZQ5qLqAoyQVqplCq4z96J2cJK9k484LAysvhZSl2Wo5FC-1J4DSpz787KFkpXd0KZlIkpGfdcdpr_gyP-VpJsm9RRQt2iGgTv58nrcc23lpIAzjJtA3ytJnuoNmCa5963v6wR9ERe8ae0kAYyWOqfDvSwfF38IJ4UkZ3Sf9bzjQ7QfPddfDqPzuRn3O8ogIyjJv8XDfVttqu1iMPuPUdle9DomkidWkWdPE36JYyMGrcn_DHFI6HrIr0dv3wwcIusIiavGs9kJi-zzGbQCSiKq0P-Jw-GVQjMugc_U_H1lLXopvCXk7tnEq1ETKP4w1KHtY5g8U9gxyNyz9wKPpwgvOagH5Vb3ofsTN3BoLv3yvuAJkwv58L_CJ4MRIfyfh0=w1102-h1468-no" alt></p><p>接着就是入境啦</p><p><img src="https://lh3.googleusercontent.com/QGZ2pP1mfTQMP4oxrKW23qcqB4eJ8w9RynDanzUAmD1KC2eHMv4Pc5UxDWVAAQaCJQrNQICCYxzRBAJUwkzFxocKRX91Pk17UH1m9k0Fm9kd8zgOVvYMPA73Qni8L2chzD2AZa9P944QrlgOLRtcyA9KpnLgZizSFLuQvuhJYMAfgbSMJBEKboKygDQlFbK0W0Vij36_30otT1ovBUfDdl6s81aQdLqYPXMbYPJp7esCOIPbvA_0GYTw_GAAEpHWW1RIpnf9-vkL64DJLBudAA3tioGkYjEvAiM-vhGR9OISH8ddQ3FqL6e0tln1SvmuldH1s6DWPo8RyLbdQdp0lYw5tqWMBtkVj1A8gOVaTajP6QOSIY9FoWQKG3wPJeVgcBQV37IGiSksvllHiTq3QLimGQgcsBTmXZS6I0OLKVoFwkzpEHHzasoUjxlpScvs3AwRHpbGYkeLdUULbnwBJCPaonSxnieD8rS2hDjnZUFFE5q_oI2ZxJaTSOJu4OLCBnZ-Vwz-s2KMzK1NXzsM0GO53f60TyG3YqaflCLZFNUeDXHnSPXvEMbwW1Tz-KgPp_E0HQ_1zoskiIMCrAgRURGmr2XZUu5ZbEyzjHt8uGqMHelISJTIdJ0_wWC7raWGJoZsYdmr9yI2GzAwssmHDCWXZCw62hzN=w1102-h1468-no" alt></p><p>入境就是填个单证明你来这里是要回去的，要有在日本酒店地址/电话，还要提供返程机票等，入境后有个小插曲，我有两个行李箱，然后出去后发现只有一个了，小的行李箱被我丢在里面了，然后只能用蹩脚的英语跟边境人员解释，最终还是顺利拿回来了。我们在大阪住的是在airbnb上订的名宿，在大阪市区，离周围的什么黑门市场，心斋桥，道顿掘都比较近。</p><h2 id="大阪"><a href="#大阪" class="headerlink" title="大阪"></a>大阪</h2><p>出了机场就是地铁了站（火车站），日本的地铁火车系统很发达，刚去的话坐车肯定是一脸懵逼，因为他们那边地铁站和火车站是一起的，各种运营线路，各种坐车套餐（我到现在还有些不清楚）。下面是关西机场的JR和南海电铁</p><p><img src="https://lh3.googleusercontent.com/U1wmgQobvVk7EuC6YOnDAhfOfhzm1TEJdIouwAdkDd7XwLWXpk7fhzqlioCNYLfP7ieyushA-3Z2Y1zTLuSfNOj8s6BfGC1s3g2N2r1Oa14FaOf2YXTlVKBFYSx2FyXe_FeZwx22HLppDRsHg03_BsC1WGG027S3ZWcC32yNT_J47L4aGLb6TNctgOnmRLe3A4EDRrQNzcs92IDFntfmCXY0QygLXnkxKh8aIFlIZV863mjGsLuhi1n8JI63g3U-cRSGCaMRthfzY1JC144Zzwlfx5ENDHf91H6W94RcyObvHEriYb5c9fc9ewx2-dDkn4kzxwwjL6aX97zId7FBUl4rlpMgulIq5BB0dhkw6x-PXzTOyAS7fnPap7J8UJA5Kz-yWtg9JECC8V0A77M0YbATFC5KYFTrdzUpvjm45op3dySW3lCfTMDEJB-7WkK_IsVtDDXTz8JqpqyOLUWJ8qqjVHkCXwkujaxTxGVwNtxYYdP6qJporRJ74p_wcQr_smfJVUcl1zhWoa9BSIIu2a8uvHhFK2cOxBgzExG3lJepg9P-Wb_pgJwviymll-7MpM8arkuspsCSHTKCvGf7mJj8HKAdEu-W6fUVOcPSXS7u7AHJWnWFpt3REmWHcEOK9o98MHxCoccXTnbnR8nqW0wtgU1lay_F=w1958-h1468-no" alt></p><p>我们去住的地方在难波附近，离的最近的地铁站叫九丁目，顺便说一句，国外Google Map是真好用，特别是日本的地铁火车很准时而且每趟车停的站是不一样的，它有普通，快速，特快之类的，上错车的概率是很大的，所以基本靠问和Google Map，google map完全就是神器。我们坐了南海电铁大概一个半小时到了地铁站</p><p><img src="https://lh3.googleusercontent.com/w7BLbS9kWcSAxTDncdHN5si8CiGdMdHgCKTVyDgTdletMH1-BS2pWLfUDkR_MJExv9eXx5UXBCsXVjb9OOvJ0Zd0vou2UMRTiHfJj8LV1Ur6L0tP14sy14pmSnZ2QgcFURE37Aj38sWlh8IgNDaGgr1ejTA-tfwaR-KyAeZXyhZe2I8LDE48JYa-wqOvHZ7YFZC-_0r3SQK4tjvFbshLyHtlOPrcQQTZT-2tyk4JXRsqAYD_gkNXJ7P1o23Uib5Bt0noOxr424tWjOtRuzbmCYo3m0O_ZU1EHsP1WwGtMxechYQHK6S3aLaFuShQ5kn1GBg2sMPnAriwu_QhIFslNQt22UCs_C0bvwD2rlw7OatY83fs12tBUZ0iNTOE6CDlcSt7zDDi8VGlk3J1Wp0O-kGsCrL0kaFdp1ib3Vo_xyUqRUn9AA3YMNo2x1WuALHSZ8Y3jtydkhru7OtipnZhgRKNhPTHjgEGSSYBsHT9-X3AoucydisNlgvK_VMvpl5C04Fhoh-aQych5Wsnzyd26E_SuYtcZfyS-x-LJedIIA1pOqUCLBIxJqtW9GNDeOyhnFaZhxQO5zonVBvv_JdKl2_IHuB6bD0cNf3Ki71Crq6GKMhxWkcudLr0m1jPFZgDDlM443sMgTMas-pqZAHlBNHPKkyXWFI6=w1958-h1468-no" alt></p><p>一出站就两个小姐姐现场表演，驻足看了下很Hi，但是太累了，而且也要尽快找到住的地方，所以没有多留，直接Google Map导航去民宿。</p><p><img src="https://lh3.googleusercontent.com/Bd9_5KMrqCd6Gz0G7SeQzhCRy4yBHgFmr0Agjlb2xTKdNeynDmQ8diLbd631prf5q1G0MtZf1GjDHmz-uEHlySQKxrxrnI7TMMZr_N1O0UV-Q6Qcv0fruOuap4Pdt3WdRZ_tXKFU-R4ntDHUMNBcquCOj5M_N_I_sWRiW5OeYxE6cBlXbTt-I2QFND3PZPEPwLk2H-tb1oBKzRmuBm6-F4aluTyHpy4KXM29w0-OwhcHo9TfQIgj0FbiC-QmxNr_UCLwpKDnFbxTVfNUtKSG5dyuXao58kvFCe0LPHPN0vzFn1xJwxRNvfkZePIAuwMUT3vb5dAgiLWgAmXkTZpDGiMNRHUOZu-cChouiJRY-b_0GvgrPubXv8L9WKfJrAgJgi92T3_2Osqxr-B7fkW_fRY8FSyZabXDBHArZqCNMnC1knllEHRgS_K60Pf_CFYwrIROLbXP03xTZK6ux6KIUuUDNXIm7BeTgYMFhLScPbDfgEWpAeK13ogZbNCb5Tdvk3fiUhjPJpIBo8acyesGOwzflQzrahNhzdH3KWdbUja5-iYErE0-5MgvVnK3NoyYEKHXqTVYHYgxdKmv8QFv86-j-hbrPwwHw8-Oy6bGOu-zG60TIIQjxoERq9Fcr2RgojAGTNePCI3P5TFxO6HoobZS9vt8CcSp=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/Kmykn7BlNu0Oiw2u0PVI2YqLZRhhtUdrTdlkua60khlx3tWuWyNjFA7EUNXt43O8vPYfPlXhM42NISHPg9fS6nOZb1roIqM0YsVZ5qQ5etVDUpCmQ58qQpPzUmMv7Ydf6qUn3w5A830I2LqqpGJ8Vxi12CKiY2ioCDju9cZFdzr8wSEeW5X-VbvGUmlW0WnYsvRuAFkrVavk-p82M9WAw8_xopoiRx96bI9QvD0YVAiD1qxh_YWtDz5OVWzeAAEQN6rtKK5OIznlWZp4sHwF7Ob9XWo0cQsnwg54zioMBVZejf7N289irx56Hg01yyqOjqWjT4Ff1VzzkWzpk0R2-ukHN7-4n66tnKmbR4-jpnhdFSPcY_IHWXRnOgg3fMCNpefb1oSwI1yoefAoWcMM9XiYV_5cBZVprLVwyGOILtU8_2hPRXUb17QZWOCZ72aH-V1z0Fwqxlbxiyro2VAJ5MnECQ1u5W3Eu3SHIFzsCNsIJhNuAerLFFX2meOznrzakhbYLeud4w-VLti98PE31EWWZzoUhzkOIbC33FXewjzgVqYtg_Ck7Vm3bwUdokxRirTB4k2BpXWguxnxX-lYTDxzru2uje2PH916t1OoouM9UwZsojxWb6mhih64x5IUtT9zLoaW9SsMHTJFNA6EL79mxFlL6eGS=w1102-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/WUU2c4swQ4ZvQmF5wPD0LMr8s45NHkwz1zSucfPErZRUl7t5rNqdTFgutHxke-2hmVjCXHjXjCrI2nsd3vCHXE_cnoz_fCehAxLsJPneB1YOFk5l0ITwbj9qUxO6T8A8CY7M0xLRCVPCGmdWBwRraJFsk9-wZeKvBWcI0Ly3BX5kpYuARncIr5SBm1Va52GxZrYRCxaTXAk1hajlBiHQt3H0AnahOP_ET5lXQ5XRac23as0XRJG6d3U7lYjSrp1E_yJ36lF9gM3YJQKj0VMY_QweB2wqsOWReoa7pIqCU2YrvWrcw-jWPia3N5vCH6TjtH2m8pwGck5VupIhJriqxlCTbtclgPKYk9cMwvO6cqqZuWhVUeuNzidH2NV-kRMYyhROyBSDvDwybPko4UKKWWMOiAzGG3UmAFDa7SoUUociDbMA8iBbtDqF0dDGFbRZcYPcaVJExQZzdLgoC1MT82eX7ntMot0mf5EHrKMQyV4M-GBFmpQZlNrcE-Tiqn8fW7uUZpQYyvt6yoiGELhiKOO6X9lbO0iNbxDyfTaXhtMvNNJ-qpiLOiKsH_13We8E-cpzv1Qk38dqpKQ6vpTL0v51kVfOYCggIGJ8Z8UaDes5rqWhVphvslVX8b0PA1ayz4OgmFoa2uSFzVfRC_ybfvKaEmmSJgdb=w1102-h1468-no" alt></p><p>终于找到了</p><p><img src="https://lh3.googleusercontent.com/MINvBAvtHezmTtiM3z_63G1N9pkIraiCAiO3A3dRPWHcutrJnOgaaS1zSciNktD-FmFQTuWfDlWEjKIfZicAPyxp9Roq5ldVED67ON5BWkvkfbsOE-cbYuBYluvHcRv6ApE-Lywi9p_GqaVxx-gWQcRPJB3AjbO7-LGXsW4dJ1073Vrf3uJH42-DzwFExKh8F2_X0oR2uXMI1xaKNKAvon8OSnPyGLJ2Nq7CFwlmIYRj7QrVbGexY7JXm3NsxoZS8cdOJwljtT7Oalbxw8fvVbVAbAvQmKgHXAgA5aUFHv1zF3alz4OlyUyh2nvYO1eUTFs72Ihfzbwc0DGmEOAhGw8gOB_emIpv0kmxcdetukhmUVAQgdgvHV6p5jM2P_8RCvctzYY1kWBy-QzEJVOzIpHTz4IMsGfUVXCJSi-posKDyEG4Nh8yD9Zmwv-osHJyVcsadhLWbwB_m2BovwK2oOsKk1OHi_75aNm9RdpWU4xBCaU0UBXwOoTELYCM5mnzS8NtebGrVbxDh3tFyfHgi0t44ye2YTRAZ7_4RaF_vzQuC-8OrMGf3LXMSI3sTfbf76bSfuZ28H3HlkRV4g22ZlNOMpLhzF43McdTtT8vfsx_oep-1OwIcRvMH7fEy1megZhfBo3HFkDoJR95bs7_0Cc2cw4nKyMD=w1958-h1468-no" alt></p><p>住的地方（好小啊，不过，五脏俱全）</p><p><img src="https://lh3.googleusercontent.com/mjKTtvOExCg9ZfFqvEomqxVIEVnQIsHBmasjKQcF9YozJkbO2CA9C1orwcW3Ff9HGMGV7SRQohXAwac8HhVVYHzgzbF9Ut-6RhwpiV40xe9gs9PiTr5HQWX0vEvwg4yT2p6Tz8SfKFmT0vvmqjaxsUOqAhSXDQ9m5FsMIkXYqDR-0YnlyLEUVNT_ZkJG4wKXR_WZcfPdX5xnob9am3uO3c1VcFMP-qj4Rh7y0JjNgcUCC6JGFF7qJwC9ePZYyFTl7Ri38-ypuWGDqRDhb8Broz-B3xZw7sU0o6xm9LTa-4ZYne-LG3ZLm7XjZAbqHljhpcJwCXvE4JRs_t-IoCTL6aS9v6NAZMzYW9Ui28OH1nuuIoBuCEWgs_wtDrFPEjInqIE1HgeZuRNaqtGGzwCsJBP6gLL6cGJ3w89cYP86dlU5oBq69CrJjJX0IMDxHTRmqAZljud51eKbSEa3IGDDuBtBa6D4UCvWRdtlodopUoZLlvXrX70wPd7NOCc4xjqZeCmXXMF6nFjUK7a2MJ9mrDCdvR5tl5H39gimBcKeRTBjf60YSxAPxnTzYNo6oNTsW0InI58tXlRW9AM4KtqPpPqBxH6Ho7j9sw4htS-oFSURY_eOTfZwGDO0ixrbkkzs-qaf2u1dKq8cBcl1CRiCT5KItk8yn2cX=w1958-h1468-no" alt></p><p>晚上9点到民宿，还没吃饭，就下去附近逛逛觅食，诶，找到一家</p><p><img src="https://lh3.googleusercontent.com/gMTOkVkgq5F_BSdIdYhd_L0qpm-veNokAJcx_suRxaO5YTWZm6SIpJv1R74DKJvKsis01Y3bTj6Z3MR4LfYqUeqyO98KkX-nU2PAWzXfHp4SniyW8o6l_pZiu4bBuVWVJDMl3SxTfRJTCshpwkoKlIViWySQhnc4H4bxuCAssNoopwDSC4FSTNkFZYOZm2U_cufmJLEGiAFBKcn0zuXhkRtNi_jG59UlMkmMzSSAIqqLraCLiT7RMzQ5QXVirZcqo4Yutvx5dF092cKpO6jHb2ih1Kqv95n5D1vbDis1mFFg7E1Obt9xo18wxNKGP7l9eKHv1KsEHOs01qpTo4Ft35Pry1PKeIoJADfNhP_3EO71UuXnmaO6J4ajMDhllkOuBV7Ubk6Q2WkImtjgt7TpTt86XPLgyTkCYTzjrhvH1Mnx_pJneAePa93d6KWkq-tzqTmirzcdRbOwKVTYLGPKfipb3aMr5VWFffS2SfqGQkZiR0dR23yvgnq6OXrtjO-h1GAdbrbUNIDR2GD0j8OkiN1a7I4ANiHOwNbZrAy-XoqW4M86qoAUb0Q6snS389Hu1XW-3g95Xo99lGzZ8iZCCpxOYzlD2PAWlyhMQR1I7kCpADs_XfzJ0CHQqFRJvmtXpi8iXBngLjh0XP4i30NIQq67DHmTjUqj=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/Vu2V-2vHx871RSKC47xuUildzomhw6eHR9N1LwweuCfleuxbfvkLw01jEPtSeKkoEWz4nhMFMN1XN7zG2eOHPXFbwcuaqkGDzroSpdoVZ31ZyYDIHqvwcub3srPrFvnt4yd9CSyzxDzkZCl8v9XR12maxpX851Ppy0ATqcyjP6fzuSjaBpNrjne4v338z8hMKiCwEa9jbj0Vh8QNEnuFtfBB_9NIZmeMCpZ1IptOsU3PFJvsnDJ9uiNRDgYcayC01q3bWJsmQEIB3IFgy0ah7r8xjks4BMTr0uaNIw0zAKM4tN7Se12EpRtwsU9Q_gNW6340iW8tk5Pu1RQX3dxN7Tv4IdG2wka4yP-Q2cx9vCx6n-hNQU5BnHKWugznkOpJrK8KGTAT5W4-LrgLYP4aIvGWd53iM7hukQr2UgJenwfse50oOqMf6hlp0jvhu7C9IAYuUk7S4SwU9kI3KUeIHbXtNk3xa2MnDhog-ZvR_A_ZbmL6DhyCcXm8gNg-LICUvmKHgaQf1VtYzYXd6qM-p5V5QEp2ryJUzJNgM_9TKgAKHRf_0FCLlfBIr5azKDA1Dh77jgYiLcF0HSxkcjFKYEtwN6K0rYsE6gXbY_fkDXTBdBIBK_PRHO-ob_jcCQSRBkZGYFPGYSx0VRyeuvBni1-UexMm-Dm7=w1920-h1080-no" alt></p><p>图太多了，后面再讲吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;行程（2019-06-01）&quot;&gt;&lt;a href=&quot;#行程（2019-06-01）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-01）&quot;&gt;&lt;/a&gt;行程（2019-06-01）&lt;/h1&gt;&lt;p&gt;此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>熵</title>
    <link href="http://yoursite.com/2019/04/28/%E7%86%B5/"/>
    <id>http://yoursite.com/2019/04/28/熵/</id>
    <published>2019-04-27T16:12:34.182Z</published>
    <updated>2019-04-27T16:33:27.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是熵"><a href="#什么是熵" class="headerlink" title="什么是熵"></a>什么是熵</h1><p>为了理解熵，必须讲一点物理学。</p><p>19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。<strong>他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。</strong></p><p>后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。</p><a id="more"></a><h1 id="能量的状态"><a href="#能量的状态" class="headerlink" title="能量的状态"></a>能量的状态</h1><p>熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnesha9rj30cs078whz.jpg" alt></p><p>物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。</p><p>上图中，能量转化会新生成大量的状态，那么状态多意味着什么呢？</p><h1 id="熵的另外一种解释"><a href="#熵的另外一种解释" class="headerlink" title="熵的另外一种解释"></a>熵的另外一种解释</h1><p>状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：<strong>能量转换会让系统的混乱度增加，熵就是系统的混乱度。</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g2hnhmgjbwj30hg07m754.jpg" alt></p><p>熵的英文名为Entropy，我觉得这个翻译的人（胡刚复教授于1923年根据热温商之意首次把entropie译为“熵”）确实很牛逼，翻译的名字很好听。熵低则混乱度低，熵高则混乱度高。</p><p>转换的能量越大，创造出来的新状态就会越多，因此高能量系统不如低能量系统稳定，因为前者的熵较大。而且，<strong>凡是运动的系统都会有能量转换</strong>，热力学第二定律就是在说，<strong>所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。</strong></p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnk9koktj30e8041glh.jpg" alt></p><p>冰块是分子的有序排列，能量释放后，变成液体水，分子排列变得无序。那么冰这个系统里的熵就比较低，而水这个系统的熵比较高。</p><h1 id="熵：一种新的世界观"><a href="#熵：一种新的世界观" class="headerlink" title="熵：一种新的世界观"></a>熵：一种新的世界观</h1><p>熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。为什么”世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。</p><p>这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。</p><p>工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。</p><p>我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。我们需要能量，让世界变得有秩序，但这样是有代价的。<strong>物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。</strong></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。（能量守恒定律告诉我们地球的能量肯定是固定的，那么当人类能利用完地球上所有的能量（不一定能利用完），而假设没有外部能量输入，则这个时候的熵如果大到一定程度是不是就是人类悲剧的开始，比如核弹，病毒等。另外一种可能，为了一部分地区的有序和稳定，牺牲了另外一部分地区的有序和生态，而目前好像就是如此，人类破坏了其它生物的家园而将自己的家园建设的越来越好）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是熵&quot;&gt;&lt;a href=&quot;#什么是熵&quot; class=&quot;headerlink&quot; title=&quot;什么是熵&quot;&gt;&lt;/a&gt;什么是熵&lt;/h1&gt;&lt;p&gt;为了理解熵，必须讲一点物理学。&lt;/p&gt;
&lt;p&gt;19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。&lt;strong&gt;他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="热力学第二定律" scheme="http://yoursite.com/tags/%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之集合操作符</title>
    <link href="http://yoursite.com/2019/03/28/Kotlin%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/28/Kotlin之集合操作符/</id>
    <published>2019-03-28T03:10:02.000Z</published>
    <updated>2019-12-19T05:57:50.299Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。</p><a id="more"></a><h2 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h2><p>Kotlin中允许你去将表达式当作参数传递，你也可以直接传递函数，跟Java8一样，如果你把函数转化为一个值的话，可以用成员引用</p><p><code>val getAge = Person::age</code></p><p>这个表达式叫做 成员引用 。它为创建一个直接调用方法或访问属性的函数值提供了一种简短的语法。双冒号将类名从你需要引用的成员（方法或属性）名中分隔出来。它所做的事情跟下面其实是一样的，但是更简洁（少了一个中间变量）：</p><p><code>val getAge = { person: Person -&gt; person.age }</code></p><p>这个成员引用是lambda中的知识点，还有很多用法，需要去理解。</p><h2 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h2><p>找出这个集合中根据某个字段排序最大的值，可以仔细观察下面代码，它们的结果和意思完全一样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之maxby</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorMaxBy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当lambda表达式是最后一个参数的时候可以不要（），直接用&#123;&#125;</span></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>))</span><br><span class="line">    println(people.maxBy &#123; it.age &#125;)</span><br><span class="line">    println(people.maxBy &#123; person2 -&gt; person2.age &#125;)</span><br><span class="line">    people.maxBy(Person2::age)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transform-joinString"><a href="#transform-joinString" class="headerlink" title="transform/joinString"></a>transform/joinString</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之transform/joinToString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorTransform</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> names = people.joinToString(separator = <span class="string">"，"</span>,postfix = <span class="string">": "</span>,transform = &#123;p: Person2 -&gt;  p.name&#125;)</span><br><span class="line">    <span class="keyword">val</span> names1 = people.joinToString(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="number">1</span>) &#123; p -&gt; p.name &#125;</span><br><span class="line">    println(names)  <span class="comment">//Bob，Alice:</span></span><br><span class="line">    println(names1) <span class="comment">//Bob</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>根据条件过滤操作<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是要注意，这份代码为每个人重复了最大年龄的查找步骤。所以，如果集合中有100个人，最大年龄的搜索将会执行100次！</span></span><br><span class="line">    people.filter &#123; it.age == people.maxBy(Person2::age)!!.age &#125;</span><br><span class="line">    <span class="comment">//people.filter &#123; it.age == people.maxBy&#123;person2 -&gt;  person2.age&#125;!!.age &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只计算了一次最大值</span></span><br><span class="line">    <span class="keyword">var</span> maxAge = people.maxBy(Person2::age)?.age</span><br><span class="line">    people.filter &#123; it.age == maxAge &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="all，any，count，find等"><a href="#all，any，count，find等" class="headerlink" title="all，any，count，find等"></a>all，any，count，find等</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * list操作符all，any</span></span><br><span class="line"><span class="comment"> * list是否包含了所有这个条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorAllAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conditions = &#123;p: Person2 -&gt; p.age &gt; <span class="number">25</span>&#125;</span><br><span class="line">    <span class="comment">//全部匹配条件</span></span><br><span class="line">    people.all(conditions) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    people.all &#123; p:Person2 -&gt; p.age &gt; <span class="number">23</span> &#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个匹配条件的</span></span><br><span class="line">    people.any(conditions) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有多少个符合条件的</span></span><br><span class="line">    people.count(conditions) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找哪个是符合条件的(如果有多个元素，函数将返回第一个匹配的元素。</span></span><br><span class="line">    <span class="comment">// 如果没有满足的元素，函数返回 null 。 find 的一个同义词是 firstOrNull 。</span></span><br><span class="line">    <span class="comment">// 如果如能够更加清晰的表达你对想法，你可以使用)</span></span><br><span class="line">    people.find &#123; p:Person2 -&gt; p.age &gt; <span class="number">23</span> &#125; <span class="comment">//Alice,Ervin</span></span><br><span class="line">    people.firstOrNull(conditions)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>分组操作符，想象一下，你需要根据你某些特性来将所有元素分割成不同的组。例如，你想把年龄相同的人放在一组。把这个特性直接作为一个参数进行传递非常方便！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符groupBy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorGroupBy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>),</span><br><span class="line">        Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),</span><br><span class="line">        Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>),</span><br><span class="line">        Person2(<span class="string">"Anny"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    people.groupBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一组都被保存成一个列表。所以结果的类型为 Map&lt;Int, List&lt;Person&gt;&gt; 。</span></span><br><span class="line">    <span class="comment">// 你可以使用像 mapKeys 和 mapValues 这样的函数对这个映射做更多的修改。</span></span><br><span class="line">    print(people.groupBy &#123; it.age &#125;[<span class="number">34</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>groupBy之后返回结果是一个Map集合，最后<code>print(people.groupBy { it.age }[34])</code>中[34]其实是输出以34为key的Person。</p><h2 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h2><p>这两个操作符在RxJava中是使用频率很高的操作符，map是对一个基本类型做一个转换，例如string -&gt; int，而flagMap则是将上游的observerable变为另外一个observerable。Kotlin中，map其实也是类型转换的意思，flatmap则是将集合中每个元素映射（map），然后把多个列表合并成一个。最终，其实它是一个集合</p><p>flatMap 函数做了两件事：首先它根据作为参数而给定的函数把每一个元素都变换（或映射）到一个集合中。然后它把多个列表合并为一个。有一个处理字符串的案例很好的解析了这个概念<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g1k0wgeommj30ig0act9c.jpg" alt></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符flatMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line">    print(people.map &#123; it.name + <span class="string">"'s"</span> &#125;) <span class="comment">//[Bob's, Alice's, Ervin's]</span></span><br><span class="line">    print(people.flatMap &#123; it.name.toList() &#125;) <span class="comment">//[B, o, b, A, l, i, c, e, E, r, v, i, n]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h2><ul><li>集合的序列操作，这个是很有用的东西。一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择，举个例子：<blockquote><p>NOTE 注意 一般来说，无论何时，你在大型集合中有链式操作时，请使用序列。在8.2一节，我们将会讨论为什么在Kotlin中，常规集合的延迟操作是高效的，尽管它会创建中间的集合。但是如果集合包含大量的元素，中间的元素重拍耗时巨大，所以延迟计算更 加可取。</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list的序列操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的链式调用</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Kotlin标准库参考（文档）指出， filter 和 map 都返回一个列表。这意味着这个链式调用将会创建两个列表：一个保存 filter 函数的结果，另一个存储 map 函数的结果。</span></span><br><span class="line"><span class="comment">     * 当原来的列表只有包含两个元素时，这不会有问题。但是如果你有百万个元素时，这会变得非常低效。 为了把它变得更加高效，你可以转换这个操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    people.map(Person2::name).filter &#123; it.contains(<span class="string">'A'</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列的操作</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有保存元素的中间集合，对于元素比较大的集合来说，性能会有客观的改善</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    people.asSequence()                    <span class="comment">//初始集合转化为序列</span></span><br><span class="line">        .map(Person2::name)</span><br><span class="line">        .filter &#123; it.contains(<span class="string">'A'</span>) &#125;</span><br><span class="line">        .toList()                          <span class="comment">//序列转化为集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合本身的操作是实时的，而序列的操作是懒加载式的，下面会详细说明序列的中间操作和最终操作</p><ul><li>序列的中间和最终操作</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1k0xt8zioj30ty06c0tu.jpg" alt></p><p>看一个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list的序列操作之不同点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sequence的操作</span></span><br><span class="line">    <span class="comment">//map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</span></span><br><span class="line">    listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; print( <span class="string">"map(<span class="variable">$it</span>) "</span> ); it * it &#125;</span><br><span class="line">        .filter &#123; print( <span class="string">"filter(<span class="variable">$it</span>) "</span> ); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">        .toList()<span class="comment">//最终操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合本身操作</span></span><br><span class="line">    <span class="comment">//map(1) map(2) map(3) map(4) filter(1) filter(4) filter(9) filter(16)</span></span><br><span class="line">    listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .map &#123; print( <span class="string">"map(<span class="variable">$it</span>) "</span> ); it * it &#125;</span><br><span class="line">        .filter &#123; print( <span class="string">"filter(<span class="variable">$it</span>) "</span> ); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意看sequence结果：map和filter是交替进行的，每个元素都是先map再filter，这证明了sequence是延迟计算的。而集合本身则是所有元素先map（中间集合），再用中间集合去filter。<strong>sequence中没有最后的toList（最终操作），则什么都不会输出。</strong></p></blockquote><p>最终操作导致所有的延迟计算都被执行了。 还有一个更重要的事要注意，在这个例子中，计算的执行顺序。原始的方法首先将会对每个元素调用 map 函数，然后对结果序列中的每个元素调用 filter 函数。这就是 map 和 filter 在集合上如何工作的。但序列并不是这样的。对于序列来说，所有的操作都会逐个应用于每个元素：处理完第一个元素（映射，然后过滤），然后处理第二个，以此类推。 这个方法意味着如果过早获取结果，某些元素根本不会被变换。我们来看一个有 map 和 find 操作的例子。首先，你把一个数映射为它的平方，之后你查找当中<strong>第一个大于３的元素</strong>（find操作符的作用）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    print(listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; <span class="number">3</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同样的操作应用于一个集合而不是序列，那么首先会计算 map 的结果，变换初始集合中所有的元素。第二步，在中间集合中发现一个满足预言的元素。使用序列，惰性方法意味着你可以提阿偶偶处理某些元素。下图解释了（使用集合）提前和延迟（使用序列）方式执行这份代码的不同点。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g1k107da1kj30uw0bsq56.jpg" alt></p><p>集合提前计算对整个集合运行每一个操作，惰性求值则逐个计算（元素多的时候效率高，性能好）</p><p>再看一个例子啊：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    println(listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; <span class="number">3</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>),</span><br><span class="line">        Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),</span><br><span class="line">        Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>),</span><br><span class="line">        Person2(<span class="string">"Dan"</span>,<span class="number">34</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先filter有助于减少变换的总次数，</span></span><br><span class="line"><span class="comment">     * 如果先进行 map ，每个元素都会进行变换。</span></span><br><span class="line"><span class="comment">     * 但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//先map再过滤</span></span><br><span class="line">    println(people.asSequence().map(Person2::name).filter&#123; it.length &lt; <span class="number">4</span>&#125;.toList())</span><br><span class="line">    <span class="comment">//println(people.asSequence().map&#123; person: Person2 -&gt; person.name&#125;.filter &#123; it.length &lt; 4 &#125;.toList())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先过滤再映射</span></span><br><span class="line">    println(people.asSequence().filter&#123;it.name.length &lt; <span class="number">4</span>&#125;.map(Person2::name).toList())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1k115spoaj30ta09ugng.jpg" alt></p><p>先filter有助于减少变换的总次数。如果先进行 map ，每个元素都会进行变换。但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</p><blockquote><p>流 vs 序列 如果你熟悉Java 8的流，你将会看到，（Kotlin的）序列是完全一样的概念。由于Java 8的流在使用旧版本的Java搭建的平台中无法使用，比如Android，所以Kotlin提供了它自己的轮子。如果你把Java 8作为目标平台，流会给你带来一个很大的好处。但是，Kotlin的集合与序列并未实现在多个CPU上并行执行流操作（ map() 或者 filter() ）的能力。你可以基于你面向的Java版本和你的具体要求来选择流和序列。</p></blockquote><p><a href="https://github.com/ervinsae/KotlinLesson" target="_blank" rel="noopener">实例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
