<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-03-16T14:31:03.728Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杂记</title>
    <link href="http://yoursite.com/2023/03/16/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2023/03/16/一些感想/</id>
    <published>2023-03-15T16:00:00.000Z</published>
    <updated>2023-03-16T14:31:03.728Z</updated>
    
    <content type="html"><![CDATA[<p>一天中最幸运的事情：</p><ol><li>碰到一首可以单曲循环的歌</li><li>解决了一个难题</li><li>突然冒出一个令自己兴奋的想法，想立马去实施</li><li>完成了一项让自己满意的工作</li><li>消除了和另一个在意的人之间的矛盾</li><li>1，2，3，4，5都来一遍</li><li>。。。</li></ol><p>天下无不散的宴席。人生是一场旅途，有人同行是一种缘分，珍惜同行时光，等到分别之时，挥手告别，微笑离开。</p><p>成年人能够依赖的只有自己，能够救自己的也只有自己。</p><p>永远不要去试探人性，人性通常都禁不起推敲。</p><p>不作恶，保持善良。</p><p>不以物喜，不以己悲。平静对待赞赏，坦然接受批评。持续反思，保持好奇心，多琢磨，多折腾。</p><p>AI的可怕之处在于，他永远在反思，在对未知事物保持敬畏。他的回答已经很完美了，最后还会来一句他有局限性。相比而言，作为人类认知不及AI万分之一，还经常飘。人类和AI共存的日子马上就要来临了。</p><p>美好的东西，站在远处观赏就好。靠的太近也许是另一番景象。</p><p>剖析自己，找到自己的缺点，就算改不掉也要时刻提醒自己。</p><p>不要看他说什么，看他做什么，他做什么代表他相信什么。</p><p>每个人只相信自己相信的东西。</p><p>多元的信息输入源很重要，信息茧房的产生其实就是常年接受一种信息源，不断强化你的既有认知。特别是目前的社交网络，信息流很多都是同质化，信息量密度低的内容，接触多了之后会让你不愿意或者没有耐心去思考稍微复杂的问题，让人变得无知且固执。</p><p>顿悟是什么感觉？王阳明砍竹子和牛顿被苹果砸都让他们顿悟了，外界的扰动触发了内心认知的一次升级。</p><p>命运和人定胜天可能是人生的两个不同纬度，后天的努力通过因果关系可以改变命运。</p><p>出了问题，有时候向内去找答案比向外求助更有用。</p><p>越来越相信平行宇宙的理论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一天中最幸运的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;碰到一首可以单曲循环的歌&lt;/li&gt;
&lt;li&gt;解决了一个难题&lt;/li&gt;
&lt;li&gt;突然冒出一个令自己兴奋的想法，想立马去实施&lt;/li&gt;
&lt;li&gt;完成了一项让自己满意的工作&lt;/li&gt;
&lt;li&gt;消除了和另一个在意的人之间的矛盾&lt;/li
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>深度学习之环境搭建</title>
    <link href="http://yoursite.com/2023/03/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2023/03/10/深度学习之环境搭建/</id>
    <published>2023-03-09T16:00:00.000Z</published>
    <updated>2023-03-13T09:49:48.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队内部要做一些分享，最近ChatGPT正火，而且正好也在研究深度学习在移动设备上的相关东西，所以就想就深度学习这个方向去沉淀一些东西供参考。</p><p>深度学习目前是两大框架，神仙打架。Google的Tensorflow和Meta的Pytorch，本文基于Tensorflow来讲。由于本人使用的是Mac M1版本，在折腾过程中遇到了很多问题，最终还是解决了。这里做个记录。</p><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Mac自带了python环境，直接安装tensorflow后，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br></pre></td></tr></table></figure></p><p>直接就报错了：illegal hardware instruction python3</p><p>后面发现是由于Tensorflow不支持Arm的cpu架构，需要使用Macos专用的Tensorflow框架，也询问了ChatGPT，最终过程是这样的。</p><ol><li><p>下载基于Arm架构的miniconda<br>下载地址：<a href="https://github.com/conda-forge/miniforge/#download" target="_blank" rel="noopener">https://github.com/conda-forge/miniforge/#download</a></p></li><li><p>输入下面三个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#下载完以后在terminal依次输入以下三个命令</span><br><span class="line"># 授权</span><br><span class="line">chmod +x ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line"># 执行下载的脚本</span><br><span class="line">sh ~/Downloads/Miniforge3-MacOSX-arm64.sh</span><br><span class="line"># 运行脚本</span><br><span class="line">source ~/miniforge3/bin/activate</span><br></pre></td></tr></table></figure></li><li><p>下载conda环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>创建conda虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf python==3.9</span><br><span class="line"></span><br><span class="line">conda activate tf</span><br></pre></td></tr></table></figure></li><li><p>安装tensorflow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pip下载在国内也很慢，很容易网络连接超时，-i https://pypi.tuna.tsinghua.edu.cn/simple能够切换到清华源下载</span><br><span class="line"></span><br><span class="line"># 在终端中依次输入以下三行命令。这三行命令都是下载包，可能速度有点慢，但是切换源之后应该速度很快。</span><br><span class="line"></span><br><span class="line">conda install -c apple tensorflow-deps</span><br><span class="line">python -m pip install tensorflow-macos -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">python -m pip install tensorflow-metal -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>查看是否有效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure></li></ol><p>如果能打印出版本号证明环境安装OK了，这时候会在tf这个虚拟环境中运行tensorflow</p><h2 id="在pycharm中使用刚刚配置的环境"><a href="#在pycharm中使用刚刚配置的环境" class="headerlink" title="在pycharm中使用刚刚配置的环境"></a>在pycharm中使用刚刚配置的环境</h2><p>pycharm是专用来开发python的，刚刚我们本地创建了一个可以运行tf的环境（interpreter）,我们如果想在pycharm里面去使用刚刚的环境，需要做一些配置，按照如果配置：</p><p><img src="https://s1.locimg.com/2023/03/13/444985288b1c9.jpg" alt="pycharm配置"></p><p>其中miniforge3就是上面第一步下载后生成的文件夹，里面有conda环境，通过这样配置生成的一个py项目就能使用tf的运行项目了</p><p><img src="https://s1.locimg.com/2023/03/13/dc1beddc79377.jpg" alt="效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;团队内部要做一些分享，最近ChatGPT正火，而且正好也在研究深度学习在移动设备上的相关东西，所以就想就深度学习这个方向去沉淀一些东西供参考。&lt;/p&gt;
&lt;p&gt;深度学习目前是两大框架，神仙打架。Google的Tensorflow和Meta的Pytorch，本文基于Tensorflow来讲。由于本人使用的是Mac M1版本，在折腾过程中遇到了很多问题，最终还是解决了。这里做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mmap的简单原理解析</title>
    <link href="http://yoursite.com/2023/02/07/mmap%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2023/02/07/mmap的简单原理/</id>
    <published>2023-02-06T16:00:00.000Z</published>
    <updated>2023-02-07T07:18:20.456Z</updated>
    
    <content type="html"><![CDATA[<p>mmap很早就知道一些，但是只是简单知道这个可以减少内存消耗，并不知道它的实现原理是怎么样的，所以也不知道它到底是怎么去减少内存消耗的，然后找了相关资料看了下，发现和android的bundle机制还有点相似，这里做个记录和总结</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>我们都知道linux进程分为<strong>用户空间</strong>和<strong>内核空间</strong>，后来在零拷贝原理中知道对于32位操作系统来说系统会给每个应用进程分配4G的虚拟内存空间，其中0-3G的内存地址属于用户空间，3-4G的内存地址属于内核空间。其中用户空间是不能共享的，而内核空间是运行操作系统的，它独立于普通的应用程序，是被所有应用程序共享的。所以对一个应用来说，只有3G的用户空间是属于应用本身的。参考：<a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">内核空间与用户空间</a>。由于用户空间是隔离的，所以这里当一个进程想访问另外一个进程的用户数据时就涉及到进程之间的通讯了（RPC），Android使用bundle来更好的解决这个问题，后面单独写Android的bundle机制。</p><a id="more"></a><h2 id="mmap是什么"><a href="#mmap是什么" class="headerlink" title="mmap是什么"></a>mmap是什么</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。</p><p>实现了这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写改动过的页面到对应的文件磁盘上，即完成了对文件的操作而不必要再调用read，write等系统函数。相反，内核空间对这段区域的修改也直接反映用户空间（因为内核空间被所有进程公用），从而实现不同进程间的 文件共享。</p><h2 id="mmap的简单原理"><a href="#mmap的简单原理" class="headerlink" title="mmap的简单原理"></a>mmap的简单原理</h2><h3 id="传统的读写文件"><a href="#传统的读写文件" class="headerlink" title="传统的读写文件"></a>传统的读写文件</h3><p>一般来说，修改一个文件需要三个步骤</p><ul><li>把文件内容读入到内存中</li><li>修改内存中的内容</li><li>把内存的数据写入到文件中</li></ul><p>过程如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b5d56c88f4b49ddba0ed1b014928a49~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>从上图可以看到磁盘中的文件file要被用户修改的时候，需要先把file文件拷贝到<strong>页缓存（page cache）</strong>中，然后通过系统函数read读到用户空间的临时buffer中（copy），修改之后，再通过write方法（copy）写回页缓存中，最终改变了磁盘中的file的文件。其中，页缓存是读写文件的中间层，内核使用页缓存与文件的数据块（连续的内存地址）关联起来。所以应用程序读写文件时，实际操作的是页缓存。这里为了实现文件修改在内存中是做了两次copy的。</p><h3 id="使用mmap读写文件"><a href="#使用mmap读写文件" class="headerlink" title="使用mmap读写文件"></a>使用mmap读写文件</h3><p>从上面读写文件的过程中，我们可以看到有一个地方是可以优化的：如果可以直接在用户空间操作（读写）页缓存，那么久可以免去页缓存的数据复制到用户空间的临时buffer的过程。mmap其实就是做这个事情的。</p><p>使用mmap系统调用可以将用户空间的虚拟内存地址与文件进行映射（怎么做到的？），对映射的虚拟内存地址就行读写操作就如同对文件进行读写操作一下，如图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a55af52d3042c79613feb41fc662d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>mmap最终是调用了sendfile方法来实现映射关系的（具体怎么做到将用户空间的内存和页缓存做映射的，可以看这篇文章：<a href="https://developer.aliyun.com/article/375144" target="_blank" rel="noopener">认证分析mmap</a>，这里不深入写，只要知道mmap的第一层原理，它减少了将内核空间往用户空间拷贝的动作，所以性能会很好。）</p><p>由于读写文件都需要经过页缓存，所以mmap映射的正是文件的页缓存，而非磁盘中的文件本身。由于mmap映射的是文件的页缓存，所以就涉及到同步的问题：页缓存上面时候把数据同步到磁盘？linux内核并不会主动把mmap映射的页缓存同步到磁盘，而是需要用户主动触发。同步mmap映射的内存到磁盘有4个时机：</p><ul><li>调用msync函数主动进行数据同步（主动）</li><li>调用munmap函数对文件进行解除映射关系时（主动）</li><li>进程推出时（被动）</li><li>系统关机时（被动）</li></ul><p>mmap 函数会返回映射后的内存地址，我们可以通过此内存地址对文件进行读写操作。如图<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b59dc54fc6fc42a294e3cf1defc1a3b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mmap很早就知道一些，但是只是简单知道这个可以减少内存消耗，并不知道它的实现原理是怎么样的，所以也不知道它到底是怎么去减少内存消耗的，然后找了相关资料看了下，发现和android的bundle机制还有点相似，这里做个记录和总结&lt;/p&gt;
&lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;p&gt;我们都知道linux进程分为&lt;strong&gt;用户空间&lt;/strong&gt;和&lt;strong&gt;内核空间&lt;/strong&gt;，后来在零拷贝原理中知道对于32位操作系统来说系统会给每个应用进程分配4G的虚拟内存空间，其中0-3G的内存地址属于用户空间，3-4G的内存地址属于内核空间。其中用户空间是不能共享的，而内核空间是运行操作系统的，它独立于普通的应用程序，是被所有应用程序共享的。所以对一个应用来说，只有3G的用户空间是属于应用本身的。参考：&lt;a href=&quot;https://www.cnblogs.com/sparkdev/p/8410350.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核空间与用户空间&lt;/a&gt;。由于用户空间是隔离的，所以这里当一个进程想访问另外一个进程的用户数据时就涉及到进程之间的通讯了（RPC），Android使用bundle来更好的解决这个问题，后面单独写Android的bundle机制。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>随想（一）</title>
    <link href="http://yoursite.com/2023/01/18/%E9%9A%8F%E6%83%B3/"/>
    <id>http://yoursite.com/2023/01/18/随想/</id>
    <published>2023-01-17T16:00:00.000Z</published>
    <updated>2023-01-18T03:42:39.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.</strong> 最近在学习一些管理方面的知识，从思想层面对管理者有了新的认识。执行者和管理者的思维模式是完全不一样的，而大部分走上管理岗位的又往往是那些业务骨干，业务骨干其实就是优秀的执行者，能够很完美的完成领导交付的任务，他们也是领导重点考察和培养的对象。但是，由于执行者和管理者存在的最大不同点在于：思维模式，所以刚进入到管理岗位的执行者会很不适应，有很强的执行者思维惯性。这个时候如果有人可以点拨你，或者自己学习是可以少走很多弯路的。那么，执行者和管理者思维的区别是什么呢？</p><ul><li>执行者：依靠自己，索取资源，局部最优，靠自己的个人能力达成个人目标</li><li>执行者：教练他人，整合资源，全局最优，依靠团队（他人）的能力来达成团队目标</li></ul><p>这里本质不同的是一个是依靠单打独斗达成目标，一个是带领团队依靠别人优秀的能力来达成目标。</p><p><strong>2.</strong> 人际交往的本质其实是价值交换。这个价值可以是有形的也可能是无形的，比如权利，钱，能力或者品质等。你能融入某个圈子说明你具备了这个圈子需要的价值，反之，你融入不了某个圈子就证明你缺少某些价值。人际交往建立后其实就是信任的问题，信任是一个很抽象的概念，这里有个公式可以把信任拆解成几个纬度，让抽象的信任可以被稍微具象化一些：</p><blockquote><p>信任 = （专业性 + 可靠性 + 同频性）/ 自我意识</p></blockquote><p>这里专业性和可靠性都好理解，同频性是指你们具有相似的思维方式，爱好，信仰之类的东西；而自我意识则是你的主观意识存在。这里我认为比较重要的是自我意识，当自我意识很小，信任就可以无限大；当自我意识很大，信任就可以无限小。这里的自我意识其实是说你的思想认识，价值观，看问题视角，认知，感受，调整等。自我意识小，说明你会依附权威，不太会提出反对意见或者都没有反对的意识，这时候你会无限信任比你强的人所提出的观点。那是不是自我意识强就好呢，我觉得也不是，自我意识强是要建立在知识，能力，情感，判断，地位等等具有充足储备的前提下，是需要强大的能力来保障的，盲目的自我意识强是毫无意义的。所以，<strong>信任其实就是在合理自我意识下的价值交换</strong>。合理自我意识还隐藏一个重要的点就是平等，平等的关系才会带来合理的自我意识（自我意识是可以被自我去调整的），信任才有可能被达成，否则我为什么要降低我的自我意识来和你交换？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 最近在学习一些管理方面的知识，从思想层面对管理者有了新的认识。执行者和管理者的思维模式是完全不一样的，而大部分走上管理岗位的又往往是那些业务骨干，业务骨干其实就是优秀的执行者，能够很完美的完成领导交付的任务，他们也是领导重点考察和培养
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>视频编码基础</title>
    <link href="http://yoursite.com/2022/11/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/11/01/视频编码基础/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-03-20T09:51:03.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频传输基本原理"><a href="#视频传输基本原理" class="headerlink" title="视频传输基本原理"></a>视频传输基本原理</h1><p>视频是利用人眼的视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说很不友好。为了能够使视频便于传输和存储，人们发现有视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端回复回来，这样就大大减少了视频数据的文件，因此有了H.264视频压缩标准。</p><p>视频里面最常用的编码格式就说H.264，基于这个编码格式还有H.265（后续研究），音频采样数据会采用AAC编码格式进行压缩。视频内容经过编码压缩后，确实有利于存储和传输。不过当要观看播放视频时，相应也需要解码过程，将压缩的视频还原。所以，编解码之间显然需要约定一种协议，这种协议大概的流程是：<strong>编码器将多张图像进行编码后产生一段一段的GOP（Group of picture），解码器则在播放时读取一段一段的GOP进行解码后读取画面再渲染显示。</strong></p><p><img src="https://s1.locimg.com/2023/03/20/e4f56c4c5d34f.png" alt="1.png"></p><blockquote><p>GOP是一组连续的画面，由一张I帧和数张B帧和P帧组成，它是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。I帧是内部编码帧（也称为关键帧），P帧是前向预测帧（前向参考帧），B帧是双向内插帧（双向参考帧）。简单说，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。如果没有I帧，P和B是无法解码的。</p></blockquote><p><img src="https://s1.locimg.com/2023/03/20/44f418589b027.png" alt="在H.264编码中I帧，P帧，B帧传输的视频画面"></p><a id="more"></a><h1 id="I帧-P帧-B帧"><a href="#I帧-P帧-B帧" class="headerlink" title="I帧,P帧,B帧"></a>I帧,P帧,B帧</h1><ul><li><strong>I帧</strong><br>I帧:即Intra-coded picture（帧内编码图像帧），I帧表示<strong>关键帧</strong>，你可以理解为这一帧画面的完整保留；每个GOP组中第一帧一定是I帧，而且是一种特殊的I帧，也可以称为IDR帧，一个GOP可以有很多I帧，但是只有1个IDR帧。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。<br><img src="https://s1.locimg.com/2023/03/20/0818121e947e7.png" alt="2.png"></li></ul><p><u>I帧的特点：</u></p><ol><li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输</li><li>解码时仅用I帧的数据就可以重构完整的图像</li><li>I帧描述了图像背景和运动主体的详情</li><li>I帧不需要参考其他画面而生成</li><li>I帧是P帧和B帧的参考帧</li><li>I帧所占数据的信息量比较大</li></ol><ul><li><strong>P帧</strong><br>P帧:即Predictive-coded Picture（前向预测编码图像帧）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）<br><img src="https://s1.locimg.com/2023/03/20/212be6bd5232b.png" alt="3.png"></li></ul><p><u>P帧的特点：</u></p><ol><li>P帧是I帧后面相隔1-2帧的编码帧</li><li>P帧采用运动补偿的方法传送它与前面的I或者P帧的差值及运动矢量预测误差</li><li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像</li><li>P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧</li><li>P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧</li><li>由于P帧是参考帧，它可能造成解码错误的扩散</li><li>由于是差值传输，P帧的压缩比较高（大概I帧的一半大小）</li></ol><ul><li><strong>B帧</strong><br>B帧：即Bidirectionally predicted picture（双向预测编码图像帧)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。<br><img src="https://s1.locimg.com/2023/03/20/24ab218973a53.png" alt="4.png"></li></ul><p><u>B帧的特点</u></p><ol><li>B帧是由前面的I或P帧和后面的P帧来进行预测的</li><li>B帧传送的是它与前面的I帧或者P帧和后面的P帧之间的预测误差及运动矢量</li><li>B帧是双向预测编码帧</li><li>B帧压缩比最高，对解码性能要求也高（大概I帧的四分之一）</li><li>需要参考前一个I帧或者P帧及其后面的一个P帧来生成一张完整的视频画面，所以P帧与B帧去掉的是视频帧在时间维度上的冗余信息。</li></ol><p><u>B帧存在的价值</u><br>从上面分析可知，I帧和P帧的解码算法比较简单，资源占用比较少，I只要自己完成就行了，P帧也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果只有I和P，解码器可以不用处理后续数据，边读边解码，那为什么还要引入B帧呢？因为B帧记录了前后帧的差别，<strong>比P帧能节约更多空间</strong>，这样视频文件可以变小，但是相应的就要求解码器性能比较高了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就时说要预读，预解码），而且，B帧不能简单丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的缓慢简单重复，就会造成画面卡顿（丢帧）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;视频传输基本原理&quot;&gt;&lt;a href=&quot;#视频传输基本原理&quot; class=&quot;headerlink&quot; title=&quot;视频传输基本原理&quot;&gt;&lt;/a&gt;视频传输基本原理&lt;/h1&gt;&lt;p&gt;视频是利用人眼的视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说很不友好。为了能够使视频便于传输和存储，人们发现有视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端回复回来，这样就大大减少了视频数据的文件，因此有了H.264视频压缩标准。&lt;/p&gt;
&lt;p&gt;视频里面最常用的编码格式就说H.264，基于这个编码格式还有H.265（后续研究），音频采样数据会采用AAC编码格式进行压缩。视频内容经过编码压缩后，确实有利于存储和传输。不过当要观看播放视频时，相应也需要解码过程，将压缩的视频还原。所以，编解码之间显然需要约定一种协议，这种协议大概的流程是：&lt;strong&gt;编码器将多张图像进行编码后产生一段一段的GOP（Group of picture），解码器则在播放时读取一段一段的GOP进行解码后读取画面再渲染显示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.locimg.com/2023/03/20/e4f56c4c5d34f.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GOP是一组连续的画面，由一张I帧和数张B帧和P帧组成，它是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。I帧是内部编码帧（也称为关键帧），P帧是前向预测帧（前向参考帧），B帧是双向内插帧（双向参考帧）。简单说，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。如果没有I帧，P和B是无法解码的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.locimg.com/2023/03/20/44f418589b027.png&quot; alt=&quot;在H.264编码中I帧，P帧，B帧传输的视频画面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>线程池的一些知识点回顾</title>
    <link href="http://yoursite.com/2022/09/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/10/线程池知识点解析/</id>
    <published>2022-09-09T16:00:00.000Z</published>
    <updated>2022-11-23T07:26:33.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对线程池的一些理解"><a href="#对线程池的一些理解" class="headerlink" title="对线程池的一些理解"></a>对线程池的一些理解</h1><ol><li>线程池是对线程的管理和调度，我们自己当然也可以去新建线程去处理并发操作，但是线程池提供了很好的解决线程之间调度，管理的能力，这些能力可能比我们自己去实现更优。</li><li><p>创建线程池有两种方式（本质上是一种），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Executors封装好的线程池创建方法去创建</span></span><br><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ThreadPoolExecutor来创建，其实上一种本质上也是调用这个来创建线程池的(阿里规范推荐)</span></span><br><span class="line">ExecutorService executors = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">0L</span>,</span><br><span class="line">        TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"><span class="comment">//其中参数1，为核心线程数；2，最大线程数；3，线程存活时间；4，线程的阻塞队列；5，线程（任务）熔断机制</span></span><br></pre></td></tr></table></figure></li><li><p>基于第二点解释这些参数的意义</p></li></ol><ul><li>a, 核心线程数是线程池初始化就会创建的线程，并且该线程不会被回收；</li><li>b, 最大线程数是线程池中允许存在的最大线程数量；</li><li>c, 线程存活时间指的是当非核心线程在处理完任务不再使用后多久被线程池回收；</li><li>d, 线程阻塞队列是任务队列，线程处理的任务会按照队列的特点存在队列中；</li><li>e, 线程熔断机制是当线程处理不过来任务时，应该做一些什么策略。</li></ul><ol start="4"><li>线程池运行的流程</li></ol><ul><li>线程池刚创建的时候，里面没有一个线程，任务队列是做为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个一个任务时，线程池会做几个判断<ul><li>a，如果正在运行的线程数量小于核心线程数，则马上创建线程执行这个任务</li><li>b，如果正在运行的线程数量大于或等于最大线程数，则把任务放入队列中</li><li>c，如果这时候队列满了，运行的线程数小于最大线程数，则创建线程立马执行这个任务</li><li>d，如果队列满了，运行的线程数大于等于最大线程数，则执行线程熔断机制</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程没有任务执行，超过线程存活时间时，线程池会判断，如果当前运行线程大于核心线程数，那么这个线程就会被回收。所以最终线程池的线程数量会维持为核心线程的数量。</li></ul><blockquote><p>这样的过程说明，并不是先加入任务就一定先执行，看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executors = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,</span><br><span class="line">                 <span class="number">6</span>,</span><br><span class="line">                 <span class="number">0L</span>,</span><br><span class="line">                 TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                 <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">         <span class="comment">//ThreadTest01 test01 = new ThreadTest01();</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> taskId = i;</span><br><span class="line">             Runnable task = () -&gt; &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getName() + <span class="string">" is saving data:"</span> + taskId);</span><br><span class="line">                     <span class="comment">/*模拟存储数据耗时*/</span></span><br><span class="line">                     Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">             executors.execute(task);</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="comment">/*运行结果：首先核心线程为3所以立马执行任务1，2，3；然后任务4到13被放入到队列中，14，15，16又会被新创建的3个线程（最大为6）执行，</span></span><br><span class="line"><span class="comment"> 再增加任务17到20时由于当前已经有6个线程在处理任务了，所以17到20的任务由于ThreadPoolExecutor.DiscardPolicy()策略会被丢弃。</span></span><br><span class="line"><span class="comment"> 然后6个线程又会依次从队列冲取出4到13任务去执行。*/</span></span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h1 id="线程池中几种队列的理解"><a href="#线程池中几种队列的理解" class="headerlink" title="线程池中几种队列的理解"></a>线程池中几种队列的理解</h1><ol><li>SynchronousQueue<br> synchronousQueue本身没有容量，是无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</li><li>LinkedBlockingQueue</li><li>ArrayBlockingQueue</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对线程池的一些理解&quot;&gt;&lt;a href=&quot;#对线程池的一些理解&quot; class=&quot;headerlink&quot; title=&quot;对线程池的一些理解&quot;&gt;&lt;/a&gt;对线程池的一些理解&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池是对线程的管理和调度，我们自己当然也可以去新建线程去处理并发操作，但是线程池提供了很好的解决线程之间调度，管理的能力，这些能力可能比我们自己去实现更优。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建线程池有两种方式（本质上是一种），如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通过Executors封装好的线程池创建方法去创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Executors.newSingleThreadExecutor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用ThreadPoolExecutor来创建，其实上一种本质上也是调用这个来创建线程池的(阿里规范推荐)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//其中参数1，为核心线程数；2，最大线程数；3，线程存活时间；4，线程的阻塞队列；5，线程（任务）熔断机制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于第二点解释这些参数的意义&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;a, 核心线程数是线程池初始化就会创建的线程，并且该线程不会被回收；&lt;/li&gt;
&lt;li&gt;b, 最大线程数是线程池中允许存在的最大线程数量；&lt;/li&gt;
&lt;li&gt;c, 线程存活时间指的是当非核心线程在处理完任务不再使用后多久被线程池回收；&lt;/li&gt;
&lt;li&gt;d, 线程阻塞队列是任务队列，线程处理的任务会按照队列的特点存在队列中；&lt;/li&gt;
&lt;li&gt;e, 线程熔断机制是当线程处理不过来任务时，应该做一些什么策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;线程池运行的流程&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;线程池刚创建的时候，里面没有一个线程，任务队列是做为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/li&gt;
&lt;li&gt;当调用execute()方法添加一个一个任务时，线程池会做几个判断&lt;ul&gt;
&lt;li&gt;a，如果正在运行的线程数量小于核心线程数，则马上创建线程执行这个任务&lt;/li&gt;
&lt;li&gt;b，如果正在运行的线程数量大于或等于最大线程数，则把任务放入队列中&lt;/li&gt;
&lt;li&gt;c，如果这时候队列满了，运行的线程数小于最大线程数，则创建线程立马执行这个任务&lt;/li&gt;
&lt;li&gt;d，如果队列满了，运行的线程数大于等于最大线程数，则执行线程熔断机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行&lt;/li&gt;
&lt;li&gt;当一个线程没有任务执行，超过线程存活时间时，线程池会判断，如果当前运行线程大于核心线程数，那么这个线程就会被回收。所以最终线程池的线程数量会维持为核心线程的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这样的过程说明，并不是先加入任务就一定先执行，看下面的例子&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//ThreadTest01 test01 = new ThreadTest01();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; taskId = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Runnable task = () -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread-&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;string&quot;&gt;&quot; is saving data:&quot;&lt;/span&gt; + taskId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &lt;span class=&quot;comment&quot;&gt;/*模拟存储数据耗时*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     Thread.sleep(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             executors.execute(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/*运行结果：首先核心线程为3所以立马执行任务1，2，3；然后任务4到13被放入到队列中，14，15，16又会被新创建的3个线程（最大为6）执行，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; 再增加任务17到20时由于当前已经有6个线程在处理任务了，所以17到20的任务由于ThreadPoolExecutor.DiscardPolicy()策略会被丢弃。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; 然后6个线程又会依次从队列冲取出4到13任务去执行。*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>跨平台技术Flutter技术规划</title>
    <link href="http://yoursite.com/2022/06/29/Flutter%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2022/06/29/Flutter技术规划/</id>
    <published>2022-06-29T13:44:54.453Z</published>
    <updated>2023-03-20T10:33:34.486Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1ebd1a953ba1b8d53e120b6f764ba6e6e387bfc366584eac2fbc9a377ee939e9">ebb08aa0288e261ddeb0b4aadf3d63d9334d551ecfb20a988ee264721d658bcc117ae618d7bd0102b1a64628349aa697db762dff100a77ffc0d8dce728a495b90f3c3638a9eb9cccdd998e9c9068ef07abb960ad41796745f8645488ff22941863cf33a0fca5e848719cc18efd78040c594cb6ef6c42a8710e529b4ab25a45e37659edca2ad19d176eb3c649334813ec4500dafd3757a9d09de6ec43e302575b01bccbaabddc745652c5e40e7ad0c0b42bd4f13ee4d8a0e3467f68df90b6b42e9f72e80dd3bdc3d3720ef41136eeca11a8b68e171417553a7629954389d606e260a62765aa4f3d42420eb61cc4aba9d680191de54edd1a6462f7529747889f6540a282fb509283859a69f42ec299a29f96089c42841fab1d28b59d765124f06acbf125857717111d9c6e32ee694ec4d62163180f9336072d0380fa76d12d628f4b1c6a831d6bb9bca67fcb1c6c8717a32b3f70f67fe5444882e66dc16a977364eb1295c6cf68ced1cfb2b4ab0fc42ab9e7c67a47b319609250d69cfc4245794a500787c55ed6da1ba188355e416acde0458a2f2197a3fec0ceb8e52c2374f1f7127b9666df428162ddaa8433d9c0d890918a0359d8a307a4a35363cda78d8ac2fde860c31bf14573cfb044485b47579ec867e00bd0caadf74d7a2298c146c59cdcf3194efb7161fd38edc4f76b469f24d2369f7e52ed852065326096d384708cd5aa79c258e3210ab8eb8c3f78f710e92742349a147cf46ad303cd7aca5c3dc9df804caa726deaa48a122bd3ccfffe6ddb35b8897e82f811d1413025d34bc2b6954d05e7c22e5a0acf8462c48159440293c9cbc9d9118b8ec71fbc3cdea05a71501aee182cbfcde2f88403f398b10257f0f64b14a2a467e353d61534d076231764f71078cbbc1fadbece02cc8a73c0741975ce60b35dfa02726bdb0d9f16f456d446535e61ddd5cd116c26da4b73f2874c0e3144f803d94b2f923ce0003db4874b0019c9fed3c4455a197480302c9a7470e5f02d22987baed37f4a1425b330b5e93e84e7c2c5175e029ff6aa909f3b9fcb8a6e7c88420833acf57457c15b7436413e5db5c941e18702ef27f0c4952ee999c96159006e16885a62ab9cecf954ed79e3897a6c6d5f5a140ccb9aba804330ddefea460af58b91e9a10243f8f412711cbdccbdc0f1139975d081ffa68af29e6c842fedd9a7814ce9f88c569f8b0ded0355c469f355113e3d30534d3ec1bb23885f9bc122d0984c44b795ae65a5be52d6e827cf1f2502e09dff3e1d67f8b206fcfa22dc15a9f7b802e9956359275a52d26cf7df222a04f82e26266e33e400ea6faa8e790bf7051459bf87013a614109860cb31300805450e3683265621c8389817064ed51e43aeade62e251b324528fdc1904f4991b8e5d0d7975f5875669c2c8d3f965cc05fd1ab9f71e6ea638ac69a6cf4ea9b72ff337ece5fea85906584c48d5ae133a29cd557574e69221b03156d8008e7da886ab90c87318eedb10756f5bb8f7264621094710e8de6742350903f2896d1a52ee4a3fd2ffb91231a4bd0bd599af4cb38c2a215473b5f884348f8f79f8a8f5cbbe5fc972cbd0a00715b87f35f674f670475b1b6ecf83834b725a4938fc8b6dbdaec50abe9f2edd3747208b1f213e05952679241288c9601f29e5745b0716dd4bc6a0dbd2abd28c6441fca636d2d0f4815117d9768d2927407839f9df0485d9281045cf86cd6a07a0a0ba79b4195f0a1c3a3977d3c3b8be7732c71430450fe21aa7e25d5ff72636240976edb429444c8e06a8034cba97c76244ba2f5a6ae3c6ff27f9c20544f89592c2edca786b32bdb47c25c2a7692c25423897dace711445390b5863b07165742cdfc816980daf7352c8e4c0b13e7082ddb37476a7ffd632a9c1c7dce017a870fbe420d20071a50a9e984d9d55b242696f2c44b425d8646b1dcc453b587bcf891cb5180ac98a1319f5ff88a091bf98a4009e1d3c6f0edda50e20415eff0c74555c52319b9add0003d03f7abaadaaccbf7b558026550c39d2bb98c55739596835512c41639a6db27769804dc755304c3f0bf230b9236d881c0aecf10014a0549f416c4fd5c6b7ce4eeb45a253de412aa7db96ce2f0b8b554757d6f1fb9ce43b39d1f059445f631c5c272293cac6941eda9b6c380cf1b47b4f55f2a930edc48e1cd86754e6224f4e74a0ff6458f387a7df5c2c0680f2f0fb6f25c26909ed8234539ac431c3dd088603c31d7a3682550209d854d1e7b2767bc45eea98787160ae652ea70d3d627282e87c20ba404dd6aa058908ae8b2ce564fa381101dff0b9016a9cd926c83225bb3d0d6ddc7cf5cc6d0c13ca6d204993f1e35ddbd95339fd20c45102efbf136b5951a4be1e6954d8d65032eb7fab7f7e8191cdb42a676d4987a1d14c7ac00b74aa2988712598e3b93e9421e87892d0350f88c1a9d1c8f090e98a0390a10f0eac73b55ef4fea75ceb79cfa50595d91e403beb0391f4a1c5cd60d38bab4754115818690b8a238ad66345807cbbd2e0b69ddf602120add94cbe3a706e826b4bb47c86c5f9599891e8443bcc6c04dac55bfc458fed5c881f995a18ba5604d05d4fb01281a9f2cd0a062b7e6b4a4d2c7f657757f448515aa884e0874660ced85c3620e10e1e33c3bbb216e33adf14fa95f30f85e5afe861949a08533cdaea4817fd32a2d59da42496b74791b7f62673de8fa4635107e5bbc01848e6fa70acbfe8ee3a093b4fd264a0c03365459d17fb7db50541d782129beb89107b2a0f18aaafccf8f34364a754dd10d5c000b6c8529a9872499c854c6febf8d158219de398ffcab152a18e03c4d2ee79dcf6e10aeb0b17e470a30a406b85551789925c290c2d1969db29ace80686027f62f218eeeb136c6541509130cd898865a3befef178f6cb4a5f3d4118dc493762fd5aa129710090c1caa40477f4383d7e520d7d5e9de39037e8ce5e3a8961d2d9376c0127742a3e42ef01e311d3f54112f3aadeb92f0ff4633db6bce55b43ac7f01512d7e087632564c247913bca66911bda72cf70761e3e4724074ec9050d8f0ce1bf0a05a2c2c6e6bafc343280e6a0d60604552a23175fe1db721a7b5378d6e8060193282f0d349d6bd0a0400f50e9e4cfd3122e5be26687e2323479a59dd4d03ab3fc004a6ab172ee19d051ab5f70fa5d6bafc65ebcc30ff359964c8c427c4569eb8be78cae7ec642fd9f823ae3f2e08d4d006201fb8098597b8cfb6d6c0efe84a798f4b50796361e0c6152080686327b916390b64f43f81d295cbe53d1c6a0528ec885e1d041c756e02cb938e5b410617edfcf56b66b3ea56a2c97853c3adcc458c4e7c2c4e4db11e79016e59f0c35f52220a4a29dbf22c2d03388b39395423130e65a498ef969e44b92d4d6d2cc22001becd01dc9689bc9c7f62874d70a1ef6d1bd114e0d979e5c7c223bba994c59f1bfb4e4e83400b9b029cc8e98b0f327c2afea64526ab7a468871ddadb874f4ae51493815714d86f7760ab7ec87873dac2108e6da6297078eabdc2fa2e499fee6064c887320abad093b030c4932fedafe985258688f161874277941b7a7e2f7492990956f1ab049003e75d39fbb8faa453c394c4ec2a743495ca06a058f21e0cc3506c23bdba88ae944934b2281eeba8d30331fcec3d81b8e9db2a299824655d56d005c2ca53e40c5042766d4a6e2b6dac071c4e1f25f624c4a3648850fab2c8dc7b3983f6ca60c9568dd925b9c55e594a0080abc76fc09ee50f9a12ce14dc1fdf3db6cc40bc04c2b41ba3b2a304776cb9f6e8c36f5a280818bf49c0b6bc491d1a42a1fefde7ca591f553f3f56a687291b1c163646cd807ee100f085fd871a1c0ba3570ffe5d9a3e76d0a162bc4cfdd149ee202f0cce1d153c5c986509cc90931c9a414083276d3af187fbf3618555b0d52f60664518b3e2ced8aae815c8b44dde554ec5ddb05640ef20c2a266a40d4e242e67e1e4d797c2879121f28be8143a484605f70d494b63e1d346b4fe69cdb79ca220d4246368e7c507a2bcd9025f02d95d77e309b506cd98e9071e0dce02720ddce1215024c4edb89193248a132af81ab84a3ce887fb9b1735dad5fa370949ddf1776fba25c57c49ab190895f8e684f193cac4f54998d1453c96fd8bb4e09c72c8530ea66dad9f14dbfe00f50082a019d38d92f974d43b318849f8a5fdac1a758069c677e417f016179718564db1305bb0d86269743bf8bd493605f0ccca1cfcc4c682d345cadd2b74064f2b6126c3829c786ad5acc93991b33225e54ea340eb4d0088874f2615519748c4a01ffe4bc827b69f7fdd451167303d49aecde69e4136a1461479719217c3487f7b392c611ada78bab57a7ce3c4f36530f6e4b09d5e0398856b89e429c06afdeb72024928915e2cba0c5e94318a149628c6ea4dad7042a6bf9870358f7439f060e0134d3541e3f160006cc63495d7b87e739b94b1cd98dbcac8cf6faa5eaaefa85cdf7421e37086a008a4ef496e03c6d57e2cb3c72c55b83d98aa93c7ee3da0352776d9537d3ddbd0d30023a34edb16100dc24c67b3fa12c4859b55626bcb681bd88ee9648d88dbe31c344314b116e6b3bd853f53fe33363f5ed5cd89f055445715bbf7dbbeff3bb78d190313b59425f2902209b0d07f90e237a7a805dea163ba925b7daca365f5706e19d0308862a55a176dee05fefa8c15d6a2fdddb889a0797a47334046480799ea968fb663463afc31bc6cb2713da89f33804421807b9a2b5d169e63dfb1358d2a7500a6796b935fb4629ea30e4404d84326e4a864ab92d9529cc29a1202371a490dcbd5d90ff3c1f8f4599271b42f7a02d4e1d088bee835564fd385fa6b631b989c9821e4f9fe76e04ec5c1c722629fe24c3a2b316a66b101639bb3845fd5f23f6830da0c1906b08d663f5502ce40e9b66250b234a73b676057be9baa47a9b7872</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      私有文章, 请输入密码查看。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2022/06/28/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2022/06/28/Java 反射机制/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2022-06-28T14:38:25.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么叫反射"><a href="#什么叫反射" class="headerlink" title="什么叫反射"></a>什么叫反射</h1><p>Java中我们创建对象一般都是用“<strong>new</strong>”这个关键字的，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"Ervin"</span>);</span><br></pre></td></tr></table></figure></p><p>反射则是一开始不知道要初始化的对象是什么，所以没办法new出一个对象，这时候就需要用到反射，例如我们使用第三方SDK的时候有可能没有提供api，只能通过反射去获取类中的方法等。按照上面生成对象的例子，使用反射是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"com.ervin.entity.Person"</span>);</span><br><span class="line">Method method = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line"><span class="comment">//Object person = cls.newInstance();</span></span><br><span class="line">Constructor constructor = cls.getConstructor();</span><br><span class="line">Object person = constructor.newInstance();</span><br><span class="line">method.invoke(person, <span class="string">"Ervin"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>直接new对象是静态模式，在代码编译前就知道需要生成什么对象；反射是在运行时才知道要生成什么类，是动态的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么叫反射&quot;&gt;&lt;a href=&quot;#什么叫反射&quot; class=&quot;headerlink&quot; title=&quot;什么叫反射&quot;&gt;&lt;/a&gt;什么叫反射&lt;/h1&gt;&lt;p&gt;Java中我们创建对象一般都是用“&lt;strong&gt;new&lt;/strong&gt;”这个关键字的，例如&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java基础，技能提升" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>怎么看懂UML类图</title>
    <link href="http://yoursite.com/2022/05/19/%E6%80%8E%E4%B9%88%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <id>http://yoursite.com/2022/05/19/怎么看懂UML类图和时序图/</id>
    <published>2022-05-18T16:00:00.000Z</published>
    <updated>2022-05-19T13:05:47.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h1><p>请看一下这个类图，类之间的关系是我们需要关注的：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2dzjchqwhj20ns0bjt8w.jpg" alt="UML例图"></p><ul><li>车的类图结构为《abstact》,表示车是一个抽象类；</li><li>车有两个子类小汽车和自行车，它们之间的关系为<strong>实现关系</strong>，<em>使用带空心箭头的虚线表示</em>；</li><li>SUV是小汽车的一种，继承自小汽车，他们之间是<strong>泛化关系</strong>，<em>使用带空心箭头的实线表示</em>；</li><li>小汽车和轮胎和发动机为<strong>组合关系</strong>，表示轮胎是小汽车的一部分，<em>使用带实心箭头的实线表示</em>；</li><li>学生和班级之间是<strong>聚合关系</strong>（下面会介绍和组合关系的区别），<em>是用带空心箭头的实线表示</em>；</li><li>学生和身份证之间为<strong>关联关系</strong>（下面会介绍和组合关系的区别），<em>使用一根实线表示</em>；</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖关系</strong>，<em>使用带箭头的虚线表示</em>；</li></ul><a id="more"></a><p>下面我们来解释这六种关系</p><h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)，继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt><br>eg：汽车是一个抽象概念，在现实世界中有对应的实现，可以用汽车定义具体的对象；汽车和SUV之间为泛化关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt></p><blockquote><p>泛化关系在代码中表现为继承非抽象类（继承）</p></blockquote><h2 id="实现关系（realize）"><a href="#实现关系（realize）" class="headerlink" title="实现关系（realize）"></a>实现关系（realize）</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt></p><blockquote><p>实现关系在代码中表现为继承抽象类（实现）</p></blockquote><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；聚合与组合的区别在于，<strong>聚合的两个部分不是强依赖，即使A不存在了，B也仍然存在；例如，部门撤销了，人员还在。</strong></p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt></p><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；<strong>组合的两个部分是强依赖的，A不存在了B也就不存在了，例如公司不在了，部门也就不存在了。</strong></p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt></p><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；例如，乘客和车票之间是一种关联关系，学生和学校是一种关联关系，关联关系默认不强调方向，表示对象间互相知道。如果要强调方向，如下图则表示A知道B，但是B不知道A（直线加箭头）</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt></p><blockquote><p>在代码中，关联对象通常是以成员变量的形式实现的</p></blockquote><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt><br>与关联关系不同的是，它是一种临时关系，通常在运行期间产生，并且随着运行时变化依赖关系也可能发生变化；显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><blockquote><p>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从一个例子开始&quot;&gt;&lt;a href=&quot;#从一个例子开始&quot; class=&quot;headerlink&quot; title=&quot;从一个例子开始&quot;&gt;&lt;/a&gt;从一个例子开始&lt;/h1&gt;&lt;p&gt;请看一下这个类图，类之间的关系是我们需要关注的：&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h2dzjchqwhj20ns0bjt8w.jpg&quot; alt=&quot;UML例图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;车的类图结构为《abstact》,表示车是一个抽象类；&lt;/li&gt;
&lt;li&gt;车有两个子类小汽车和自行车，它们之间的关系为&lt;strong&gt;实现关系&lt;/strong&gt;，&lt;em&gt;使用带空心箭头的虚线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;SUV是小汽车的一种，继承自小汽车，他们之间是&lt;strong&gt;泛化关系&lt;/strong&gt;，&lt;em&gt;使用带空心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;小汽车和轮胎和发动机为&lt;strong&gt;组合关系&lt;/strong&gt;，表示轮胎是小汽车的一部分，&lt;em&gt;使用带实心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生和班级之间是&lt;strong&gt;聚合关系&lt;/strong&gt;（下面会介绍和组合关系的区别），&lt;em&gt;是用带空心箭头的实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生和身份证之间为&lt;strong&gt;关联关系&lt;/strong&gt;（下面会介绍和组合关系的区别），&lt;em&gt;使用一根实线表示&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;学生上学需要用到自行车，与自行车是一种&lt;strong&gt;依赖关系&lt;/strong&gt;，&lt;em&gt;使用带箭头的虚线表示&lt;/em&gt;；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>消息推送</title>
    <link href="http://yoursite.com/2021/06/18/%E6%B6%88%E6%81%AF%E8%A7%92%E6%A0%87/"/>
    <id>http://yoursite.com/2021/06/18/消息角标/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2023-03-20T10:33:42.213Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de6fc2fc2e67b35badf9526d75d94b4099e25897edc1ed1cd27dfca66ff12468">ebb08aa0288e261ddeb0b4aadf3d63d97e083ffaa0d4fa6b0c85289138924abbcf55a51af6c61cc4e373f667829e744f297ead5b8ee0f05f1a1a314d5dcb43ec76920a6242ea186c7ac4c823ac240210604dd1f63554e8be529c7182901ec87e81a62424a23c4364a55f2f5cb46c75b0b4856ad7860f807f0fe8a3a7a093e5b9e2734dbcced5ce7b35f6a7d404fe0c2fe03565e36cf3390639c0ad9121691a3f3cc9f74975e2d7ceb1ae2f7d6976705f06c0d4b5532022cd04debf0b98463322dbe52640c64c6f9f382d86c5899a7c07b32e9c0ada1cffbd13689b7021b083c80b8131b0d6d8037f122a4254d5a19fff319731a42fb50bd4014c8dcf8841d9c564d9b1c649614e071aa0752b10698886f617c628f326792ff4373ab9ad7ff5119dcbcecbb0ac574fc259d399d118c8e9d64ad51cb2b05f557fa8d79d028218bb5137963848854014dc709240160001fb4e0ace1bbb80566921e18531973392d825445e6fd72d6df3e7d648c92b5acdb5d866e4a66d8bcc2dd8c9682aae048f644efc0f8ea40ffc7d0bc2ca23b23746e5082ffad301a82f04044604755d574eac68b3e49f2bfb104c47b94332e01523d60a5fcb020969458538203d72fd7676d7f65137ddc33ba48404257dad30eb8613ab55a6459a7dc8dff4e31e0f16073403f946bd08d317839f63994a55bf4a7f8fb8e19ff2f9c2f81b0b3ef81c1bc829dc9615eb71593a34e8282f9b7708251b55a9a8767467add8a3ecd091c48d249f91014099274ae89a6544cc873cd1a02b05346ed669aba0977b1bed5f2ba3c624db41c35e078b3db8faf672d2760710c3952c8cdd2877f43f4440d5eeb52255e32d4e54b2573d50cde71edacf8393108d77649136848532ff293d3051b04ea91eb737ab0a6d689325e9755b9ea29cb867158b6c8e922a33fbf5ef4e3c0de9a4450d82bfc3e71543c7a61fec53b88e97cc4080cc98f6272adf2ef7c7feb2128e192c1db289db60ec27cfd7115b4bb0ff0453c3fe3731bac12d1d667f024e11345c78eccf742b9d1c4ae079e109487609e6b03f8aa47bf565e1ca17e3fc308d44964647151a25a4ed09078a68b42cdf06c9f507a1d79924453f81a8f796c6a89ec7b0395ba0f5534eb95732fc3deb8d69f6bdd1b05a527d3efe70c70460e376d35212362d49a78f098679593920ebe9ff2e1c9cc90e80d15504749dbdfc1ea34a13863ce3789bd027d48e6b41773368af20ccf98c6458b661e8de933b18c2b38d582d9cc2b15888c84c961d3e950dff5694e77cddee13235f37605872f4e083f425c04b26410ea8fad146fbcab7a22c7ff90d337714bb7d20acae105fe5ffe95cf5e2d38c3e69e03507020a48fbda7d9cae636f2a4cff15a6c639e96a6a55cd040ad997f2b58e4c394275b4c43540ed7466e131abf8a4cb7e1e4cb9542099ca8c3430612e503c7833cbc8794478311729e110d922cc0c7de08edf21ba2c26a93f1e87799f5d79ca07c30d2a443e61906f43fa2d5090e7f39f39b8b49215a7778e6e456d6917e40888815c4b221226787e04fadc8b7ae531c56dfcb7f68f5ac4ad303e04a994f8ef0733852e69f1629c8d525a3ed6c15effff1b0cee7bf4ea686391470e905b92ba102fe03b6621cf2877eb9e449400666926675bd915f06533c4d718f1ea302ef2c82cce2f36bca792836b88d5d5882d3ba223b8c1dd034c2246e4efe4eab32ea8b19ff05e9b99c73d1004dee06fd57f784afd853e0f2f35ef91e32e115fdc4b0a1c7d1e9f0de41eda611585b5552c8c52a4c8afaedb2f58ecf74702b9ef07761aa56e2788daee33ae8bcbb6eb284d116690240be2667b1639328209922d36dcc836f9ff8755ff38e7af8c8740efe9a17621836b77dd63197fd265bf4b759559d0cb74eccee9733cd97860ac7b1ced4ddc388924c4605dbf6430c45b526416c01c9c505a5cd741dbc44008129915e8dc030b628bfa6bf490a9c79684e9176e770542e0f3b94f98b6a7394ebfd00b2f4033845df166f6f5e297f4df5210e495e01e799924f3bddfa06f8f63dd9fc8ed29c74ddc26e470d60e63481d7c9e99329e0fdbd2534b6e13ae9afbd60af003a22d4c902888612a9c6be0d14861e56538b5ecccc6d8eaa03fb1c7b6bb53eb114cb45bbcd941c4a592cf25f65d8bc9ff1f9de46e1f4bd967461ce053f3122641c477d4ee864c104f9af188682e64d33c9b3ae874f94298843fe530686283220f3b2fa91769ff59a956e24563370616215a0f42fb5095336fc3ebbf8106558d7ea42a560c1d7102c205ec10557615a2a502acf5a24bf19860e922943a0b00b8e978259b2e4e6321608b2a1c9394c38a4d7f8db48df1f49aa3863586f8c7077f97fa6f78e1b044b828c59dcbf31c7a040128aa43e8059f87793ef82c28941edc84d20f97b80445f5fb42153b61ea1207a819b1f2847662f2c5d6694b02347f5e9df1701a84c3d37bd9f4d48e6ebe66e3e15711820cb03b00ce6ee1f709e285b750a6c5ef28c03850c204b16e6f4e3889a72f4059b59816ada92abdbca3a307ee1fabbe1b7e995a5490bd7b85e5c716e26a702c02274134933756c61d56bd45170bbed30e85e8ba6dd35c2001d159c5197870675e728828be24bc9a0e7505873f31ccc09d32893b5c2dccca3b083ba7d8cb902fafcfe2b8bb7eabb0e97abd2d5c899715ca5b19b6e29f9b10d2db797e4bd5b800863a301bcdf96576e745b8ac37e4c0a75e6387a078e7015dc7ff9c9e264e19ed049b40a0dc2d9cb2146fec587a8309a137675f5fa9e5e832a13c78c74acb254369edfd8a7621c78d6bf60c8b85bf5fc52ed868a365b973597aee079dd814c9c8c9b77c3ca96546eb54ce5e51b93441fe9f2ceaebad9f5a8227696ccf2da9ca67dc2676ee03bf1c78231c33620e9157c92ecdd3a9bf778f0a55061ee959f7bd6a75118a9279d44dfca3a9a146c80752ea2db9c6df930010d44d7b055db4b239e101b0a61d6249435ca665c08719d42b5c9a309cc1f921443d4a414aebf4183a7555d4e60cb3fb546b9c962460daa0ab9d95460997b62dd7a5758cec0c4d5918d9c3c67e58fba9872d7cac13cb064a07c1b5fb9e7c53b13e4602f72d7dee8f1baa480b040ee1717e159f93fc179c5005190c8a9254dd4ae526cbcfe251a7b6a9673b3525f6fca7fc2c752bf60717d96b3613299bcbded852feff693bf7d8df3447148aa561004a5f5600d1eae76318829126a4e5381461d8667cb784a1ef63e1d4d8aab4650d3c1239b301edec2e20349cda440dcbc59719fb163185d56dd661a8d43d762db45d429793933bba3545f1b7505d583ab37a6c374587f41c9a66b3755ac84152b205f5f270f0bb22847f784009a07af7f2067baec08edadc70dd31cb2c61f9f3596ee8a423e2d5f91d323ff91b6e8eb2b87798ea0ab7cfbb112a56ce08e780c0501710113c146bbdc533c0291803ade7d573d4ca6b887bfbfcd491ec6e3ce3c3f71029e3afb991d67f52ab7df524a91a526392899fed6fb8d383a88e4b8e4a92b0405062c4a6518e32d780ad07340f5cf835f7c3bd1021987a275693d209efc0ea5054d0b2b5ea7496eac6f9b8195bd5361b411c610b299c107719b768e99980f70c3c2c7efe0c70375031f376144df7e4dc12764adc5036e8a0b3419b55a89b311bb20fa2e56510c54e2d08f7943274937650a0f554186cbf6453f4de7e7c6c48ad3c43eb4588cdb771c8c0548bb638756f78598e07da813f63f79b26a6416b80a83fe56087131b3de99788753dd957ce3018968914f67b1f9b0d5948d8df8f885b5db0fb28170dc5f2d004d6b520650e1a9462c02a7f67f03bf2d114a5c9b77dd3e3a5a2f6bf4a97c8a18ce3d2b5034dcc97739c932ebc8a881d6971c0404c242aeb4b12ac31fadd529b14bdd35bb43b0329388bfd39e74264a7cce099b4fc2c5ba800230df12cdfb0d5f364c05b091c3c26cdb03a2f089156bd2115221d6ca5452aa1a5ec79f304b6b7c6f760ad7e7aa0da94de716c3333803086d8fe5700fc996c551fc7fa81f6c1324e4f7eeaad5c6fea714858edbd8ee63119a7828eb8c28e56d13e291f9258e48dd3d458b3b443c5a476c0d4febb33b35d93d194393d34fa6d61f569685334d0857f10b78557738963386ddcc1796acf2bd86da9b051700697aacbe72c32a4c6a2c8a740971883e4817d4163de86551635a39b4f5414602bcc2a27ee21013b3f104aab74539d0291552a388065ae67ae7dd5417a64cfb5c6561490513d7711aa565645c7b77b71220a7332e8045eb3ec0cf7f338311e579770431c965cdc1080bf8f64d7a78e3df227f406074e237101be2dcfc6336d4afd58677c0f19c39d373f58d19f495195681e9e2cb8bc6f79438a3c876e67479b6e68fdf820ab0ae6216d3677447c589bf34039c1f4af232b22733f2724148525bfca1366c26641e6c8bacbcde294e704ef11b1cce7fc6850cca2c0d3bb2657dd6898c0e0475e229f5f098db4002f379555043fb513d82009e41fcfa440815690bed940f8b0517ef2ea314e2b8a9f13833fae5016035e3686d560bb4484c392553d515685706f2cef0a770f2a3164c8fd026ed0aa843e96ae6d18ec6ebea1e88a4bfc4fd31a7d01a885e31604ffb669cfbf2384911704962170e5a2d8276122d799a5a1ecc363067cb7326838ead311480682947d0bee87143e0ddea39d21f46a0783c43726e5622dc910464681168a215b1a7b3ec1dabe4b945cc5f96b39b113770bd20fcebb3b7e3b43b8061dbbc79604b96e7b76c17d23226d68d5fd2ad6c73713a148b210d490333de7d8ccca2889a55d776d736ad779f1bf5a3295b2d171f1020e2c0f94dec511f5efcee97557a3089d9da14bca53049a84a14d15c5f0e9eff1d5927f7e8033a96195673c0e090066c1a4fda8e9b2943f818076e33f0a1421f72de9d5d77cb9e64a2fc854e330f93e77421f73ed9c27438d8f5eb6f55030efaf5fb81bb63b0f6df4d2a6d45f190a28c3f75a1b543dcceddff4bba1fe60b75509a0274d0fbf8e31b4bd4ac4c2b97bb8a7063b982a46d552fd1ca980290f54f305482e2e6d7553df6c376636263ffb83409eabe573a50a68239f8b1d15676bf6a1fe4a426f76862cfc81958483efdcc9896e9b99eeed7fd635aa13c64b362c34d298aea25bc82c61ad81e256138d820decb08952ac47b88b01216281c0744ae760db93e38c834089482c8e5b1352e2cc72469a54c192c23117da9eec65377136fb557a991b38afb8ffaff6f394c3681d9a97548b51cdca1c13cc5587540d0bfd38df2d68462197a859f6042419af3bb613efcf9d427cabf3bd4b23733459fd5a45c2f5f79f848a8628e2ad89fd825d52a1970e529691e24003f14878fffc88c0c7d59921bb450772dbe061c880c848f2cba6c46dcfe57fcf3adbc3b24f4bbd6c05bff24088751e4ec880db13539ac747986799b17ef4a0cc97b15297002b059c1b0c72d26ee6accc6c78093826b21434b915ffc891b9369003d183ed6d1ab4d99b2a8e4c7d48f751a2a6937058c55d866cade33bb7a9a110f8806dd4d77036980f03765a911932e84b99ec630502b0fd429f062c27646b24433dabd0fec60322b641b499728995de132a1f34a15b7f92f9b7c72f2f88ca99a6ce1d3ffc1ab43b458a64bac3b3afc6bb9cd342b01b9400686a2d805618abb254799a092c69735c7d19524b8858d6ed0af57519a90eb5bae7fd3bcd351d745db39d66192a58ceb062ea52b913a1b418ce2eb9068d41a204ab2aa2351d144aa66976972725a732ec3455f132694c4dc0fb95a62240aad2eaff7e06368ecd49d760af311064c95768b1df1eff6a1ef5e8515f1bfdfaac169cdfed2ea185ff183ea0b32fcc5e742071c1eff0dac4fcb309a6d6799f86bc51d387bd1bdc3dceae802b010a10c9cab8f8c1f8272d22f0aea4c0ea1276452af30dbb1915a3d0c93d71299faf7a10eca8bc9eb9153af4361a4c9235a10afabc77e053ce0e8a8e9aafb44c7ee24bd3851ead18da66864260b1dad3ec16954a1524c243f22c65aa3ae81869b62f602273f0a27d1215b2e17c130d7e3c3df0a96b7cd7e707ebf325579703bad2b3d9d520fe8aa1c686f7f1c75297f9da0ebd950606259b831aaf2c1d6f560460e3453a6cdeceabb04c5635f9b126236d109ed291bf9ae10756c538e1dfd2f8ba5bdfec23a990bdd8de82e2ceed5b0ccf954708e6dd3ab3fde27539bc5262937189c55c023919363a20991f3d11e246a90f86c1cf788c45f1a77b07ad80949096238b7fd943b293edb536a78f1791aa608a571fc4cefdb4fe1856e79b1763bb4bf66e5dcd8035f0c4bd2306cb50bb2b3a29c6dea5be91cc7dc9d68bd4c507ebdd968ac5dd801cea602625edf1180f74ba43e5273ce19313b50596a0ddc6ca38c8df2aa4cac18bc57891fc85974026daef7a3de7619ac7a61a58b411eb68c6756ec2ab98cce661d9a197808eff2097a0882a6603bddbc6379a9f044614b152f1bfe1e57e54dd60cf8a0de95af7d59d172a56c2f2afa817d40fe7fd05ea0ba35e1d11badcd82092bafab49365c9921db585a175f2b7237cd9844d1eb4cf705cc73cb985a33166b8524f13e08a959b4c98b6bd0efa2ae8435ed4d2c68a453ab17d93a90ab00d3bf57e8eaa6b9e864819317d6631262c4cff2aa4624793d8961b4d01813c1a74e7f9420a94a41f86b2862f3df8ce213a62193b5dba5821fa1e2f815631f67ce7aa358610d2d64013f7be85035a3d5a13887e4334e57d728e2e1f75c8e20e39a3c0333748e102d044753e9838e19270a6b25553b3dbc2880fcae555e8da0272b4504263c97dedd6bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      私有文章, 请输入密码查看。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="私有" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>私有文章</title>
    <link href="http://yoursite.com/2021/06/18/%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1%E8%A7%86%E9%A2%91%E8%80%97%E7%94%B5%E5%8F%91%E7%83%AD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2021/06/18/网易云信视频耗电发热测试/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-07-13T06:19:44.445Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed5b4123d3dd01d0b4c26fc99d2677193a3d3ccb41059dd8e047dbdace86dd3b">ebb08aa0288e261ddeb0b4aadf3d63d97e083ffaa0d4fa6b0c85289138924abb58fc845e64c0eda53c9f4fcd54bf3827408f21a6ad76ce5425911ef71b0f09e723d169da98587c817a43570f7e7809670feab795c2445b2e3fdefd7c17e8e86b7212beb6c324748abb2bf27a6a09abf239f8c672a62c87341541007be7eaf829330fd67354180b7537fb8118be1da28fa39338be4ae42596ee1e0f8c29a5c8b60ee3010e769baa600cebd1cfeddccdd0db38bc76f0cff0b2d83a3cd308d0eb8bdce45c7c7b114e7e048b218e9d0bd62137de2ecc82a1dea264a6e23a6081e19ba49bb5e79396bf434e8d7c9281a138b008dbe2cb616c5c3e20600281dcaa9c93b5e5e3a4d225fe7263d3dc740b67b4ac285c60aadf0b2696ac1fe9d4bcfef3ea1c5aafe19c5fe0aca81db85bd3a3fa1a4931ebbce0fb0b9aef2571eba9887ce136697cbe3f8c472463d5e748aeff5e029ef28300271f66f1f7b151a40176ff49302cce536143f8ed48b4a22d004751536315129da5cdce793a1589b4139a65669f78250d13b0dcd8456c71daaa31fd7532e681a264153bfa0a24bf5c93146fe7bffbc72d105a27079780c7879d66710325e5e195c8efbc8a417074f3b09abaf368977fd4cc668810cd3a7dc753782c333b5b915fbd173b80390afc591bef62fda47ea928e5252e412de907fca7b388f880f7e827651b623cee3bcc8498698178f17430460db95f6c190d4fd8f539211c5095090253e4c0a55e0db5c4b735b481582bb5e18bc965c87c22ee910cb604d0b0d2551d4f2c8bdc5569c938aee2dc601a1e1a1eae3fe12c8a24159f608cf42a791287ca5112d315c69c4906344f2a702f5433862693eb303eb14a39234f9694de9bd0f74d40bb66f93d9f7bf74e91d969f5a9690aeded109b025c24d92f9666b4fa429409601fb7a257fc68e24475a9ddbee8e8240523af2c59ad8ff077a570578a7976c86a4bf10612eae84ce8dac3c7b69b321f7b09aadadb37ef8d918acb62e2a7fd97fc15b21e7ec9446c18bbd30d0c94f541f36561ebf08e39be1c160fe16acd70c34b004ec851d5b38bc3a849ad975413d23be403bb49a51fff51d98c7470a91ae5df8631826e4e89d8e9fc2e5d67b0e44fad1e32d90ebd3a1983e583f24858fc255540d8a9d26fa19af1045ebe8565e5b4954950016f3ae5b718e4b6e285aa593f8dce3518863e2c533c2191f680eb09a823c8a1874a042946fc153daa27f5e54dcb655a3f9170a1bb9b06783f7b94e7462c0992c2cb7469ac5a0750ae39319ebc1ee357eff995c62cd3a3a2e8d113441ba9411a7e1d30ed2216fea9cb94ee7cfffbabccb6e491fed263a7c7944eccfdb5d46a9a974f2f3a14445a239670667aa801ae5338cef76ec96d147e0441a52beb3d73496a07d189a078a6f4002684cae075683fc7b8b8c8fe4e55c3796fcae198ceceec5e6b2189268b373a4a330c869c21e5ef9449238b3e0c73fdd66058f730301f5c6e670ccaf2eda9992e61e515aad4eb7abcf17295888fb0cf32d5a476e8892f60241006644085339f2bf3e5c231547b372d89c4b30cc835906454ba48034d2ad0e771b8757dbae8421e46561533378c2632fb71c1a71dbe4e38c9da9f9a99d85a2328035f768496f0d0708940675ff30abcf246a7c55058dc08714340d10cd52645f29e17d1e314eb61ffbb5c407284e41af5fe54043b3e3fd75bd67825f011a1b8468c5e83b94f94ccec67598ae0e217bb499a1b9bd7dc1a358e301e302c61af34145aa21da58815944910531dee414570d22c20fc3543fae37c5f00d0f6890926b8baae725d6cc305915d8bc225f72f43a5606a87a0cdd8b958a9b190cdbc6fc4b3ba758aced4f1d072fbdb5c1101faab5c6a138dfa01229739d2ce7d1febc97a8eae39111647d6375e5408b60965c37eb30d16de9143faf8825997ce832039e036237c62d1ff4dfe8391e63d84c4519437662fa7d16cb9c0fb5bfd81643604621a469a2ea86afc31cbeeb8544b66f5ab6f6722c13d0d0863ed5371d23671bebc1ab21c19153802f0c22f2c294da442cb75624564159a86e903138c42111facda84fc05d4fda5a21cf0b684ccdbd3d0eb3e37ad5d18cf1d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看.
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="私有" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊LRU算法及LinkedHashMap</title>
    <link href="http://yoursite.com/2020/07/23/%E8%81%8A%E8%81%8AHashMap/"/>
    <id>http://yoursite.com/2020/07/23/聊聊HashMap/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-08-04T08:19:57.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以前聊过HashMap的数据结构，其实就是一个数组+链表<a href="https://ervinsae.github.io/2018/11/30/Android内存优化（一）/" target="_blank" rel="noopener">Android内存优化</a>。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。</p><a id="more"></a><h1 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h1><p>LinkedHashMap是Map接口的哈希表和双向链表实现，继承了HashMap，其基本操作与父类相似，采用的Hash算法和HashMap一样。<strong>其实其数据结构基本和HashMap是一样的，只是Entry不一样，除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链表列表。</strong>HashMap的Entry是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><p>而LinkedHashMap的Entry则多了before和after：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br><span class="line">Entry&lt;K, V&gt; before; <span class="comment">//上一个元素的引用</span></span><br><span class="line">Entry&lt;K, V&gt; after; <span class="comment">//下一个元素的引用</span></span><br></pre></td></tr></table></figure><p>next指针是每一个数组后面的链表，而before和after则是整个LinkedHashMap的元素顺序，看图可能更好理解：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheuq9kpiaj30kj0autae.jpg" alt><br>正是由于拥有before和after指针，所以LinkedHashMap是有序的而HashMap是无序的</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>先来看例子：HashMap是无序的，而LinkedHashMap是有顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己可以打印输出结果看到，它不是按照put顺序的，同样的数据我们换成LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果完全和put顺序一致。<br><code>key：name1，value：josan1</code><br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code></p><p>以上只是LinkedHashMap其中一种双向链表的存储顺序特性：<strong>插入顺序</strong>(输出完全和插入顺序保持一致)，并且这个为LinkedHashMap的默认顺序。通过默认构造方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure></p><p>我们看下同样的数据，换一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br><span class="line">hashMap.put(<span class="string">"name1"</span>, <span class="string">"josan1"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name2"</span>, <span class="string">"josan2"</span>);</span><br><span class="line">hashMap.put(<span class="string">"name3"</span>, <span class="string">"josan3"</span>);</span><br><span class="line"></span><br><span class="line">hashMap.get(<span class="string">"name1"</span>)</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Entry entry = iterator.next();</span><br><span class="line">    String key = (String) entry.getKey();</span><br><span class="line">    String value = (String) entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多了一行代码，先get了一个元素<br>打印结果:<br><code>key：name2，value：josan2</code><br><code>key：name3，value：josan3</code><br><code>key：name1，value：josan1</code></p><p>这就是LinkedMap另一种牛逼的存储特性叫：<strong>访问顺序</strong> 其通过带参数的构造方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.5f</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a>LinkedHashMap的实现</h2><ul><li>成员变量</li></ul><p>来看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。（默认为false）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表的表头元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedHashMap的Entry元素。</span></span><br><span class="line"><span class="comment">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，在LinkedHashMap的构造方法中，实际调用了HashMap的相关构造方法来构造一个底层存放的table数组。（如果没有指定initialCapacity的大小，系统默认是1&lt;&lt;4也就是16），这里需要注意的是accessOrder参数，如果不设置默认为false，代表按照插入顺序迭代，如果为true，则代表可以按照访问顺序进行迭代。（访问顺序迭代这个特性可以用在LRU算法中，这个后面单独弄一期）。</p><ul><li>初始化</li></ul><blockquote><p>这一块很多分析源码的都说有init方法，但是看了下发现没找到这个方法，先暂存</p></blockquote><ul><li>存储（PUT）</li></ul><p>LinkedHashMap并没有重现父类的put的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是重写了当key存在时的afterNodeAccess方法，这个方法在HashMap中是一个空方法，这个操作就是把节点移动到最后（看这个参数accessOrder），实现访问顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>LinkedHashMap 重写了父类 HashMap 的 get 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个 LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用带参数的构造方法。</p><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种特性很适合构建 LRU 缓存。LinkedHashMap 提供了 <em>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) </em>方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">LinkedHashMap 的实现原理</a></p><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">图解LinkedHashMap原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/93103619" target="_blank" rel="noopener">HashMap 最新底层原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;以前聊过HashMap的数据结构，其实就是一个数组+链表&lt;a href=&quot;https://ervinsae.github.io/2018/11/30/Android内存优化（一）/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android内存优化&lt;/a&gt;。HashMap是无序的，因为他是按照key值去存放数据的，key值和你put进去的顺序几乎是不会相同的。那怎么能保证我put进去的数据和get出来的数据是相同顺序呢，这就要用到这里的LinkedHashMap。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>AtomicBoolean详解</title>
    <link href="http://yoursite.com/2020/07/14/%E5%9F%BA%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84AtomicBoolean/"/>
    <id>http://yoursite.com/2020/07/14/基于CAS思想的AtomicBoolean/</id>
    <published>2020-07-13T16:00:00.000Z</published>
    <updated>2021-01-04T06:08:35.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。</p><a id="more"></a><h2 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h2><p>先看下AtomicBoolean的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(expectedValue, updateValue)</span></span>;</span><br></pre></td></tr></table></figure><p>我们看到了上面提到的一个在java并发中非常重要的一类算法：<strong>CAS：compare And set比较设置</strong>。我们用上面方法为例来解释下CAS的思想。当内存中可见的值如果和期望的值（expectedValue）一致，则将内存中的值修改为新值（updateValue），并且返回true。该操作是原子性的，意思是线程安全的。当多个线程同时访问某个对象时，如果其中一个线程通过CAS操作获得了访问权限，则其他线程只能在该线程处理完之后才能访问。<strong>这类似于同步关键字synchronized但是效率更高</strong>，因为没有锁的机制，即使在JDK7之后进行过优化。下面会举例子说明，在多线程中这种原子操作的必要性。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//demo.executeAtomicLogic();</span></span><br><span class="line">                    demo.executeLogic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//synchronized (this) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (bFlag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    bFlag = !bFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码是用一个boolea值来简单判断其它线程是否能进入业务代码执行，我们想看到的是线程1执行完后才能执行线程2，我们来看下结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggry7p6nl7j31780jaq5g.jpg" alt></p><p>可以看到这个结果是相当混乱，所有线程都抢占了资源。我们再看下使用了AtomicBoolean来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicBoolean aFlag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    demo.executeAtomicLogic();</span><br><span class="line">                    <span class="comment">//demo.executeLogic();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAtomicLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aFlag.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑开始..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑完毕."</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--处理业务逻辑失败!!!"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                aFlag.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(LocalDate.now() + <span class="string">" "</span> + LocalTime.now() + <span class="string">"--"</span> + Thread.currentThread().getName() + <span class="string">"--已经存在处理中的业务，请稍后再试!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrylt0w8sj30y20bo403.jpg" alt></p><p>和加锁的效果完全一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;java中并发的类基本都在java.util.concurrent这个包中，包括前面介绍的大名鼎鼎的AQS。这个AtomicBoolean也是这个包的类，它支持在单个变量上解除锁的线程安全编程。java.util.concurrent.atomic此包中的类可以将volatile值，字段和数组元素的概念扩展到那些也提供院子条件更新操作的类。后续会一个一个研究。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java并发，能力提升" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%EF%BC%8C%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>八一八强引用、软引用、弱引用、虚引用</title>
    <link href="http://yoursite.com/2020/07/13/%E5%85%AB%E4%B8%80%E5%85%AB%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/13/八一八强引用、软引用、弱引用、虚引用/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T07:30:48.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们都知道JVM的垃圾回收机制中，GC判断<strong>堆中的</strong>对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。</p><a id="more"></a><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>先说说引用，Java中的引用，类似C语言中的指针。都知道Java分为基本类型和引用类型。有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的。JAVA中一切皆对象，无论你是直接操作对象本身，还是通过指向对象的引用来间接操作对象，都是采用统一的一种方法。</p><p>在 JDK 1.2 之前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 refrence 数据是代表某块内存、某个对象的引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。比如我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）<br>这四种引用强度依次逐渐减弱，Java中引入这四种引用的目的是让程序自己决定对象的生命周期，JVM通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。<br><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0519%2F5654b36aj00qakom4000jd200lw008lg00i90075.jpg&amp;thumbnail=690x2147483647&amp;quality=75&amp;type=jpg" alt><br>其中FinalReference类是包内可见，其它三种引用类型均为public，可以在应用程序中直接使用。</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在Java中最常见的就是强引用，就是直接new出来的对象都是强引用，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person就是一个强引用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person（）</span><br></pre></td></tr></table></figure><p>当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收器回收的，即使该对象用用不会被用到也不会被回收。当内存不足，JVM开始垃圾回收，对于强引用的对象，就算出现了OOM也不会对该对象进行回收，因此强引用有时也是造成Java内存泄漏的原因之一。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示地将相应引用赋值为null，一般就认为是可以被GC回收的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongRefenenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = o1;</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//null</span></span><br><span class="line">        System.out.println(o2); <span class="comment">//java.lang.Object@2503dbd3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尽管o1已经被回收了，但是o2强引用了o1，所以不会被GC回收。o1指向的内存为null，但是o2指向的原来o1的内存对象是不会被回收的。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对强引用弱化了一些的引用。它用来描述一些还有用，但是并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。</p><p>对于只有软引用的对象来说：当系统内存充足时它不会被回收，当系统内存不足时它才会被回收。看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line">        System.out.println(<span class="string">"------内存不够用的情况------"</span>);</span><br><span class="line">        softRefMemoryNotEnough();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get());<span class="comment">//不会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置`-Xms5m -Xmx5m` ，然后故意new一个一个大对象，使内存不足产生 OOM，看软引用回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference s1 = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(s1.get()); <span class="comment">//会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用通常在对内存敏感的程序中，比如告诉缓存就有用到软引用，内存够用的时候就保留，不够用就回收。Android中图片库Glide就是用到软引用，还比如Mybatis缓存类SoftCache用到软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    SoftReference softReference = (SoftReference)<span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (softReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = softReference.get();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.delegate.removeObject(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">                <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.size() &gt; <span class="keyword">this</span>.numberOfHardLinks) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。弱引用需要用WeakReference类来实现，它比软引用的生存周期更短。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakRefDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference w1 = <span class="keyword">new</span> WeakReference(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(w1.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1); <span class="comment">//被回收</span></span><br><span class="line">        System.out.println(w1.get());<span class="comment">//被回收 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方文档说弱引用常被用来实现规范化映射，JDK中的WeakHashMap就是一个这样的例子（ThreadLocal中也用到弱引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"k1"</span>);</span><br><span class="line">       String value = <span class="string">"v1"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       System.out.println(map);<span class="comment">//不会被回收</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       WeakHashMap map = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">       <span class="comment">//String key = "weak"; //key指向一个JVM字符串常量池中的"weak"字符串</span></span><br><span class="line">       <span class="comment">// 刚开始写成了上边的代码</span></span><br><span class="line">       <span class="comment">//思考一下，写成上边那样会怎么样？ 那可不是引用了</span></span><br><span class="line">       String key = <span class="keyword">new</span> String(<span class="string">"weak"</span>);</span><br><span class="line">       String value = <span class="string">"map"</span>;</span><br><span class="line">       map.put(key, value);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       <span class="comment">//去掉强引用</span></span><br><span class="line">       key = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       System.out.println(map);<span class="comment">//被回收，因为只被一个弱引用引用（WeakHashMap的原理）</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也称为“幽灵引用”，是一种最弱的引用关系。顾名思义，就是形同虚设，与其它集中引用不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。如果一个对象仅持有虚引用，那么它就和没有任务引用一样，在任何时候都可能被GC回收，它不能单独使用也不能通过它来访问对象，虚引用必须和引用队列（RefenenceQueue）联合使用。虚引用主要作用是跟踪对象垃圾回收的状态，仅仅是提供一种确保对象finalize后可以做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被GC回收，用来实现比finalization机制更灵活的回收操作。</p><blockquote><p>设置虚引用的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理。</p></blockquote><p>Java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phantomRefDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException  </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(o1,referenceQueue);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">    o1 = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(referenceQueue.poll()); <span class="comment">//引用队列中</span></span><br><span class="line">    System.out.println(phantomReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。SoftReference,WeakReference,PhantomReference都有一个可以传递ReferenceQueue的构造器。创建引用的时候，可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们都知道JVM的垃圾回收机制中，GC判断&lt;strong&gt;堆中的&lt;/strong&gt;对象实例或者数据是不是需要回收（栈里面存放的是基本类型数据及对像的引用，所以是不需要GC去回收）的方法主要有两种：引用计数法和可达性算法两种。而无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin内联函数</title>
    <link href="http://yoursite.com/2020/05/30/Kotlin%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/30/Kotlin内联函数/</id>
    <published>2020-05-30T09:16:33.000Z</published>
    <updated>2020-12-29T08:24:32.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin中内联函数的理解"><a href="#Kotlin中内联函数的理解" class="headerlink" title="Kotlin中内联函数的理解"></a>Kotlin中内联函数的理解</h1><p>kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。即那些在函数体内会访问到的变量。内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。</p><p>调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针移出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。</p><p>来看一个官方的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(l: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</span><br><span class="line">      l.lock()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> body()</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          l.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用这个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(l, &#123;<span class="string">"do something!"</span>&#125;)<span class="comment">//l是一个Lock对象</span></span><br></pre></td></tr></table></figure><p>对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果只要函数体类似这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l.lock()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"do something!"</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制大量重复代码，那么有没有一种机制，又能少些重复代码（变成一个可供调用的方法）又不会在调用过程中频繁压栈出栈影响性能呢。有的，这就是kotlin的内联函数inline所拥有的能力。</p><a id="more"></a><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>使用inline声明的函数，会在编译时将会拷贝到调用的地方。</p><h3 id="inline-function"><a href="#inline-function" class="headerlink" title="inline function"></a>inline function</h3><p>定义一个sum函数计算两个数的和</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为Java代码看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var1 = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的样子，在该调用的地方调用函数。</p><p>然后为sum函数添加inline声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void main(<span class="meta">@NotNull</span> String[] args) &#123;</span><br><span class="line">   int var1 = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   System.<span class="keyword">out</span>.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">inline</span> sum(int a, int b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再反编译为Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> var4 = a$iv + b$iv;</span><br><span class="line">   System.out.println(var4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sum函数的实现代码被直接拷贝到了调用的地方。上面的例子其实并没有体现inline的优势，因为拷贝代码和在调用的地方调用方法没有本质区别，但是如果你的函数中有lambda形参数，或者是参数为函数的时候，inline的优势才会体现（因为不会新建函数对象，可以减少内存损耗）。</p><h3 id="inline-function-with-lambda-parameters"><a href="#inline-function-with-lambda-parameters" class="headerlink" title="inline function with lambda parameters"></a>inline function with lambda parameters</h3><p>再来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123; <span class="comment">//sum方法中有一个函数参数</span></span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, @NotNull Function1 lambda)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">int</span> r = a + b;</span><br><span class="line">   lambda.invoke(r);</span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   sum(<span class="number">1</span>, <span class="number">2</span>, (Function1)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(Function1）null.INSTANCE，是由于反编译器工具在找不到等效的 Java 类时的显示的结果。</p></blockquote><p>我们传递的那个lambda被转换为了Function1类型，它是Kotlin函数的一部分，它以1结尾是因为我们在lambda函数中传递了一个参数。</p><p>再来看一个代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在循环中调用sum函数，每次都传递一个lambda函数打印结果，反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> var2 = <span class="number">10</span>; var1 &lt;= var2; ++var1) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, (Function1)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在每次循环里面都会创建一个Function1的实例对象，这里就是性能的优化点所在，如何优化呢？</p><ul><li>在循环外部建立lambda对象</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l: (r: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> = &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function1 l = (Function1)<span class="keyword">null</span>.INSTANCE;</span><br><span class="line"><span class="keyword">int</span> var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> var3 = <span class="number">10</span>; var2 &lt;= var3; ++var2) &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只会创建一个Function对象，优化了原来在循环内部不停创建对象。</p><ul><li>使用inline</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>) &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">byte</span> var2 = <span class="number">10</span>; var1 &lt;= var2; ++var1) &#123;</span><br><span class="line">     <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">     String var9 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">     System.out.println(var9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda函数对象在编译的时候被拷贝到了调用的地方，避免了创建Fuction对象</p><h3 id="inline使用注意事项"><a href="#inline使用注意事项" class="headerlink" title="inline使用注意事项"></a>inline使用注意事项</h3><ul><li>public inline函数不能访问私有属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> title: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(l: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        println(<span class="string">"Title: <span class="variable">$title</span>"</span>) <span class="comment">// 编译错误: Public-Api inline function cannot access non-Public-Api prive final val title</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的没问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(l: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        println(<span class="string">"Title: <span class="variable">$title</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意程序控制流程</li></ul><p>当使用inline的时候，如果传递给inline函数的lambda，有return语句，那么会导致闭包的调用者也返回。</p><p>看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Start"</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 这个会导致 main 函数 return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)<span class="comment">//不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   String var1 = <span class="string">"Start"</span>;</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">   String var7 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">   System.out.println(var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译之后也能看到，lambda return之后的代码不会执行。（println（“Done”）没有执行）。怎么解决这个问题呢，不要使用return可以使用return@label语法，返回到lambda被调用的地方。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Start"</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)<span class="comment">//会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h2><p>当一个inline函数中，有多个lambda函数做为参数的时候，可以在不想内联的lambda函数前使用noinline声明。不会被拷贝代码到被调用的地方。</p><p>看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> lambda2: (result: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    lambda2.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            &#123; println(<span class="string">"Result is: <span class="variable">$it</span>"</span>) &#125;,</span><br><span class="line">            &#123; println(<span class="string">"Invoke lambda2: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, @NotNull Function1 lambda, @NotNull Function1 lambda2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> r = a + b;</span><br><span class="line">   lambda.invoke(r);</span><br><span class="line">   lambda2.invoke(r);</span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">byte</span> a$iv = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">byte</span> b$iv = <span class="number">2</span>;</span><br><span class="line">   Function1 lambda2$iv = (Function1)<span class="keyword">null</span>.INSTANCE;<span class="comment">//lambda2新建了对象</span></span><br><span class="line">   <span class="keyword">int</span> r$iv = a$iv + b$iv;</span><br><span class="line">   String var8 = <span class="string">"Result is: "</span> + r$iv;</span><br><span class="line">   System.out.println(var8);</span><br><span class="line">   lambda2$iv.invoke(r$iv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译代码中可以看到使用inline声明的lambda形参函数被搬到了被调用的地方，而被noinline声明的函数则生成了Function对象。</p><h2 id="crossinline"><a href="#crossinline" class="headerlink" title="crossinline"></a>crossinline</h2><p>声明一个lambda函数不能有return语句（可以有return@label语句），这样可以避免使用inline时，lambda中的return影响流程导致某些语句没有执行。被crossinline声明的lambda函数如果有return语句会在编译时报错。</p><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, <span class="keyword">crossinline</span> lambda: (<span class="type">result</span>: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> r = a + b</span><br><span class="line">    lambda.invoke(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        println(<span class="string">"Result is: <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 编译错误: return is not allowed here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 inline，内联函数到调用的地方，能减少函数调用造成的额外开销，在循环中尤其有效。</li><li>使用 inline 能避免函数的 lambda 形参额外创建 Function 对象。</li><li>使用 noinline 可以拒绝形参 lambda 内联。</li><li>使用 crossinline 显示声明 inline 函数的形参 lambda 不能有 return 语句，避免lambda 中的 return 影响外部程序流程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin中内联函数的理解&quot;&gt;&lt;a href=&quot;#Kotlin中内联函数的理解&quot; class=&quot;headerlink&quot; title=&quot;Kotlin中内联函数的理解&quot;&gt;&lt;/a&gt;Kotlin中内联函数的理解&lt;/h1&gt;&lt;p&gt;kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。即那些在函数体内会访问到的变量。内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。&lt;/p&gt;
&lt;p&gt;调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针移出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。&lt;/p&gt;
&lt;p&gt;来看一个官方的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(l: &lt;span class=&quot;type&quot;&gt;Lock&lt;/span&gt;, body: ()&lt;/span&gt;&lt;/span&gt; -&amp;gt; T): T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      l.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; body()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          l.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用这个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lock(l, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;do something!&quot;&lt;/span&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;//l是一个Lock对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果只要函数体类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;l.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;do something!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    l.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制大量重复代码，那么有没有一种机制，又能少些重复代码（变成一个可供调用的方法）又不会在调用过程中频繁压栈出栈影响性能呢。有的，这就是kotlin的内联函数inline所拥有的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（三）</title>
    <link href="http://yoursite.com/2020/05/27/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/27/Java线程池实现原理（三）/</id>
    <published>2020-05-27T02:20:00.000Z</published>
    <updated>2020-05-27T02:20:30.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">转自美团技术团队</a></p></blockquote><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>上一期讲了线程池生命周期管理的任务管理，对于线程池来说，任务管理和线程管理是它必须关注的事情，而线程管理比任务管理则更复杂。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="Worker线程（工作线程）"><a href="#Worker线程（工作线程）" class="headerlink" title="Worker线程（工作线程）"></a>Worker线程（工作线程）</h3><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker，先看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker这个线程，实现了Runnable接口，并持有一个线程thread变量，一个初始化的任务firstTask，thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值时非空的，那么线程就会在启动初期立即执行这个任务，<strong>也就是对应核心线程（corePool）创建时的情况</strong>，如果这个值时null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，<strong>也就是非核心线程的创建</strong>。</p><a id="more"></a><p>Worker执行任务的模型如下图所示：</p><p><img src="https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png" alt></p><p>线程池需要管理线程的生命周期，需要在线程池长时间不允许的时候进行回收。<strong><em><em>线程池使用一张Hash表去持有线程的引用</em></em></strong>，这样可以通过添加引用，移除引用这样的操作来控制线程的生命周期，这个时候重要的是如何判断线程是否在运行。 </p><blockquote><p>Worker是通过继承AQS，使用AQS来实现<strong>独占锁</strong>这个功能（每次只能有一个线程能持有锁，是针对共享锁而言的，AQS源码中其内部类Node定义来两个常量SHARED和EXCLUSIVE，分别就是共享模式和独占模式，标示了AQS队列中等待线程的锁获取模式），为的就是实现不可重入的特性去反应线程当前的执行状态。</p></blockquote><p>下图是Java中主流锁的分类：（锁的概念有很多，但是其实各种锁的维度是不同的，后面会详细深入了解）</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="java各种主流锁分类"></p><p>那么如何判断线程是否正在运行呢：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中</li><li>如果正在执行任务，则不应该中断线程</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</li><li>线程池在执行shutdown方法或者tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法使用tryLock方法来判断线程池中的线程是否空闲状态；如果是空闲状态则可以安全回收。 </li></ol><p>会在线程回收过程中也使用到了这种特性，回收过程如下图所示：<br><img src="https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png" alt></p><h3 id="Worker线程增加"><a href="#Worker线程增加" class="headerlink" title="Worker线程增加"></a>Worker线程增加</h3><p>增加线程时通过线程池中addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成，<strong>该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</strong> addWorker方法有两个参数：firstTask，core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空（和Worker线程中的firstTask差不多），<strong><em>core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize（核心线程数），false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize（最大线程数）</em></strong>，其执行流程如下：</p><p><img src="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png" alt></p><h3 id="Worker线程回收"><a href="#Worker线程回收" class="headerlink" title="Worker线程回收"></a>Worker线程回收</h3><p>线程池中线程的销毁依赖于JVM自动的回收，线程池做的工作时根据当前线程池的状态维护一定数量的线程引用<strong>（前面提到的用Hash表）</strong>，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<strong>Worker被创建出来后，就会不断的进行轮训，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。</strong>当Worker无法获取到任务，也就是获取的任务为空时，循环就会结束，Worker会主动消除自身在线程池内的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务（循环）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可以看出线程池回收时在processWorkerExit方法中完成的，下面是线程回收流程图：</p><p><img src="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png" alt></p><p>实时上，在这个方法中，将线程引用移除线程池就已经结束线程池销毁线程的工作了（等待JVM自动回收线程）。但是由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的状态，是否要根据新状态，重新分配线程。</p><h3 id="Woker线程执行任务"><a href="#Woker线程执行任务" class="headerlink" title="Woker线程执行任务"></a>Woker线程执行任务</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法执行过程是：</p><ol><li>while循环不断通过getTask方法来获取任务</li><li>getTask方法总阻塞队列中获取任务</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li><li>执行任务</li><li>如果getTask方法结果为null，则跳出循环，执行processWorkerExit方法，销毁线程</li></ol><p>流程图如下：</p><p><img src="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线程池生命周期管理&quot;&gt;&lt;a href=&quot;#线程池生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;线程池生命周期管理&quot;&gt;&lt;/a&gt;线程池生命周期管理&lt;/h1&gt;&lt;p&gt;上一期讲了线程池生命周期管理的任务管理，对于线程池来说，任务管理和线程管理是它必须关注的事情，而线程管理比任务管理则更复杂。&lt;/p&gt;
&lt;h2 id=&quot;线程管理&quot;&gt;&lt;a href=&quot;#线程管理&quot; class=&quot;headerlink&quot; title=&quot;线程管理&quot;&gt;&lt;/a&gt;线程管理&lt;/h2&gt;&lt;h3 id=&quot;Worker线程（工作线程）&quot;&gt;&lt;a href=&quot;#Worker线程（工作线程）&quot; class=&quot;headerlink&quot; title=&quot;Worker线程（工作线程）&quot;&gt;&lt;/a&gt;Worker线程（工作线程）&lt;/h3&gt;&lt;p&gt;线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker，先看一下源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractQueuedSynchronizer&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread thread;&lt;span class=&quot;comment&quot;&gt;//Worker持有的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runnable firstTask;&lt;span class=&quot;comment&quot;&gt;//初始化的任务，可以为null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Worker这个线程，实现了Runnable接口，并持有一个线程thread变量，一个初始化的任务firstTask，thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值时非空的，那么线程就会在启动初期立即执行这个任务，&lt;strong&gt;也就是对应核心线程（corePool）创建时的情况&lt;/strong&gt;，如果这个值时null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，&lt;strong&gt;也就是非核心线程的创建&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（二）</title>
    <link href="http://yoursite.com/2020/05/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/20/Java线程池实现原理（二）/</id>
    <published>2020-05-20T02:13:00.000Z</published>
    <updated>2020-05-20T02:13:58.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">转自美团技术团队</a></p></blockquote><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由线程池内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><strong>ctl</strong>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含了两部分的信息：运行状态（runState）和线程数量（workerCount），高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。这样做的好处是：源码中经常出现要同时判断上述两种状态的情况，这时候通过一个变量就可以获取，而不用为了维护两者的一致去占用资源锁，然后线程池也提供了很多方法供用户获取当前的运行状态和线程个数。这里都是用位运算，速度会比基本运算快很多。下面代码是一些线程池的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; //计算当前运行状态</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;  //计算当前线程数量</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;   //通过状态和线程数生成ctl</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：</p><table><thead><tr><th>运行状态</th><th>状态描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>能接受新提交的任务，并且也能处理阻塞队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</td></tr><tr><td>STOP</td><td>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程</td></tr><tr><td>TIDYING</td><td>所有任务都已经终止了，workerCount为0</td></tr><tr><td>TERMINATED</td><td>在terminated()方法执行后进入该状态</td></tr></tbody></table><p>其生命周期转换如下所示：</p><p><img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt></p><h2 id="任务管理机制"><a href="#任务管理机制" class="headerlink" title="任务管理机制"></a>任务管理机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。先来介绍一些基本概念：</p><p><strong>corePoolSize:</strong></p><blockquote><p><strong>线程池的基本大小</strong>，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。（线程池本身也要创建线程去执行任务，只是线程池维护了这些创建线程的生命周期，看什么时候需要创建，什么时候要销毁）</p></blockquote><p><strong>maximumPoolSize:</strong></p><blockquote><p><strong>线程池中允许的最大线程数</strong>，线程池中的当前线程数目不会超过该值。若果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largesPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么生活曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()来改变这个最大线程数目。</p></blockquote><p><strong>poolSize:</strong></p><blockquote><p>线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；poolSize也不会超过maximumPoolSize.</p></blockquote><p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在的线程池的运行状态、运行线程数目、运行策略、决定接下来执行的流程，是直接申请线程执行，缓冲到队列中执行，还是直接拒绝执行。参看上图任务分配机制。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount（线程数量） &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列（BlockQueue）没有满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize,且线程池中阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize,并且线程池内的阻塞队列已满，则根据<strong>拒绝策略</strong>来处理该任务，默认的拒绝策略是直接抛出异常。</li></ol><p>其执行流程如下图所示：</p><p><div align="center"><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" alt></div></p><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理</strong>，其中任务的管理相对是一件容易的事情，复杂的是线程的管理，这会涉及到线程池数量，等待/唤醒，同步/锁，线程创建和死亡等问题。线程池中以生产者消费者模式，通过一个阻塞队列来实现将任务和线程两者解耦的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p><p><strong>阻塞队列（BlockingQueue）</strong>是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者时往队列中添加元素的线程，消费者时总队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只是从容器里拿元素。下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p><p><div align="center"> <img src="https://p1.meituan.net/travelcube/f4d89c87acf102b45be8ccf3ed83352a9497.png" alt></div></p><p>使用不同的队列可以实现不一样的任务存取策略，在这里，我们可以再介绍下阻塞队列的成员：(针对不同场景使用)</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁</td></tr><tr><td>LinkedBlockingQueue</td><td>一个由链表结构组成的有界队列，此队列按照先进先出的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong></td></tr><tr><td>PriorityBlockingQueue</td><td>一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序</td></tr><tr><td>DelayQueue</td><td>一个实现了PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素，只有延迟满后才能从队列中获取元素</td></tr><tr><td>SynchronousQueue</td><td>一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个只用场景是在线程池里。Executors.newCachedThreadPool()就使用了这个队列，这个线程池根据需要（新任务到来时）创建新线程，如果有空闲线程则会重复使用，线程空闲了60s后会被回收（需要关注使用场景）</td></tr><tr><td>LinkedTransferQueue</td><td>一个由链表结构组成的无界阻塞队列，相比与其他队列，LinkedTransferQueue队列多了transfer和tryTransfer方法</td></tr><tr><td>LinkedBlockingDeque</td><td>一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半</td></tr></tbody></table><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>由上文的任务分配部分可以知道，任务的执行有两种可能：</p><ol><li>直接创建新的线程来处理。（在线程初始创建的时候）</li><li>线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次从队列中申请任务去执行。（大多数时间线程池工作的情况）</li></ol><p>线程需要从任务缓存模块中不断的取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现。其执行流程如下：</p><p><img src="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png" alt></p><p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态，如果线程池现在不应该持有那么多线程，则返回null。工作线程Worker会不断接收新任务执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。（怎么判断线程是否为可回收）</p><h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量（maximumPoolSize），当线程池任务队列已满，并且线程池中的线程数目达到最大容量，就需要拒绝执行该任务了，采取任务拒绝策略来保护线程池。</p><p>拒绝策略需要实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p><table><thead><tr><th>序号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>ThreadPoolExecutor.AborPolicy</td><td>默认方式，直接丢弃任务并抛出RejectedExecutionException异常。在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现问题</td></tr><tr><td>2</td><td>ThreadPoolExecutor.DiscardPolicy</td><td>丢弃任务，但是不抛出异常。使用此策略，可能使我们无法发现系统的异常状态。</td></tr><tr><td>3</td><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</td></tr><tr><td>4</td><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由调用线程（提交任务的线程）处理该任务，这种情况是需要让所有任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线程池生命周期管理&quot;&gt;&lt;a href=&quot;#线程池生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;线程池生命周期管理&quot;&gt;&lt;/a&gt;线程池生命周期管理&lt;/h1&gt;&lt;p&gt;线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由线程池内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理（一）</title>
    <link href="http://yoursite.com/2020/05/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/13/Java线程池实现原理（一）/</id>
    <published>2020-05-13T02:57:46.030Z</published>
    <updated>2020-05-18T02:49:08.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h2><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，或者涉及到一些复杂线程操作需要重复开启线程。线程过多会带来额外的开销，包括创建线程的开销，调度线程的开销等等，同时也降低了计算机的整体性能。<br>线程池能维护多个线程，等待监督管理分配可并发执行的任务，这种做法一方面避免了处理任务时创建销毁线程开销的代价，另一方面也避免了线程数量膨胀的过分调度问题，保证了对内核的充分利用。<br>Java中对线程池的实现都是基于ThreadPoolExcutor类，它能带来一系列的好处：</p><ul><li><strong>降低资源消耗：</strong> 通过池化技术重复利用已经创建的线程，降低线程创建和销毁造成的损耗</li><li><strong>提高响应速度：</strong> 任务到达时，无需等待线程创建就可以立即执行（前提是线程池中有可用的线程）</li><li><strong>提高线程的可管理性：</strong> 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。不用开发者自己去维护这一整个流程。</li><li><strong>提供更多更强大的功能：</strong> 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><a id="more"></a><h2 id="线程池能解决什么问题"><a href="#线程池能解决什么问题" class="headerlink" title="线程池能解决什么问题"></a>线程池能解决什么问题</h2><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。这种思想也广泛应用于计算机的其它领域中：</p><ul><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。例如Sql连接池</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。例如String。</li></ul><h1 id="Java线程池核心设计于实现"><a href="#Java线程池核心设计于实现" class="headerlink" title="Java线程池核心设计于实现"></a>Java线程池核心设计于实现</h1><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>Java中的线程池核心实现类是ThreadPoolExecutor，首先分析UML类图，如下：</p><p><img src="https://p1.meituan.net/travelcube/912883e51327e0c7a9d753d11896326511272.png" alt="ThreadPoolExcutor UML类图"></p><p>具体分析：</p><p><strong>Executor：</strong> ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦，用户无需关注如何创建线程，如何调度线程来执行任务，用户只需要提供Runable对象，将任务的执行逻辑提交到执行器（Executor）中，由Executor框架完成线程的调配和任务的执行部分。<br><strong>ExecutorService：</strong>接口增加了一些能力：</p><ol><li>扩充执行任务的能力，补充可以为一个或是一批异步任务生成Future方法</li><li>提供了管控线程池的方法，比如停止线程池的运行。</li></ol><p><strong>AbstractExecutorService：</strong>是上层的抽象类，将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法即可。<br><strong>ThreadPoolExecutor：</strong>最下层的实现类实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时还需要管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>下图是ThreadPoolExecutor的运行机制：</p><p><div align="center"><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt></div></p><p>从图中可以看出来，线程池内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p><p>线程池的运行主要分成两部分：<strong>任务管理</strong>，<strong>线程管理</strong>。<br>任务管理：充当生成者的角色，当任务提交后，线程池会判断该任务后续的流转：</p><pre><code>1. 直接申请线程执行该任务2. 缓冲到队列中等待线程执行3. 拒绝该任务</code></pre><p>线程管理：线程管理部分是消费者，他们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务，线程就会被回收。</p><p>下一节继续按照下面三个部分去介绍线程池的运行机制：</p><ol><li>线程池如何维护自身的生命周期</li><li>线程池如果管理任务</li><li>线程池如何管理线程</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h2 id=&quot;线程池是什么&quot;&gt;&lt;a href=&quot;#线程池是什么&quot; class=&quot;headerlink&quot; title=&quot;线程池是什么&quot;&gt;&lt;/a&gt;线程池是什么&lt;/h2&gt;&lt;p&gt;线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，或者涉及到一些复杂线程操作需要重复开启线程。线程过多会带来额外的开销，包括创建线程的开销，调度线程的开销等等，同时也降低了计算机的整体性能。&lt;br&gt;线程池能维护多个线程，等待监督管理分配可并发执行的任务，这种做法一方面避免了处理任务时创建销毁线程开销的代价，另一方面也避免了线程数量膨胀的过分调度问题，保证了对内核的充分利用。&lt;br&gt;Java中对线程池的实现都是基于ThreadPoolExcutor类，它能带来一系列的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗：&lt;/strong&gt; 通过池化技术重复利用已经创建的线程，降低线程创建和销毁造成的损耗&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高响应速度：&lt;/strong&gt; 任务到达时，无需等待线程创建就可以立即执行（前提是线程池中有可用的线程）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高线程的可管理性：&lt;/strong&gt; 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。不用开发者自己去维护这一整个流程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供更多更强大的功能：&lt;/strong&gt; 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaGuide之AQS</title>
    <link href="http://yoursite.com/2020/05/12/JavaGuide%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2020/05/12/JavaGuide之AQS/</id>
    <published>2020-05-12T06:21:34.000Z</published>
    <updated>2020-05-12T07:18:30.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">文章转载：一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</a></p></blockquote><p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p><p>本文关注以下几点内容：</p><ol><li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li><li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li><li>深入理解 Java 线程中断和 InterruptedException 异常</li></ol><p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">上一篇文章中对 AbstractQueuedSynchronizer 的介绍 </a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p><p>其实这篇文章的信息量很大，初学者估计<strong>至少要 1 小时</strong>才能看完，希望本文对得起大家的时间。</p><a id="more"></a><!-- toc --><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 <a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer</a> 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p><p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。</p><p>2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue</p></blockquote><p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/" target="_blank" rel="noopener">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p><p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。</p><p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">  <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p><blockquote><p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p></blockquote><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="condition-2"></p><blockquote><p>这里，我们简单回顾下 Node 的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表</p></blockquote><p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p><ol><li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li><li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li><li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ol><p>上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p><p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 </p><p>这个图看懂后，下面的代码分析就简单了。</p><p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到 condition 的条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class="line">    <span class="comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p><h3 id="1-将节点加入到条件队列"><a href="#1-将节点加入到条件队列" class="headerlink" title="1. 将节点加入到条件队列"></a>1. 将节点加入到条件队列</h3><p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class="line">    <span class="comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t 此时是 lastWaiter，队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。</p><p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p><p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全释放独占锁"><a href="#2-完全释放独占锁" class="headerlink" title="2. 完全释放独占锁"></a>2. 完全释放独占锁</h3><p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p><blockquote><p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">// 那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">// 相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p></blockquote><h3 id="3-等待进入阻塞队列"><a href="#3-等待进入阻塞队列" class="headerlink" title="3. 等待进入阻塞队列"></a>3. 等待进入阻塞队列</h3><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p><h3 id="4-signal-唤醒线程，转移到阻塞队列"><a href="#4-signal-唤醒线程，转移到阻塞队列" class="headerlink" title="4. signal 唤醒线程，转移到阻塞队列"></a>4. signal 唤醒线程，转移到阻塞队列</h3><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。</p><p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待了最久的线程</span></span><br><span class="line"><span class="comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class="line"><span class="comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// true 代表成功转移</span></span><br><span class="line"><span class="comment">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class="line">    <span class="comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class="line">    <span class="comment">// 否则，将 waitStatus 置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class="line">    <span class="comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p><h3 id="5-唤醒后检查中断状态"><a href="#5-唤醒后检查中断状态" class="headerlink" title="5. 唤醒后检查中断状态"></a>5. 唤醒后检查中断状态</h3><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p><p>等线程从挂起中恢复过来，继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断，返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p><p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p><h3 id="6-获取独占锁"><a href="#6-获取独占锁" class="headerlink" title="6. 获取独占锁"></a>6. 获取独占锁</h3><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p><h3 id="7-处理中断状态"><a href="#7-处理中断状态" class="headerlink" title="7. 处理中断状态"></a>7. 处理中断状态</h3><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p><ul><li>0：什么都不做，没有被中断过；</li><li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li><li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。</p></blockquote><h3 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h3><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p><h3 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h3><p>关于 Condition 最后一小节了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，贴一下代码大家就都懂了，我就不废话了。</p><h2 id="AbstractQueuedSynchronizer-独占锁的取消排队"><a href="#AbstractQueuedSynchronizer-独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer 独占锁的取消排队"></a>AbstractQueuedSynchronizer 独占锁的取消排队</h2><p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p><p>接下来，我想说说怎么取消对锁的竞争？</p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的。</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了。</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p><hr><p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p><h2 id="再说-java-线程中断和-InterruptedException-异常"><a href="#再说-java-线程中断和-InterruptedException-异常" class="headerlink" title="再说 java 线程中断和 InterruptedException 异常"></a>再说 java 线程中断和 InterruptedException 异常</h2><p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p><blockquote><p>Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p></blockquote><p>关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">   doWork();</span><br><span class="line">   System.out.println(<span class="string">"我做完一件事了，准备做下一件，如果没有其他线程中断我的话"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。</p></blockquote><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p><p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p><ol><li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p><p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p><blockquote><p>这几个方法的相同之处是，方法上都有: throws InterruptedException </p><p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p></blockquote></li><li><p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p><blockquote><p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p></blockquote></li><li><p>Selector 中的 select 方法，参考下我写的 NIO 的文章</p><blockquote><p>一旦中断，方法立即返回</p></blockquote></li></ol><p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。</p><p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p><h3 id="InterruptedException-概述"><a href="#InterruptedException-概述" class="headerlink" title="InterruptedException 概述"></a>InterruptedException 概述</h3><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p><p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p><p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 </p><p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了。</p><h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p><p>我们经常会这么写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go on</span></span><br></pre></td></tr></table></figure><p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p><p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span></span><br><span class="line">        <span class="comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span></span><br><span class="line">        selfInterrupt();<span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p><p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"> ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。</p><p>欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md" target="_blank" rel="noopener">推荐系列</a><br><a href="https://juejin.im/post/5c6e7dcf51882562547ba9f9#heading-17" target="_blank" rel="noopener">推荐系列2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javadoop.com/post/AbstractQueuedSynchronizer-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章转载：一行一行源码分析清楚 AbstractQueuedSynchronizer (二)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。&lt;/p&gt;
&lt;p&gt;本文关注以下几点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深入理解 ReentrantLock 公平锁和非公平锁的区别&lt;/li&gt;
&lt;li&gt;深入分析 AbstractQueuedSynchronizer 中的 ConditionObject&lt;/li&gt;
&lt;li&gt;深入理解 Java 线程中断和 InterruptedException 异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本上本文把以上几点都说清楚了，我假设读者看过&lt;a href=&quot;http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章中对 AbstractQueuedSynchronizer 的介绍 &lt;/a&gt;，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。&lt;/p&gt;
&lt;p&gt;其实这篇文章的信息量很大，初学者估计&lt;strong&gt;至少要 1 小时&lt;/strong&gt;才能看完，希望本文对得起大家的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技能提升" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot之事务</title>
    <link href="http://yoursite.com/2020/03/03/Spring%20boot%E4%B9%8B%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/03/Spring boot之事务/</id>
    <published>2020-03-03T08:24:41.861Z</published>
    <updated>2020-03-04T08:18:00.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的事务机制"><a href="#Spring的事务机制" class="headerlink" title="Spring的事务机制"></a>Spring的事务机制</h1><p>所有的数据库访问技术都有事务处理机制，这些技术提供了API用于开启事务，提交事务完成数据操作，或者在发生错误的时候回滚数据。Spring的事务机制是用统一的机制来处理不同数据访问技术的事务处理，Spirng的事务机制提供了一个PlatformTransactionManager接口，不同的数据访问技术的事务使用不同的接口实现，如下表：</p><table><thead><tr><th>数据访问技术</th><th>实现</th></tr></thead><tbody><tr><td>JDBC</td><td>DataSourceTransactionManager</td></tr><tr><td>JPA</td><td>JPATransactionManager</td></tr><tr><td>Hibernate</td><td>HibernateTransactionManager</td></tr><tr><td>JDO</td><td>JdoTransactionManager</td></tr></tbody></table><a id="more"></a><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>Spring支持声明式事务，即使用注解来选择需要使用事务的方法，他使用@Transactional注解在方法上表明该方法需要事务支持。备注解的方法在被调用时，Spring开启一个新的事务，当方法无异常运行结束后，Spring会提交这个事务。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveStudent</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，@Transactional注解来自于org.springframework.transcation.annotation包，而不是javax.transaction。</p></blockquote><h2 id="注解事务行为"><a href="#注解事务行为" class="headerlink" title="注解事务行为"></a>注解事务行为</h2><p>@Transactional有如下表所示的属性来定制事务行为</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>Propagation</td><td>事务传播行为</td></tr><tr><td>isolation</td><td>事务隔离级别</td></tr><tr><td>readOnly</td><td>事务的读写性，boolean型</td></tr><tr><td>timeout</td><td>超时时间，int型，以秒为单位。</td></tr><tr><td>rollbackFor</td><td>一组异常类，遇到时回滚。（rollbackFor={SQLException.class}）</td></tr><tr><td>rollbackForClassName</td><td>一组异常类名，遇到回滚，类型为 string[]</td></tr><tr><td>noRollbackFor</td><td>一组异常类，遇到不回滚</td></tr><tr><td>norollbackForClassName</td><td>一组异常类名，遇到时不回滚。</td></tr></tbody></table><h2 id="类级别使用-Transactional"><a href="#类级别使用-Transactional" class="headerlink" title="类级别使用@Transactional"></a>类级别使用@Transactional</h2><p>@Transactional不仅可以注解在方法上，还可以注解在类上。注解在类上意味着此类的所有public方法都开启了事务。如果类级别和方法级别同时使用了@Transactional注解，则使用在类级别的注解会重载方法级别的注解（也就是已类级别的注解最终生效）。</p><h1 id="Spring-Boot的事务支持"><a href="#Spring-Boot的事务支持" class="headerlink" title="Spring Boot的事务支持"></a>Spring Boot的事务支持</h1><ul><li>自动配置的事务管理器，在使用JDBC作为数据库访问技术时（现在一般很少），配置如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(DataSource.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(<span class="keyword">this</span>.dataSource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用JAP作为数据持久化技术时，配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(PlatformTransactionManager.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Bean注解可以参考Springboot注解详解，大意是Springboot启动后扫描的一系列组件的标识</p></blockquote><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>演示如何使用@Transactional使用异常数据回滚与使用异常导致数据不回滚</p><ul><li>实体类（Entity）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据持久化层（Dao层）<br>这里使用的是JPA</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Service层</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">saveStudentWithRollBack</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Service实现层（Impl）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">// 直接注入 StudentRepository 的 bean</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Transactional 注解的 rollbackFor 属性，指定特定异常时，触发回滚</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithRollBack</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        Student s = studentRepository.save(student);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"高斯林"</span>.equals(s.getName()))&#123;</span><br><span class="line">            <span class="comment">//硬编码，手动触发异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"高斯林已存在，数据将回滚"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Transactional 注解的 noRollbackFor 属性，指定特定异常时，不触发回滚</span></span><br><span class="line">    <span class="meta">@Transactional</span>(noRollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        Student s = studentRepository.save(student);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"高斯林"</span>.equals(s.getName()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"高斯林已存在，数据将不会回滚"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller层（接口调用层）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入 studentservice 的 bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试回滚情况</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/withRollBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithRollBack</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.saveStudentWithRollBack(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试不回滚情况</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/withOutRollBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">saveStudentWithoutRollBack</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.saveStudentWithoutRollBack(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试结果：有异常回滚成功后，数据并没有写入数据库；不回滚，有异常数据也会插入数据库</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring的事务机制&quot;&gt;&lt;a href=&quot;#Spring的事务机制&quot; class=&quot;headerlink&quot; title=&quot;Spring的事务机制&quot;&gt;&lt;/a&gt;Spring的事务机制&lt;/h1&gt;&lt;p&gt;所有的数据库访问技术都有事务处理机制，这些技术提供了API用于开启事务，提交事务完成数据操作，或者在发生错误的时候回滚数据。Spring的事务机制是用统一的机制来处理不同数据访问技术的事务处理，Spirng的事务机制提供了一个PlatformTransactionManager接口，不同的数据访问技术的事务使用不同的接口实现，如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据访问技术&lt;/th&gt;
&lt;th&gt;实现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JDBC&lt;/td&gt;
&lt;td&gt;DataSourceTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JPA&lt;/td&gt;
&lt;td&gt;JPATransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hibernate&lt;/td&gt;
&lt;td&gt;HibernateTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDO&lt;/td&gt;
&lt;td&gt;JdoTransactionManager&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring boot" scheme="http://yoursite.com/tags/Spring-boot/"/>
    
      <category term="后台" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
</feed>
