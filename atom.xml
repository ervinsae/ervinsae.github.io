<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-27T16:33:27.302Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>熵</title>
    <link href="http://yoursite.com/2019/04/28/%E7%86%B5/"/>
    <id>http://yoursite.com/2019/04/28/熵/</id>
    <published>2019-04-27T16:12:34.182Z</published>
    <updated>2019-04-27T16:33:27.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是熵"><a href="#什么是熵" class="headerlink" title="什么是熵"></a>什么是熵</h1><p>为了理解熵，必须讲一点物理学。</p><p>19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。<strong>他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。</strong></p><p>后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。</p><a id="more"></a><h1 id="能量的状态"><a href="#能量的状态" class="headerlink" title="能量的状态"></a>能量的状态</h1><p>熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnesha9rj30cs078whz.jpg" alt=""></p><p>物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。</p><p>上图中，能量转化会新生成大量的状态，那么状态多意味着什么呢？</p><h1 id="熵的另外一种解释"><a href="#熵的另外一种解释" class="headerlink" title="熵的另外一种解释"></a>熵的另外一种解释</h1><p>状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：<strong>能量转换会让系统的混乱度增加，熵就是系统的混乱度。</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g2hnhmgjbwj30hg07m754.jpg" alt=""></p><p>熵的英文名为Entropy，我觉得这个翻译的人（胡刚复教授于1923年根据热温商之意首次把entropie译为“熵”）确实很牛逼，翻译的名字很好听。熵低则混乱度低，熵高则混乱度高。</p><p>转换的能量越大，创造出来的新状态就会越多，因此高能量系统不如低能量系统稳定，因为前者的熵较大。而且，<strong>凡是运动的系统都会有能量转换</strong>，热力学第二定律就是在说，<strong>所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。</strong></p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnk9koktj30e8041glh.jpg" alt=""></p><p>冰块是分子的有序排列，能量释放后，变成液体水，分子排列变得无序。那么冰这个系统里的熵就比较低，而水这个系统的熵比较高。</p><h1 id="熵：一种新的世界观"><a href="#熵：一种新的世界观" class="headerlink" title="熵：一种新的世界观"></a>熵：一种新的世界观</h1><p>熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。为什么”世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。</p><p>这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。</p><p>工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。</p><p>我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。我们需要能量，让世界变得有秩序，但这样是有代价的。<strong>物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。</strong></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。（能量守恒定律告诉我们地球的能量肯定是固定的，那么当人类能利用完地球上所有的能量（不一定能利用完），而假设没有外部能量输入，则这个时候的熵如果大到一定程度是不是就是人类悲剧的开始，比如核弹，病毒等。另外一种可能，为了一部分地区的有序和稳定，牺牲了另外一部分地区的有序和生态，而目前好像就是如此，人类破坏了其它生物的家园而将自己的家园建设的越来越好）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是熵&quot;&gt;&lt;a href=&quot;#什么是熵&quot; class=&quot;headerlink&quot; title=&quot;什么是熵&quot;&gt;&lt;/a&gt;什么是熵&lt;/h1&gt;&lt;p&gt;为了理解熵，必须讲一点物理学。&lt;/p&gt;
&lt;p&gt;19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。&lt;strong&gt;他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="热力学第二定律" scheme="http://yoursite.com/tags/%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之集合操作符</title>
    <link href="http://yoursite.com/2019/03/28/Kotlin%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/28/Kotlin之集合操作符/</id>
    <published>2019-03-28T03:10:02.000Z</published>
    <updated>2019-03-29T14:23:11.250Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。</p><a id="more"></a><h2 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h2><p>Kotlin中允许你去将表达式当作参数传递，你也可以直接传递函数，跟Java8一样，如果你把函数转化为一个值的话，可以用成员引用</p><p><code>val getAge = Person::age</code></p><p>这个表达式叫做 成员引用 。它为创建一个直接调用方法或访问属性的函数值提供了一种简短的语法。双冒号将类名从你需要引用的成员（方法或属性）名中分隔出来。它所做的事情跟下面其实是一样的，但是更简洁（少了一个中间变量）：</p><p><code>val getAge = { person: Person -&gt; person.age }</code></p><p>这个成员引用是lambda中的知识点，还有很多用法，需要去理解。</p><h2 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h2><p>找出这个集合中根据某个字段排序最大的值，可以仔细观察下面代码，它们的结果和意思完全一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list操作符之maxby</span><br><span class="line"> */</span><br><span class="line">fun listOperatorMaxBy()&#123;</span><br><span class="line"></span><br><span class="line">//当lambda表达式是最后一个参数的时候可以不要（），直接用&#123;&#125;</span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42))</span><br><span class="line">    println(people.maxBy &#123; it.age &#125;)</span><br><span class="line">    println(people.maxBy &#123; person2 -&gt; person2.age &#125;)</span><br><span class="line">    people.maxBy(Person2::age)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transform-joinString"><a href="#transform-joinString" class="headerlink" title="transform/joinString"></a>transform/joinString</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list操作符之transform/joinToString</span><br><span class="line"> */</span><br><span class="line">fun listOperatorTransform()&#123;</span><br><span class="line"></span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42))</span><br><span class="line"></span><br><span class="line">    val names = people.joinToString(separator = &quot;，&quot;,postfix = &quot;: &quot;,transform = &#123;p: Person2 -&gt;  p.name&#125;)</span><br><span class="line">    val names1 = people.joinToString(&quot;&quot;,&quot;&quot;,&quot;&quot;,1) &#123; p -&gt; p.name &#125;</span><br><span class="line">    println(names)  //Bob，Alice:</span><br><span class="line">    println(names1) //Bob</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>根据条件过滤操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list操作符之filter</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">fun listOperatorFilter()&#123;</span><br><span class="line"></span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42),Person2(&quot;Ervin&quot;,34))</span><br><span class="line"></span><br><span class="line">    //但是要注意，这份代码为每个人重复了最大年龄的查找步骤。所以，如果集合中有100个人，最大年龄的搜索将会执行100次！</span><br><span class="line">    people.filter &#123; it.age == people.maxBy(Person2::age)!!.age &#125;</span><br><span class="line">    //people.filter &#123; it.age == people.maxBy&#123;person2 -&gt;  person2.age&#125;!!.age &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //只计算了一次最大值</span><br><span class="line">    var maxAge = people.maxBy(Person2::age)?.age</span><br><span class="line">    people.filter &#123; it.age == maxAge &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="all，any，count，find等"><a href="#all，any，count，find等" class="headerlink" title="all，any，count，find等"></a>all，any，count，find等</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * list操作符all，any</span><br><span class="line"> * list是否包含了所有这个条件</span><br><span class="line"> */</span><br><span class="line">fun listOperatorAllAny()&#123;</span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42),Person2(&quot;Ervin&quot;,34))</span><br><span class="line"></span><br><span class="line">    val conditions = &#123;p: Person2 -&gt; p.age &gt; 25&#125;</span><br><span class="line">    //全部匹配条件</span><br><span class="line">    people.all(conditions) // false</span><br><span class="line"></span><br><span class="line">    people.all &#123; p:Person2 -&gt; p.age &gt; 23 &#125; // true</span><br><span class="line"></span><br><span class="line">    //有一个匹配条件的</span><br><span class="line">    people.any(conditions) // true</span><br><span class="line"></span><br><span class="line">    //有多少个符合条件的</span><br><span class="line">    people.count(conditions) // 2</span><br><span class="line"></span><br><span class="line">    // 查找哪个是符合条件的(如果有多个元素，函数将返回第一个匹配的元素。</span><br><span class="line">    // 如果没有满足的元素，函数返回 null 。 find 的一个同义词是 firstOrNull 。</span><br><span class="line">    // 如果如能够更加清晰的表达你对想法，你可以使用)</span><br><span class="line">    people.find &#123; p:Person2 -&gt; p.age &gt; 23 &#125; //Alice,Ervin</span><br><span class="line">    people.firstOrNull(conditions)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>分组操作符，想象一下，你需要根据你某些特性来将所有元素分割成不同的组。例如，你想把年龄相同的人放在一组。把这个特性直接作为一个参数进行传递非常方便！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list操作符groupBy</span><br><span class="line"> */</span><br><span class="line">fun listOperatorGroupBy()&#123;</span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24),</span><br><span class="line">        Person2(&quot;Alice&quot;,42),</span><br><span class="line">        Person2(&quot;Ervin&quot;,34),</span><br><span class="line">        Person2(&quot;Anny&quot;,34))</span><br><span class="line"></span><br><span class="line">    people.groupBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line">    //每一组都被保存成一个列表。所以结果的类型为 Map&lt;Int, List&lt;Person&gt;&gt; 。</span><br><span class="line">    // 你可以使用像 mapKeys 和 mapValues 这样的函数对这个映射做更多的修改。</span><br><span class="line">    print(people.groupBy &#123; it.age &#125;[34])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>groupBy之后返回结果是一个Map集合，最后<code>print(people.groupBy { it.age }[34])</code>中[34]其实是输出以34为key的Person。</p><h2 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h2><p>这两个操作符在RxJava中是使用频率很高的操作符，map是对一个基本类型做一个转换，例如string -&gt; int，而flagMap则是将上游的observerable变为另外一个observerable。Kotlin中，map其实也是类型转换的意思，flatmap则是将集合中每个元素映射（map），然后把多个列表合并成一个。最终，其实它是一个集合</p><p>flatMap 函数做了两件事：首先它根据作为参数而给定的函数把每一个元素都变换（或映射）到一个集合中。然后它把多个列表合并为一个。有一个处理字符串的案例很好的解析了这个概念<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g1k0wgeommj30ig0act9c.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * list操作符flatMap</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">fun listOperatorMap()&#123;</span><br><span class="line"></span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42),Person2(&quot;Ervin&quot;,34))</span><br><span class="line">    print(people.map &#123; it.name + &quot;&apos;s&quot; &#125;) //[Bob&apos;s, Alice&apos;s, Ervin&apos;s]</span><br><span class="line">    println(people.flatMap &#123; it.name.toList() &#125;) //[B, o, b, A, l, i, c, e, E, r, v, i, n]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h2><ul><li>集合的序列操作，这个是很有用的东西。一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择，举个例子：<blockquote><p>NOTE 注意 一般来说，无论何时，你在大型集合中有链式操作时，请使用序列。在8.2一节，我们将会讨论为什么在Kotlin中，常规集合的延迟操作是高效的，尽管它会创建中间的集合。但是如果集合包含大量的元素，中间的元素重拍耗时巨大，所以延迟计算更 加可取。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list的序列操作</span><br><span class="line"> *</span><br><span class="line"> * 一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">fun listOperatorSequence()&#123;</span><br><span class="line"></span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24), Person2(&quot;Alice&quot;,42),Person2(&quot;Ervin&quot;,34))</span><br><span class="line"></span><br><span class="line">    //集合的链式调用</span><br><span class="line">    /**</span><br><span class="line">     * Kotlin标准库参考（文档）指出， filter 和 map 都返回一个列表。这意味着这个链式调用将会创建两个列表：一个保存 filter 函数的结果，另一个存储 map 函数的结果。</span><br><span class="line">     * 当原来的列表只有包含两个元素时，这不会有问题。但是如果你有百万个元素时，这会变得非常低效。 为了把它变得更加高效，你可以转换这个操作。</span><br><span class="line">     */</span><br><span class="line">    people.map(Person2::name).filter &#123; it.contains(&apos;A&apos;) &#125;</span><br><span class="line"></span><br><span class="line">    //序列的操作</span><br><span class="line">    /**</span><br><span class="line">     * 没有保存元素的中间集合，对于元素比较大的集合来说，性能会有客观的改善</span><br><span class="line">     */</span><br><span class="line">    people.asSequence()                    //初始集合转化为序列</span><br><span class="line">        .map(Person2::name)</span><br><span class="line">        .filter &#123; it.contains(&apos;A&apos;) &#125;</span><br><span class="line">        .toList()                          //序列转化为集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合本身的操作是实时的，而序列的操作是懒加载式的，下面会详细说明序列的中间操作和最终操作</p><ul><li>序列的中间和最终操作</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1k0xt8zioj30ty06c0tu.jpg" alt=""></p><p>看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * list的序列操作之不同点</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">fun listOperatorSequence1()&#123;</span><br><span class="line"></span><br><span class="line">    //sequence的操作</span><br><span class="line">    //map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</span><br><span class="line">    listOf( 1 , 2 , 3 , 4 )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; print( &quot;map($it) &quot; ); it * it &#125;</span><br><span class="line">        .filter &#123; print( &quot;filter($it) &quot; ); it % 2 == 0 &#125;</span><br><span class="line">        .toList()//最终操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //集合本身操作</span><br><span class="line">    //map(1) map(2) map(3) map(4) filter(1) filter(4) filter(9) filter(16)</span><br><span class="line">    listOf( 1 , 2 , 3 , 4 )</span><br><span class="line">        .map &#123; print( &quot;map($it) &quot; ); it * it &#125;</span><br><span class="line">        .filter &#123; print( &quot;filter($it) &quot; ); it % 2 == 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意看sequence结果：map和filter是交替进行的，每个元素都是先map再filter，这证明了sequence是延迟计算的。而集合本身则是所有元素先map（中间集合），再用中间集合去filter。<strong>sequence中没有最后的toList（最终操作），则什么都不会输出。</strong></p></blockquote><p>最终操作导致所有的延迟计算都被执行了。 还有一个更重要的事要注意，在这个例子中，计算的执行顺序。原始的方法首先将会对每个元素调用 map 函数，然后对结果序列中的每个元素调用 filter 函数。这就是 map 和 filter 在集合上如何工作的。但序列并不是这样的。对于序列来说，所有的操作都会逐个应用于每个元素：处理完第一个元素（映射，然后过滤），然后处理第二个，以此类推。 这个方法意味着如果过早获取结果，某些元素根本不会被变换。我们来看一个有 map 和 find 操作的例子。首先，你把一个数映射为它的平方，之后你查找当中<strong>第一个大于３的元素</strong>（find操作符的作用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun listOperatorSequence2()&#123;</span><br><span class="line"></span><br><span class="line">    println(listOf( 1 , 2 , 3 , 4 )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; 3 &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同样的操作应用于一个集合而不是序列，那么首先会计算 map 的结果，变换初始集合中所有的元素。第二步，在中间集合中发现一个满足预言的元素。使用序列，惰性方法意味着你可以提阿偶偶处理某些元素。下图解释了（使用集合）提前和延迟（使用序列）方式执行这份代码的不同点。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g1k107da1kj30uw0bsq56.jpg" alt=""></p><p>集合提前计算对整个集合运行每一个操作，惰性求值则逐个计算（元素多的时候效率高，性能好）</p><p>再看一个例子啊：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun listOperatorSequence2()&#123;</span><br><span class="line"></span><br><span class="line">    println(listOf( 1 , 2 , 3 , 4 )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; 3 &#125;)</span><br><span class="line"></span><br><span class="line">    val people = listOf(Person2(&quot;Bob&quot;,24),</span><br><span class="line">        Person2(&quot;Alice&quot;,42),</span><br><span class="line">        Person2(&quot;Ervin&quot;,34),</span><br><span class="line">        Person2(&quot;Dan&quot;,34)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先filter有助于减少变换的总次数，</span><br><span class="line">     * 如果先进行 map ，每个元素都会进行变换。</span><br><span class="line">     * 但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</span><br><span class="line">     */</span><br><span class="line">    //先map再过滤</span><br><span class="line">    println(people.asSequence().map(Person2::name).filter&#123; it.length &lt; 4&#125;.toList())</span><br><span class="line">    //println(people.asSequence().map&#123; person: Person2 -&gt; person.name&#125;.filter &#123; it.length &lt; 4 &#125;.toList())</span><br><span class="line"></span><br><span class="line">    //先过滤再映射</span><br><span class="line">    println(people.asSequence().filter&#123;it.name.length &lt; 4&#125;.map(Person2::name).toList())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1k115spoaj30ta09ugng.jpg" alt=""></p><p>先filter有助于减少变换的总次数。如果先进行 map ，每个元素都会进行变换。但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</p><blockquote><p>流 vs 序列 如果你熟悉Java 8的流，你将会看到，（Kotlin的）序列是完全一样的概念。由于Java 8的流在使用旧版本的Java搭建的平台中无法使用，比如Android，所以Kotlin提供了它自己的轮子。如果你把Java 8作为目标平台，流会给你带来一个很大的好处。但是，Kotlin的集合与序列并未实现在多个CPU上并行执行流操作（ map() 或者 filter() ）的能力。你可以基于你面向的Java版本和你的具体要求来选择流和序列。</p></blockquote><p><a href="https://github.com/ervinsae/KotlinLesson" target="_blank" rel="noopener">实例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Android Https证书详解</title>
    <link href="http://yoursite.com/2019/03/21/Android%20Https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/21/Android Https证书详解/</id>
    <published>2019-03-21T02:36:35.000Z</published>
    <updated>2019-03-22T14:37:19.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。</p><a id="more"></a><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS是基于 X.509 认证，他假定所有的数字证书都是由一个层次化的数字证书认证机构发出，即 CA。另外值得一提的是 TLS 是独立于 HTTP 的，任何应用层的协议都可以基于 TLS 建立安全的传输通道，如 SSH 协议。</p><h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><p>Https通信过程中需要交换服务器的公钥，但是怎么确保公钥就是服务器的公钥呢，就需要引入了一个第三方，也就是上面所说的 CA(Certificate Authority)。<br>CA 用自己的私钥签发数字证书，数字证书中包含A的公钥。然后 B 可以用 CA 的根证书中的公钥来解密 CA 签发的证书，从而拿到合法的公钥。那么又引入了一个问题，如何保证 CA 的公钥是合法的呢。答案就是现代主流的浏览器会内置 CA 的证书。我们可以在浏览器中看到Https网站的证书信息：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1by50u8rgj31yn0u0q8g.jpg" alt=""></p><h2 id="中间证书"><a href="#中间证书" class="headerlink" title="中间证书"></a>中间证书</h2><p>当然，现在大多数CA不直接签署服务器证书，而是签署中间CA，然后用中间CA来签署服务器证书。这样根证书可以离线存储来确保安全，即使中间证书出了问题，可以用根证书重新签署中间证书。上图中第三级就是中间证书了。</p><h1 id="Android配置Https"><a href="#Android配置Https" class="headerlink" title="Android配置Https"></a>Android配置Https</h1><p>Android 使用的是 Java 的 API。那么 Https 使用的 Socket 必然都是通过SSLSocketFactory 创建的 SSLSocket，当然自己实现了 TLS 协议除外。目前Android使用的网络通信基本都是Okhttp了，OK默认就支持Https，当你不配置的时候，它默认是支持在Android内部默认安装的100多个证书，在Android设置中可以看到这些内置根证书（会自动更新）。</p><blockquote><p>如果你的后端证书是购买的那么基本就是这些内置根证书中的一种了，你可以不需要任何改动，直接就可以从Http过渡到Https（直接修改BaseURL），但是如果后端使用的是自制证书，那么你就必须要配置了（如果不配置会报证书锚点找不到的错误）。</p></blockquote><ul><li>SSLSocketFactory</li></ul><p>创建SSL的工厂类，默认是这样实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> private synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">    sslContext.init(null, null, null);</span><br><span class="line">    return defaultSslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line">  &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">    throw new AssertionError(); // The system has no TLS. Just give up.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TrustManager</li></ul><p>上文说了，SSL 握手开始后，会校验服务器的证书，那么其实就是通过 X509ExtendedTrustManager 做校验的，更一般性的说是 X509TrustManager :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The trust manager for X509 certificates to be used to perform authentication</span><br><span class="line"> * for secure sockets.</span><br><span class="line"> */</span><br><span class="line">public interface X509TrustManager extends TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">            throws CertificateException;</span><br><span class="line"></span><br><span class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">            throws CertificateException;</span><br><span class="line"></span><br><span class="line">    public X509Certificate[] getAcceptedIssuers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么最后校验服务器证书的过程会落到 checkServerTrusted 这个函数，如果校验没通过会抛出 CertificateException 。很多博客说，配置 SSL 差不多是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        sslContext.init(null, new TrustManager[]&#123;</span><br><span class="line">                new X509TrustManager() &#123;</span><br><span class="line">                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        return new X509Certificate[0];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, null);</span><br><span class="line">        return sslContext.getSocketFactory();</span><br><span class="line">    &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是信任所有证书的，包括自制证书，相当于客户端不会去检查证书的签名。这么做毫无安全性可言，一般不要这么做</p><h2 id="SSL的配置"><a href="#SSL的配置" class="headerlink" title="SSL的配置"></a>SSL的配置</h2><p>Android中SSL的配置，可以不配置（系统会默认信任Android内置证书），但是如果用系统默认的 SSL，那么就是假设一切 CA 都是可信的。可往往 CA 有时候也不可信，比如某家 CA 被黑客入侵什么的事屡见不鲜。虽然 Android 系统自身可以更新信任的 CA 列表，以防止一些 CA 的失效。那么为了更高的安全性，我们希望指定信任的锚点（我们信任的证书），可以类似采用如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Ervin on 2017/3/14.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class CertificationFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static SSLContext getSLLContext(Context context)&#123;</span><br><span class="line">        SSLContext sslContext = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //取得本地证书的流</span><br><span class="line">            CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">            InputStream cerInputStream = context.getAssets().open(&quot;root.crt&quot;);</span><br><span class="line">            Certificate ca = cf.generateCertificate(cerInputStream);</span><br><span class="line">                       </span><br><span class="line">           //创建Keystore包含我们的证书</span><br><span class="line">            String keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">            keyStore.load(null, null);</span><br><span class="line">            keyStore.setCertificateEntry(&quot;ca&quot;, ca);</span><br><span class="line"></span><br><span class="line">            // 创建一个 TrustManager 仅把 Keystore 中的证书 作为信任的锚点</span><br><span class="line">            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">            tmf.init(keyStore);</span><br><span class="line">            TrustManager[] trustManagers = tmf.getTrustManagers();</span><br><span class="line">            </span><br><span class="line">            // 用 TrustManager 初始化一个 SSLContext</span><br><span class="line">            sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            sslContext.init(null, trustManagers, null);</span><br><span class="line">        &#125; catch (CertificateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return  sslContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Okhttp中开启配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">httpClient = new OkHttpClient</span><br><span class="line">                    .Builder()</span><br><span class="line">                    .addInterceptor(new TokenValidInterceptor(this.context))</span><br><span class="line">                    .addInterceptor(new HttpRespV3ConvertInterceptor())</span><br><span class="line">                    .addInterceptor(loggingInterceptor)</span><br><span class="line">                    //开启SSL配置</span><br><span class="line">                    .sslSocketFactory(CertificationFactory.getSLLContext(this.context).getSocketFactory())</span><br><span class="line">                    .connectTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>这样的话Okhttp会只<strong>信任“root.crt”以及被它签发的证书</strong>才会被信任。这里有个地方要注意：这里的root.crt在我的项目中代表了CA的根证书（第一级的证书，也许也是中间证书，过期时间比较久），还有一种证书是用这个root去签发的，在你购买证书后会给你去服务器配置的。因为在实际情况中，一般购买的证书（子证书）有效期都是2年左右，如果客户端信任这个子证书那么也就是2年后证书过期，你的APP就不能用了，因此我们考虑了使用根证书，（根证书默认会信任他以及他所签发的证书），这样子证书到期后，只要还用这家CA的证书签发一个子证书，APP还是会继续信任。这样比起信任100多个根证书，我只信任一个要安全得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Https" scheme="http://yoursite.com/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>QUANTUMULT的配置</title>
    <link href="http://yoursite.com/2019/03/18/Quantumult%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/18/Quantumult配置/</id>
    <published>2019-03-18T15:43:00.000Z</published>
    <updated>2019-03-22T14:51:25.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。</p><a id="more"></a><blockquote><p>老板由于已知的原因，时隔半年回归。寄语：“Whatever does not kill us makes us stronger.” - Friedrich Nietzsche</p></blockquote><p>这里Quantumul讲的很详细，这里就不多啰嗦了，后续还会更新最新的FQ技术及方法。</p><p>Mac：shadowsocksR-NG-R，ClashX<br>IOS：quantumul,shadowrockets,surge<br>Android: SSR,ClashNG,…</p><p><a href="https://withdewhua.space/2018/09/14/Quantumult_1/" target="_blank" rel="noopener">配置教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="GFW" scheme="http://yoursite.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>alfred的简单配置</title>
    <link href="http://yoursite.com/2019/03/14/alfred%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/14/alfred简单配置/</id>
    <published>2019-03-14T15:19:27.085Z</published>
    <updated>2019-03-15T16:03:14.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><p>alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧</p><p><img src="https://www.hi-linux.com/img/linux/alfred19.png" alt=""></p><a id="more"></a><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>从官网就可能下载使用Alfred了，但是想用他的完整功能，比如workflow就要激活powerpack了，在天朝这些都不是问题，推荐几个Mac软件搬运工网站：</p><ul><li><p><a href="https://xclient.info/?t=6dacdaeb762299d9df9fac82782e70febed6d9c3" target="_blank" rel="noopener">大名鼎鼎的xclinet</a></p></li><li><p><a href="https://www.waitsun.com/" target="_blank" rel="noopener">域名很黄的waitsun</a></p></li><li><p><a href="http://www.orsoon.com/" target="_blank" rel="noopener">未来软件园</a></p></li></ul><p>等等吧，收藏夹里一堆。</p><h2 id="基础功能介绍"><a href="#基础功能介绍" class="headerlink" title="基础功能介绍"></a>基础功能介绍</h2><p>首先是启动alfred了，一般为避免和spotlight快捷键冲突，会将alfred启动快捷键设置为：double cmd。这样也确实挺方便的</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>这个是最简单最基础的功能了，alfred自带了一些查询，例如：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13w98d0wmj30we0rqkbi.jpg" alt=""></p><p>只要输入关键字，就可以打开浏览器Google一下你要的内容了，alfred会自动匹配所有和关键字相关的内容（10个）给你选择。你也可以自己设置自定义的搜索规则：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g13wezhsslj31880u0x51.jpg" alt=""></p><h3 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h3><p>剪切板功能也是一个很赞的功能，我的使用频率也是最高的之一，一般快捷键设置为：cmd+option+C。会弹出最近你所复制的文本，图片，甚至文件。如果一段文字你需要多次用到，那么这个将会大大提高你的效率。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13wiqzej1j30w00nuaop.jpg" alt=""></p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>这个功能主要是你可以使用alfred的感觉真关机，待机，锁定屏幕等等。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g13wkaz6fqj30w409swko.jpg" alt=""></p><h3 id="Terminal-shell"><a href="#Terminal-shell" class="headerlink" title="Terminal/shell"></a>Terminal/shell</h3><p>这个是由于我在Mac上使用的是程序员专用的iTerm命令行工具，然后Alfred可以通过“&gt;”来开启命令行（很好的功能），但是它默认使用的是mac系统自带的terminal，如果你想开启iTerm，那么：</p><blockquote><p>Preference - Terminal/shell - Application:custom</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//适用于iTerm2</span><br><span class="line">on alfred_script(q)</span><br><span class="line">if application &quot;iTerm2&quot; is running or application &quot;iTerm&quot; is running then</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to false</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to true</span><br><span class="line">end try</span><br><span class="line">tell current session of the first window</span><br><span class="line">if onlywindow is false then</span><br><span class="line">tell split vertically with default profile</span><br><span class="line">write text q</span><br><span class="line">end tell</span><br><span class="line">end if</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">else</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">end try</span><br><span class="line">tell the first window</span><br><span class="line">tell current session to write text q</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">end if</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><h2 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h2><p>这个是收费功能，也是alfred可以拥有无限可能的功能，他类似于IOS中的捷径（其实原来也叫workflow，被Apple收编后叫捷径）</p><p>下面简单介绍几个有用的workflow：</p><h3 id="New-File"><a href="#New-File" class="headerlink" title="New File"></a>New File</h3><p>mac上新建文件是个比较蛋痛的事，一般人还新建不来。如果有这个就好办了。该插件默认启动关键字是：new。默认情况下，你可以直接新建 TXT、MD、自定义文件类型这三种类型的文件和目录。其中 TXT、MD 格式也是比较常用的文本格式，插件就将这两种类型的文件直接作为了默认文件类型。真是非常贴心！</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13wwgsd46j30w20ikdpy.jpg" alt=""></p><h3 id="TerminalFinder"><a href="#TerminalFinder" class="headerlink" title="TerminalFinder"></a>TerminalFinder</h3><p>看名字就知道是Finder和Terminal互相切换的，有时候我们在Finder中想开启命令行，还有时候在命令行中打开了一个目录又想在Finder中显示。用这个吧。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g13wz57gcaj31q20cy45w.jpg" alt=""></p><h3 id="有道词典"><a href="#有道词典" class="headerlink" title="有道词典"></a>有道词典</h3><p>系统自带的词典，查找起来不太方便，alfred的workflow中使用yd关键字就能英汉互查</p><p><img src="https://static.hufangyun.com/hexo/img/alfred-youdao.jpg?imageView2/2/w/500" alt=""></p><blockquote><p>好用的workflow其实有很多，需要大家去发掘去使用，但是另一方面我们其实也用不到那么多功能，所以还是适合自己的才是最好的。</p></blockquote><h3 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h3><p>workflow插件是傻瓜式的，直接下载.workflow文件下来后，点击就能安装了。下面给几个下载workflow的网站：</p><p><a href="http://www.packal.org/" target="_blank" rel="noopener">Packal</a></p><p><a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">alfredflow</a></p><p>还有就是Google了。。。。。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>最后，如果你有多台mac之间都在用alfred，你想使用一个配置文件，那么你就要使用同步功能了。坑爹的是，aflred默认是不同步的（连iCloud都不支持），它只是把配置文件保存在本地，那么怎么才能同步呢，上图：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g13x8udixpj319j0u01j0.jpg" alt=""></p><p>说白了也就是自己把配置文件上传到云端，多端同步。</p><p>最后，其实这个blog只是我使用的一个简单介绍或者记录，alfred还有很多高级功能没有去涉及，还是希望能帮助到别人吧。生命在于折腾！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Alfred&quot;&gt;&lt;a href=&quot;#Alfred&quot; class=&quot;headerlink&quot; title=&quot;Alfred&quot;&gt;&lt;/a&gt;Alfred&lt;/h1&gt;&lt;p&gt;alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/alfred19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="alfred，效率" scheme="http://yoursite.com/tags/alfred%EF%BC%8C%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Git的常规配置</title>
    <link href="http://yoursite.com/2019/02/28/git%E7%9A%84%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/28/git的常规配置/</id>
    <published>2019-02-28T08:16:18.972Z</published>
    <updated>2019-02-28T08:20:10.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h1><p>git的全局和单个仓库的用户名和邮箱的配置</p><ul><li>全局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;email&quot;</span><br><span class="line">//查询</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>某个仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;name&quot;</span><br><span class="line">git config user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>未完待续，持续更新。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mark&quot;&gt;&lt;a href=&quot;#Mark&quot; class=&quot;headerlink&quot; title=&quot;Mark&quot;&gt;&lt;/a&gt;Mark&lt;/h1&gt;&lt;p&gt;git的全局和单个仓库的用户名和邮箱的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android后期开发的几个方向</title>
    <link href="http://yoursite.com/2019/02/25/Android%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E5%90%91/"/>
    <id>http://yoursite.com/2019/02/25/Android开发的几个方向/</id>
    <published>2019-02-25T04:05:41.864Z</published>
    <updated>2019-02-26T06:51:36.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。</p><a id="more"></a><h1 id="移动端未来的几个方向"><a href="#移动端未来的几个方向" class="headerlink" title="移动端未来的几个方向"></a>移动端未来的几个方向</h1><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>目前我们项目已经在尝试走组件化和插件化，前两年，插件化火起来了，为什么火呢，因为可以实现Android不用发布版本就可以热更新，但是插件化有自己的问题，就是兼容性。Android机型太多（马上要出折叠屏了），插件化框架难免要涉及到系统API的hook，兼容性问题就出现了，开发者会莫名其妙碰到各种错误，随着Android版本迭代，插件化这条路越来越不好走，Android P给了开发者一个信号，不能再随便hook系统API了，Google要开始整顿了。然后，另外一个动态化就是Hybrid开发了，利用H5和原生混合开发（目前最为流行的开发方式），例如老牌的Cordova，Facebook的React-Native（通过Jscore进行js解析，使得原生View进行渲染，提供桥机制调用原生的能力）。RN是第一个真正的高性能动态框架，它的出现让Web前端和客户端的界限变得模糊。随之而来的是各个大公司的自研框架，例如阿里巴巴的Weex和美团的Picasso框架，RN只提供了Android和IOS的支持，Weex扩展了思路，提供了Web端的支持，一个是React语法糖，一个Vue语法糖。另外，Google自己在2018年下半年正式推出了自己的跨平台方案—Flutter（前面Blog已经写过），通过Dart编写APP，然后编译成机器码运行在IOS和Android上，对开发者最好的是Hot reload，而且做到了原生跨平台。</p><h2 id="移动端机器学习"><a href="#移动端机器学习" class="headerlink" title="移动端机器学习"></a>移动端机器学习</h2><p>毫无疑问，移动端机器学习从2017年年底就开始火起来了，TensorFlow 也推出了移动端框架，很多应用都开始在移动端部署机器学习模型，例如相机类应用（FaceU）、电商类应用（唯品会）等，包括离线的机器学习。<br>如果深挖这个方向，我觉得十年内不会被淘汰。当然了，难度也不小。</p><h2 id="AR和VR"><a href="#AR和VR" class="headerlink" title="AR和VR"></a>AR和VR</h2><p>从支付宝的 AR抢红包、QQ的AR踢球等玩法被越来越多的人体验，AR走进了人们的视野。对于广告引流玩法来说，AR无疑是能带来巨大收益的。那么开发AR引擎的移动开发者自然成了香饽饽，目前AR主要应用的领域是广告变现，不过很多公司也找到了AR的一些落地场景，如果是研究OpenGL，计算机图形学的移动开发者，可以往AR引擎开发方向发展，非常有前景。</p><h2 id="移动端音视频"><a href="#移动端音视频" class="headerlink" title="移动端音视频"></a>移动端音视频</h2><p> 这个领域最火的就是抖音了，还有各种相机，图片应用等都需要音视频开发领域的专业开发人员，图像处理，滤镜，剪裁等，研究OpenGL，计算机图形学的移动开发者在这个领域也有很大的优势</p><h2 id="移动端区块链"><a href="#移动端区块链" class="headerlink" title="移动端区块链"></a>移动端区块链</h2><p>在人人都知道比特币的时候，背后的区块链技术也得到了大家的拥护，区块链应用目前最多的还是数字钱包，但是未来应该会有更多的落地方式，例如Status。如果有移动开发同学对区块链方向感兴趣的，可以开始研究起来了。如果要学习智能合约开发的同学，我推荐一个非常好的网站：Cryptozombies，绝对是入门 solidity 智能合约开发的精品。</p><p>目前移动端的区块链人才还不多，各大公司也没有在招，但是两三年内，应该就会爆发了，现在还在探索落地场景的阶段，也给了对区块链技术感兴趣的移动开发同学学习的时间。改变世界的技术了解一下？</p><h2 id="移动端基础框架"><a href="#移动端基础框架" class="headerlink" title="移动端基础框架"></a>移动端基础框架</h2><p>UI未来可能都会被动态化技术接管，但是移动基础框架不会。一个APP总要有网络请求，日志处理，ORM，缓存，PUSH等框架，这部分和UI关系不大，但是是组成APP不可或缺的部分。框架其实就是轮子，我们用轮子用的很溜并不代表你的代码能力很溜，而是人间写的轮子很溜，好的轮子就是无论开发者代码能力好坏，写出来的功能和性能都是差不多的，比如Retrofit，OKhttp等。在这些框架基础上P5和P7写的代码不会有多大差别。然后，轮子总要有人写，而且大公司的需求可能开源的轮子不满足，这时候就要自创轮子了。写轮子就需要开发者的知识深度和广度了，需要沉淀和学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android动画总结</title>
    <link href="http://yoursite.com/2019/02/16/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/16/Android动画总结/</id>
    <published>2019-02-16T07:55:33.060Z</published>
    <updated>2019-02-27T14:43:44.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">lottie</a>,<a href="https://github.com/yyued/SVGAPlayer-Android" target="_blank" rel="noopener">SVGA</a> 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。)</p><a id="more"></a><h1 id="动画分类"><a href="#动画分类" class="headerlink" title="动画分类"></a>动画分类</h1><h2 id="各自特点及区别"><a href="#各自特点及区别" class="headerlink" title="各自特点及区别"></a>各自特点及区别</h2><p>Android动画主要分为视图动画和属性动画，视图动画只有透明度，旋转，平移，伸缩四种，而属性动画则是只要是对象的属性且有setter该属性的方法就可以对该属性执行一种动态变化效果。视图动画主要是使用<strong>Animation</strong>，组合动画使用AnimationSet，而属性动画主要是<strong>Animator</strong>，组合使用AnimatorSet。视图动画主要就是四种操作，对对象的颜色，背景等就无能为力了。相对来说，属性动画会更精细点，能实现更多更好的效果。</p><h2 id="视图动画"><a href="#视图动画" class="headerlink" title="视图动画"></a>视图动画</h2><p>视图动画很早就出现在Android中，主要在android.view.animation包下面，这里可以看到主要是对View进行操作的，里面有很多的类帮助我们实现一些简单动画效果，如对view进行移动，缩放，旋转，淡入淡出等，并且我们可以借助AnimationSet将这些动作组合起来</p><ul><li>补间动画（Tween Animation）</li></ul><table><thead><tr><th>名称</th><th>原理</th><th>对应Animation 子类</th></tr></thead><tbody><tr><td>平移动画</td><td>移动视图位置</td><td>TranslateAnimation</td></tr><tr><td>缩放动画</td><td>放大缩小视图</td><td>ScaleAnimation</td></tr><tr><td>旋转动画</td><td>旋转视图位置</td><td>RotateAnimation</td></tr><tr><td>透明度动画</td><td>改变视图透明度</td><td>AlphaAnimation</td></tr></tbody></table><ul><li>逐帧动画（Frame Animation）</li></ul><p>这个类似动画片，一帧一帧播放，每一帧是一张图片，按顺序去播放一组预先定义好的图片，简单方便，但是容易OOM，占资源</p><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画在Android3.1的时候才引入到Android中，主要在android.animator包下面。属性动画机制已经不仅仅是针对View来设计了（看包名就知道），也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不在是视觉上的动画效果了。它实际上是一种不断对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性（真的改变了对象属性）。属性动画的工作原理和逻辑：</p><p><img src="http://upload-images.jianshu.io/upload_images/944365-16a162a731f548d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>步骤2中的插值器，默认会有一些系统自带的插值器，如下表，表示的是初始值到结束值的一个变化关系，关系到动画的一个显示效果。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>插值器（Interpolator）</td><td>值的变化模式（匀速,加速）</td></tr><tr><td>估值器（TypeEvaluator）</td><td>决定值的具体变化数值</td></tr></tbody></table><table><thead><tr><th>插值器名称</th><th>描述</th></tr></thead><tbody><tr><td>AccelerateDecelerateInterpolator</td><td>先加速再减速</td></tr><tr><td>AccelerateInterpolator</td><td>先加速再一直加速</td></tr><tr><td>AnticipateInterpolator</td><td>先往后一下，再加速往前</td></tr><tr><td>AnticipateOvershootInterpolator</td><td>先往后一下，再一直往前超过终点，再往回收一下。</td></tr><tr><td>BounceInterpolator</td><td>最后会回弹一下</td></tr><tr><td>CycleInterpolator</td><td>重复几次，感觉就是环形进度条那种，具体我还没试过</td></tr><tr><td>DecelerateInterpolator</td><td>一直减速</td></tr><tr><td>LinearInterpolator</td><td>线性匀速</td></tr><tr><td>OvershootInterpolator</td><td>到了终点之后，超过一点，再往回走。有个参数可以定义，超过的力度。</td></tr></tbody></table><h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><ul><li><p>定义：通过不断控制值的变化，再不断手动赋值给对象的属性，从而实现动画效果。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/944365-d74ed6378954939b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>用法</p></li></ul><pre><code></code></pre><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator<br>测试Hexo本地是否要保留原文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：&lt;a href=&quot;https://github.com/airbnb/lottie-android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lottie&lt;/a&gt;,&lt;a href=&quot;https://github.com/yyued/SVGAPlayer-Android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SVGA&lt;/a&gt; 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。)&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>SBT环境搭建</title>
    <link href="http://yoursite.com/2019/01/30/SBT%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/30/SBT环境配置/</id>
    <published>2019-01-30T08:32:09.016Z</published>
    <updated>2019-01-30T09:25:18.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol><li>由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做个记录（凑数）。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li>前提<br>必须要装JDK，sbt也是运行在JVM上的，所以需要java的环境，没有环境sbt会提示你先要装JDK，然后就是配置好环境变量了。</li><li><p>下载IDE<br>现在宇宙IDE非IDEA莫属了（VS Code表示不服），前后端主要的平台都支持，AndroidStudio就是基于这个IDE写的。咱也熟。下载完成后下载插件：Scala和Sbt。下载完成后重启IDE，导入Sbt项目后，会自动在右侧多了个sbt编译按钮<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzopvtb2v6j30l40ocacg.jpg" alt=""></p></li><li><p>下载sbt sdk<br>这里要下载sbt最新版本（好像是1.2.+），配置好环境变量，在命令行测试命令：sbt或者sbt test。这样在user目录下会生成一个.sbt目录。</p></li></ul><ul><li>配置私服访问<br>一般上面三步基本就能配好环境。直接导入代码就可以使用sbt编译了，但是我们的后端很多依赖包是在自己公司搭建的私服上的，所以还需要配置访问私服的密钥和路径。（问人的，这个貌似很多文章都找不到），生成两个文件（一个私服仓库的路径文件，一个授权访问私服的文件）见图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzoqdm8mctj30dc0e0gmc.jpg" alt=""><br>需要放在上面所说的.sbt文件中。</li></ul><blockquote><p>这里还有一个很坑人的地方，导致你编译失败，代码一片红，因为我们在上面的私服仓库路径文件里面配置的第三方依赖包和我们自己仓库的依赖包都会同时下载，但是基于经验判断我们下载自己仓库的包的时候先决条件是需要把第三方包都下载好，这样如果同时下载会导致所有包都下不下来（坑），这时候就需要根据经验先下载一些优先的第三方包，注释掉另外一些路径，等下载完成后再打开这些路径，接着下载所需的私有仓库中的包。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="scala，sbt" scheme="http://yoursite.com/tags/scala%EF%BC%8Csbt/"/>
    
  </entry>
  
  <entry>
    <title>kotlin常用操作符</title>
    <link href="http://yoursite.com/2019/01/03/Kotlin%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/01/03/Kotlin中常见的操作符/</id>
    <published>2019-01-03T06:43:00.000Z</published>
    <updated>2019-01-03T06:51:56.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="？操作符"><a href="#？操作符" class="headerlink" title="？操作符"></a>？操作符</h3><p>表示这个对象可能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在变量后面加？，代表这个变量可以为空</span><br><span class="line">var name: String? = &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果str不能转为Int类型，则返回null</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？</span><br><span class="line">b?.length</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="?:操作符"></a>?:操作符</h3><p>如果操作符左边表达式不为空用左边表达式结果，为空则用右边的值。类似三元运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val l: Int = if(b!=null) b.length else -1</span><br><span class="line">// 除了完整的if表达式，这个还可以用Elvis操作符来表示：</span><br><span class="line">val l = b?.length ?: -1</span><br><span class="line">// 如果?: 左侧表达式非空，elvis操作符就返回左侧表达式的值，否则返回右侧的值。</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：当且仅当左侧为空时，才会对右侧表达式求值。</p></blockquote><h3 id="！！操作符"><a href="#！！操作符" class="headerlink" title="！！操作符"></a>！！操作符</h3><p>一定是非空的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这会返回一个非空的b值，或者如果b为空，就会抛出空指针异常</span><br><span class="line">var l = b!!.length</span><br></pre></td></tr></table></figure><h3 id="与"><a href="#与" class="headerlink" title="== 与 ==="></a>== 与 ===</h3><p>这个类似java中的 == 和 .equals()</p><p>== 判断值是否相等，=== 判断值及引用是否完全相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val num: Int = 128;</span><br><span class="line">val a:Int? = num</span><br><span class="line">val b:Int? = num</span><br><span class="line">println(a == b) //true</span><br><span class="line">print(a === b) //false</span><br></pre></td></tr></table></figure><h3 id="符号以及-in-和-in-操作符"><a href="#符号以及-in-和-in-操作符" class="headerlink" title="..符号以及 in 和 !in 操作符"></a>..符号以及 in 和 !in 操作符</h3><p>..代表从x到y，==包括x和y,这是一个闭区间==运算符，而until则是半闭区间运算符，代表从a到b范围内所有的值，==包括a和不包括b==。<br>in代表在一个区间中，！in代表不在一个区间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i in 1..10)&#123; //等价于 1 &lt;= i &lt;= 10</span><br><span class="line">    println(i) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用until函数，创建一个不包括其结束元素的区间</span><br><span class="line">for(i in 1 until 10)&#123;&#125; // i in [1,10)</span><br></pre></td></tr></table></figure><h3 id="downTo-函数"><a href="#downTo-函数" class="headerlink" title="downTo()函数"></a>downTo()函数</h3><p>倒叙遍历，区间内循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(i in 4 downTo 1)&#123;&#125; //print(i) -- 4321</span><br></pre></td></tr></table></figure><h3 id="step函数"><a href="#step函数" class="headerlink" title="step函数"></a>step函数</h3><p>可以进行任意数量的迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..4 step 2) print(i) // prints &quot;13&quot;</span><br><span class="line">for (i in 4 downTo 1 step 2) print(i) // prints &quot;42&quot;</span><br></pre></td></tr></table></figure><h3 id="符号"><a href="#符号" class="headerlink" title="::符号"></a>::符号</h3><p>得到类的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(this@KotlinActivity, MainActivity::class.java))</span><br></pre></td></tr></table></figure><h3 id="符号-1"><a href="#符号-1" class="headerlink" title="@符号"></a>@符号</h3><p>限定this的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    inner class State&#123;</span><br><span class="line">        fun getUser(): User&#123;</span><br><span class="line">            //返回User</span><br><span class="line">            return this@User</span><br><span class="line">        &#125;</span><br><span class="line">        fun getState(): State&#123;</span><br><span class="line">            //返回State</span><br><span class="line">            return this@State</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为标签<br>跳出双层循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loop@ for (itemA in arraysA) &#123;</span><br><span class="line">     var i : Int = 0</span><br><span class="line">      for (itemB in arraysB) &#123;</span><br><span class="line">         i++</span><br><span class="line">         if (itemB &gt; 2) &#123;</span><br><span class="line">             break@loop</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         println(&quot;itemB:$itemB&quot;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==命名函数自定义标签：==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun fun_run()&#123;</span><br><span class="line">    run &#123;</span><br><span class="line">        println(&quot;lambda&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    var i: Int = run &#123;</span><br><span class="line">        return@run 1</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;$i&quot;)</span><br><span class="line">    //匿名函数可以通过自定义标签进行跳转和返回</span><br><span class="line">    i = run (outer@&#123;</span><br><span class="line">        return@outer 2</span><br><span class="line">    &#125;)</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从forEach跳出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun forEach_label(ints: List&lt;Int&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    var i =2</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        //forEach中无法使用continue和break;</span><br><span class="line">//        if (it == 0) continue //编译错误</span><br><span class="line">//        if (it == 2) /*break //编译错误 */</span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">     run outer@&#123;</span><br><span class="line">         ints.forEach &#123;</span><br><span class="line">             if (it == 0) return@forEach //相当于在forEach函数中continue,实际上是从匿名函数返回</span><br><span class="line">             if (it == 2) return@outer //相当于在forEach函数中使用break,实际上是跳转到outer之外</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    if (i == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        //每个函数的名字代表一个函数地址，所以函数自动成为标签</span><br><span class="line">        return@forEach_label //等同于return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="as-操作符"><a href="#as-操作符" class="headerlink" title="as?操作符"></a>as?操作符</h3><p>当使用as转型的时候，可能经常出现ClassCastException。所以，现在可以用==as?安全转型==，当转型不成功的时候，它会返回null。</p><blockquote><p>注意：在使用intent传值的时候，会出现空字符串不能用as强制转型，应该使用as?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val m: Int? = a as? Int</span><br></pre></td></tr></table></figure><h3 id="冒号："><a href="#冒号：" class="headerlink" title="冒号："></a>冒号：</h3><p>用于类的继承，变了的定义</p><ol><li>类型和超类型之间的冒号前要有一个空格</li><li>实例和类型之间的冒号前不能用空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义全局变量时</span><br><span class="line">var str: String? = null</span><br><span class="line"></span><br><span class="line">//类的继承与变量定义</span><br><span class="line">class TestActivity&lt;T : Serializable&gt;(str: String) : Activity&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型判断符is"><a href="#类型判断符is" class="headerlink" title="类型判断符is"></a>类型判断符is</h3><p>检查某个实例是否是某个类型，如果判断出属于某个类型，那么判断后的分支中可以直接可当该类型使用，==无需显示转换==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">        //obj在&amp;&amp;右边自动动转换成&quot;String&quot;类型</span><br><span class="line">        if (obj is String &amp;&amp; obj.length &gt; 0)</span><br><span class="line">            return obj.length</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="操作符-2"><a href="#操作符-2" class="headerlink" title="$操作符"></a>$操作符</h3><p>字符串可以包含模板表达式，及一小段代码，会求值并把结果包含到字符串中。模板字符串以美元符号$开头，由一个简单的名字构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val value:Int=5;</span><br><span class="line">val str:String=&quot;the value is $value&quot;</span><br></pre></td></tr></table></figure><h2 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h2><p>run 、 apply 、 let 、 also 和 with 五个函数均位于 kotlin 包下的 Standard 文件中，其含义和用法比较相似，现分别介绍如下。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul><li>run函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.run&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>run函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>run函数实际上可以说是let和with的结合体，run函数只是接受一个lambda函数作为参数，以闭包形式返回，==返回值为最后一行的值或者指定的return的表达式==</p></li><li><p>例子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.run &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">  public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>适用场景<br>适用于let，with函数任何场景，因为run函数是let，with两个函数的结合体，它既弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样省略，直接访问实例的公有属性和方法，另一方面也弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p></li><li><p>run函数使用前后对比</p></li></ul><p>不使用run函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"></span><br><span class="line">   with(item)&#123;</span><br><span class="line"></span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用run函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line"></span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       // 可以看到直接省略了item，并且可以在之前判空</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>let函数的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object.let&#123;</span><br><span class="line">it.todo()//在函数体内使用it替代object对象去访问其公有的属性和方法</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//另一种用途 判断object为null的操作</span><br><span class="line">object?.let&#123;//表示object不为null的条件下，才会去执行let函数体</span><br><span class="line">it.todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>let函数底层的inline扩展函数+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>从源码let函数来看，它是一个只有一个lambda 函数块block作为参数的函数，调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过it指代该对象，返回值为函数块的最后一行或者指定return表达式。</p></li><li><p>let函数的kotlin和java转化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //kotlin</span><br><span class="line"></span><br><span class="line"> fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = &quot;testLet&quot;.let &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line"> &#125;</span><br><span class="line">//返回值：7/1000</span><br><span class="line"></span><br><span class="line"> //java</span><br><span class="line"></span><br><span class="line"> public final class LetFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var2 = &quot;testLet&quot;;</span><br><span class="line">      int var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      System.out.println(result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>let函数适用的场景<br>最常用的场景就是使用let函数处理需要针对一个可以null的对象统一判空处理。</p></li><li><p>let函数的前后对比</p></li></ul><p>没有使用前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mVideoPlayer?.setVideoView(activity.course_video_view)</span><br><span class="line">mVideoPlayer?.setControllerView(activity.course_video_controller_view)</span><br><span class="line">mVideoPlayer?.setCurtainView(activity.course_video_curtain_view)</span><br></pre></td></tr></table></figure><p>使用后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对对象做了统一的判空处理</span><br><span class="line">mVideoPlayer?.let &#123;</span><br><span class="line">       it.setVideoView(activity.course_video_view)</span><br><span class="line">       it.setControllerView(activity.course_video_controller_view)</span><br><span class="line">       it.setCurtainView(activity.course_video_curtain_view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><ul><li>with函数的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with(object)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>with函数底层的inline扩展函数+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>with函数和前面几个函数使用方法略有不同，因为它不是以扩展的形式存在的。它是将某个对象作为函数的参数，==在函数块内可以通过this指代该对象==。返回值为函数块最后一行或者指定的return表达式。</p><p>可以看出with函数接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始的样子如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user, &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>但是由于，with函数最后一个参数是一个函数，可以把函数提到圆括号外部，所以最终with函数的调用形式如下：（可以看下kotlin的lambda表达式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user) &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>with函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = with(user) &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line"> public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var4 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>with函数的适用场景</li></ul><p>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBindViewHolder中，数据model的属性映射到UI上</p><ul><li>with函数使用前后对比</li></ul><p>没有使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line"></span><br><span class="line">   ArticleSnippet item = getItem(position);</span><br><span class="line">        if (item == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">        holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">        String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">        String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">        String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">        String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">        holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"></span><br><span class="line">   with(item)&#123;</span><br><span class="line"></span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       //省略了item，直接调用了实例中的方法</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul><li>apply函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.apply&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数的inline结构分析</li></ul><p>从结构上来看，apply函数和run函数很像，唯一不同点就是他们各自返回值不同，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回值则是传入对象的本身。</p><ul><li>apply函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.apply &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//输出：result：kotlin，1，111111（User本身对象被打印出来）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class ApplyFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      String var3 = &quot;result: &quot; + user;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数使用前后的对比</li></ul><p>没有使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)</span><br><span class="line">mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_seek_bar.max = 10</span><br><span class="line">mSheetDialogView.course_comment_seek_bar.progress = 0</span><br></pre></td></tr></table></figure><p>使用后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//形成了链式调用</span><br><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line"></span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多层级判空问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mSectionMetaData.questionnaire.userProject != null) &#123;</span><br><span class="line">    renderAnalysis();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123;</span><br><span class="line">    fetchQuestionData();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt; 使用了apply后可以变为链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line"></span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //questionnaire不为空的时候操作questionnaire</span><br><span class="line"></span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //section不为空的时候操作section</span><br><span class="line"></span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //sectionArticle不为空的时候操作sectionArticle</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><ul><li>also函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.also&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>also函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">//可以看到这个函数是从kotlin1.1开始才有的</span><br><span class="line">public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125;</span><br></pre></td></tr></table></figure><ul><li>also函数的inline结构分析</li></ul><p>also函数的结构实际上和let很像，唯一的区别是返回值不一样，let是以闭包的形式返回的，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值，而also函数则返回传入对象本身。这个和apply一样。</p><ul><li>also函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = &quot;testLet&quot;.also &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line">//结果：7/testLet</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class AlsoFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var2 = &quot;testLet&quot;;</span><br><span class="line">      int var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准函数总结"><a href="#标准函数总结" class="headerlink" title="标准函数总结"></a>标准函数总结</h3><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">定义inline结构</th><th style="text-align:left">函数体内代指对象</th><th style="text-align:left">返回值</th><th style="text-align:left">是否是扩展函数</th><th style="text-align:left">使用场景</th></tr></thead><tbody><tr><td style="text-align:left">let</td><td style="text-align:left">fun T.let(block: (T) -&gt; R): R = block(this)<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">it</td><td style="text-align:left">闭包返回</td><td style="text-align:left">是</td><td style="text-align:left">适用于处理不为null的操作场景</td></tr><tr><td style="text-align:left">with</td><td style="text-align:left">fun with(receiver: T, block: T.() -&gt; R): R = receiver.block()</td><td style="text-align:left">this</td><td style="text-align:left">返回闭包</td><td style="text-align:left">否</td><td style="text-align:left">适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</td></tr><tr><td style="text-align:left">run</td><td style="text-align:left">fun T.run(block: T.() -&gt; R): R = block()<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">this</td><td style="text-align:left">闭包返回</td><td style="text-align:left">是</td><td style="text-align:left">适用于let,with函数任何场景。</td></tr><tr><td style="text-align:left">apply</td><td style="text-align:left">fun T.apply(block: T.() -&gt; Unit): T { block(); return this }<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">this</td><td style="text-align:left">返回this</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">also</td><td style="text-align:left">fun T.also(block: (T) -&gt; Unit): T { block(this); return this }</td><td style="text-align:left">it</td><td style="text-align:left">返回this</td><td style="text-align:left">是</td><td style="text-align:left">适用于let函数的任何场景，一般可用于多个扩展函数链式调用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;h3 id=&quot;？操作符&quot;&gt;&lt;a href=&quot;#？操作符&quot; class=&quot;headerlink&quot; title=&quot;？操作符&quot;&gt;&lt;/a&gt;？操作符&lt;/h3&gt;&lt;p&gt;表示这个对象可能为空&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//在变量后面加？，代表这个变量可以为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var name: String? = &amp;quot;zhangsan&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//如果str不能转为Int类型，则返回null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fun parseInt(str: String): Int?&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b?.length&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>常见算法（二）</title>
    <link href="http://yoursite.com/2018/12/21/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/21/常见算法（二）/</id>
    <published>2018-12-21T07:45:16.298Z</published>
    <updated>2018-12-24T03:54:50.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。</p><a id="more"></a><h3 id="单向链表转置"><a href="#单向链表转置" class="headerlink" title="单向链表转置"></a>单向链表转置</h3><p>这个问题其实是很常见的一个算法问题，但是如果没弄清楚就会被它给搞晕了，从晕到不晕的过程就是你理解该算法的过程。</p><blockquote><p>算法还是需要理解它，才能真正的去掌握它</p></blockquote><p>下图是一个单向链表转置的初始状态和终止状态。<br><img src="https://img-blog.csdn.net/20170419120811149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHloMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>转置后：<br><img src="https://img-blog.csdn.net/20170419120851823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHloMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>首先要知道链表的数据结构是怎么样的，链表首先有自己的值（value），其次它有一个指针指向了下个结点，我们用代码来表示是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    public int value;</span><br><span class="line">    </span><br><span class="line">    public Node next;</span><br><span class="line">    </span><br><span class="line">    public Node(int data)&#123;</span><br><span class="line">        this.value = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以很清楚的看到链表的特点，他是区别于数组的一种数据结构。</p><h4 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h4><p>在数组中，是通过==索引==来访问元素的，很多算法都是利用索引来操作的，所以数组这种数据结构可以快速的查询到数据。<br>链表的优势则是删除/插入数据，因为数组是固定长度的，所以增删都会改变数组的所有元素（下标变化了），而链表是可以动态改变大小的，他只会影响左右相邻的两个结点。另外链表在内存中的存储不是连续的。</p><h4 id="算法分析过程"><a href="#算法分析过程" class="headerlink" title="算法分析过程"></a>算法分析过程</h4><p>先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Node reverseList(Node head)&#123;</span><br><span class="line">    //临时变量</span><br><span class="line">    Node pre = null</span><br><span class="line">    Node next = null</span><br><span class="line">    </span><br><span class="line">    while(head != null)&#123;</span><br><span class="line">        next = head.next // 1</span><br><span class="line">        head.next = pre // 2</span><br><span class="line">        </span><br><span class="line">        pre = head  //3</span><br><span class="line">        head = next. //4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析下具体过程，其实主要是while循环中四句话。我们逐一来分析，第一轮过程：</p><p>首先初始状态：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyhomubpa9j30pq059glm.jpg" alt=""></p><p>执行完1：next = head.next后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhoo4er7vj30nz06p74d.jpg" alt=""></p><p>执行完2: head.next = pre后：（pre此时是null）<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyhoq2nt8hj30po079aa7.jpg" alt=""></p><p>执行完3: pre = head后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhor37xb8j30pw07yt8w.jpg" alt=""></p><p>执行完4: head = next后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhosor3w2j30qa07h74g.jpg" alt=""></p><p>第一轮结束，我们看到头结点head在2的位置了，递归操作，我们继续分析第二轮：</p><p>执行完1：next = head.next后：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyhovdga7nj30q807tt90.jpg" alt=""></p><p>执行完2: head.next = pre后：（pre此时是指向了1）<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyhowpw07sj30p106zq37.jpg" alt=""><br>这一步很巧妙将1和2转置了。<br>执行完3: pre = head后：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyhoykh8iqj30op06taab.jpg" alt=""></p><p>执行完4: head = next后：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyhozd97bpj30p206f74j.jpg" alt=""></p><p>如此，经过5次循环就能将这个单向链表成功转置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 (一)</title>
    <link href="http://yoursite.com/2018/12/16/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/16/常见排序算法（一）/</id>
    <published>2018-12-16T06:39:02.868Z</published>
    <updated>2019-02-27T15:13:02.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。</p><a id="more"></a><h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>原理：分治，前后两个指针交替前进，然后递归，主要步骤是：</p><ol><li>取一个数作为基数（一般就选第一个）</li><li>将数组中比这个数大的放在它的右边，比基数小的放在它左边</li><li>递归两遍的数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] a,int low,int high)&#123;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = high;</span><br><span class="line">    int temp = a[low] //比较的数</span><br><span class="line">    </span><br><span class="line">    while(i &lt; j)&#123;</span><br><span class="line">        while(i&lt;j &amp;&amp; a[j] &gt;= temp)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; j) &#123;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(i &lt; j &amp;&amp; a[j] &lt; temp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a[i] = temp;</span><br><span class="line">    quickSort(a,low,i-1);</span><br><span class="line">    quickSort(a,i+1;high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>原理：堆其实是一个完全二叉树，它的特征是当前结点下标为i，那么它的根结点为i/2，它的左子结点为：2i+1；右子结点为：2i+2。<br>堆排序要经过两步：</p><ol><li>将树变为稳定的二叉树（大堆模式），即每个根结点都要大于等于它的子结点。</li><li>将根结点和最后一个结点互换，递归以上操作</li></ol><p>手写代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一步变为稳定树</span><br><span class="line">public void adjustHeap(int[] ,int parent,int length)&#123;</span><br><span class="line">    int temp = a[parent];</span><br><span class="line">    int leftChildIndex = 2*parent + 1;</span><br><span class="line">    </span><br><span class="line">    while(leftChildIndex &lt; length)&#123;</span><br><span class="line">        if (a[leftChildeIndex] &lt; a[leftChildIndex + 1]&#123;</span><br><span class="line">            leftChildIndxe = leftChildIndex + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (temp &gt; a[leftChildIndex])&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        a[parent] = a[leftChildIndex];</span><br><span class="line">        </span><br><span class="line">        parent = leftChildIndex;</span><br><span class="line">        leftChildIndex = 2*leftChildIndex + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a[parent] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>原理：内存循环会不停比较两个数的大小，进行换位，完成一轮后，最大的数会排在最后。（注意和选择排序的区别，选择排序是内层循环和外层循环比较）<br>算法时间复杂度：O（n2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] a)&#123;</span><br><span class="line"></span><br><span class="line">    int len = a.length;</span><br><span class="line">    for(int i =0 ;i&lt;len;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;len - i -1;j++)&#123;//每一轮最后一个数不用比较</span><br><span class="line">        // 内存循环比较相邻两个数</span><br><span class="line">            if(a[j] &gt; a[j+1])&#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>原理：遍历数组中最小值，放在最左边，再从剩下数组中找最小值，直到排序完成（在要排序的一组数中，选出最小的一个数与第一个位置的数交换位置）<br>算法时间复杂度：O（n2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void selectSort(int[] a)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">        for(int j = i+1; j&lt; len;j++)&#123;</span><br><span class="line">        // 和外层第一个元素比较</span><br><span class="line">            if(a[j] &gt; a[i])&#123;</span><br><span class="line">                int temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法，Android" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%EF%BC%8CAndroid/"/>
    
  </entry>
  
  <entry>
    <title>GDG Shenzhen 2018</title>
    <link href="http://yoursite.com/2018/12/09/GDG%20Shenzhen%202018/"/>
    <id>http://yoursite.com/2018/12/09/GDG Shenzhen 2018/</id>
    <published>2018-12-09T07:27:54.609Z</published>
    <updated>2018-12-09T08:30:33.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于GDG"><a href="#关于GDG" class="headerlink" title="关于GDG"></a>关于GDG</h2><p>GDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。<br><img src="https://chinagdg.org/wp-content/uploads/2015/07/2015_ChinaSummit-1024x382.jpg" alt="全国组织"></p><p><a href="https://chinagdg.org/" target="_blank" rel="noopener">GDG官网</a></p><p>昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。</p><a id="more"></a><h2 id="活动打卡"><a href="#活动打卡" class="headerlink" title="活动打卡"></a>活动打卡</h2><p>活动地址，关键离我住的地方很近。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fy0jnaidt2j30u0140qv6.jpg" alt="活动地址"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy0jpf392lj30u0140kjl.jpg" alt="活动标题"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy0jqeujphj31400u04qq.jpg" alt="现场"></p><p><a href="https://gallery.vphotos.cn/vphotosgallery/index.html?vphotowechatid=1EF7FAB4CF1DE5D92DAC7EE20115154C&amp;gallery_source_code=0&amp;from=groupmessage&amp;isappinstalled=0&amp;gallery_source_code=0#/" target="_blank" rel="noopener">更多照片–现场图片直播</a></p><h2 id="心得感想"><a href="#心得感想" class="headerlink" title="心得感想"></a>心得感想</h2><p>今年的活动收获还比较多，GDE（Google developer expert）将了很多AI，TensorFlow，Google的一些东西，包括很具体的Flutter，Kotlin以及Android的优化等等东西。干活还是比较多的。作为一个Android开发者，对于Android的未来其实一直有关注，blog里面也写了很多，这里就写一些经过这个活动后的感受吧，Google其实已经在开发Android的替代系统了，而且kotlin也迭代到了V1.3版本，这个时候又来了个Flutter（跨平台开发），感觉这些项目都是各自为政，其实看过《硅谷之谜》这本书后也能理解，大公司其实内部为了保持创新活力会鼓励团队或者部门去折腾，类似公司里面的成立小的创业团队，每个团队负责一个项目，如果做好了就会被公司收购，做的不好就被关掉（垃圾Google关掉了多少优秀的服务，看看隔壁百度。。。）。对于我们这些开发者而言，其实还是要靠自己的兴趣去选择，感觉李锐博士说的很好：选择职业要看自己的兴趣，不要太功利，AI很火大家都去AI，市场饱和后还是靠大家的实力，如果已自己的兴趣为出发点，赚钱是一个自然的过程。保持好奇心，紧跟前沿技术，不断去学习。然后，我自己感觉，flutter这个东西还是需要去认真对待的，特别是感受到他的hot reload的特性后，感觉非常爽，还有kotlin也是需要快速去掌握的，目前个人掌握的并不全面。另外，需要移动端结合AI来做些东西，可能会有不一样的发现。下面列出个人比较关注和感兴趣的点：</p><ol><li>数据安全，在中国还有很多工作要做</li><li>隐藏的歧视，这里其实指的是，在技术发展飞速的今天，很多年轻人已经享受到了技术带来的好处，但是还有些人是没有得到实惠的，这些人在这个时代是弱势群体，但是他们经常会被忽略。</li><li>Flutter的优势在众多跨平台框架中是很out standing的</li><li>Android WorkManager某些情况下是可以替代Service的，比如在那些不用立即在后台执行操作的场景下</li><li>Kotlin的协程概念。这个我比较感兴趣，这个特性是V1.3刚发布的，这个是kotlin中的异步概念的实现，很像Rxjava的链式调用，需要去学习一下，另外kotlin好像也能有在大数据里面。</li><li>供web和移动端调用的轻量级TensorFlow，包括tensorflwo.js tensorflow.lite。</li><li>中国的AI发展很快，美帝国主义可能要制裁这些公司了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于GDG&quot;&gt;&lt;a href=&quot;#关于GDG&quot; class=&quot;headerlink&quot; title=&quot;关于GDG&quot;&gt;&lt;/a&gt;关于GDG&lt;/h2&gt;&lt;p&gt;GDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。&lt;br&gt;&lt;img src=&quot;https://chinagdg.org/wp-content/uploads/2015/07/2015_ChinaSummit-1024x382.jpg&quot; alt=&quot;全国组织&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chinagdg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDG官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="GDG" scheme="http://yoursite.com/tags/GDG/"/>
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>悖论之共有知识和公共知识</title>
    <link href="http://yoursite.com/2018/12/07/%E6%82%96%E8%AE%BA%E4%B9%8B%E5%85%B1%E6%9C%89%E7%9F%A5%E8%AF%86%E5%92%8C%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/07/悖论之共有知识和公共知识/</id>
    <published>2018-12-07T09:24:04.140Z</published>
    <updated>2018-12-07T10:20:04.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩：</p><ol><li>大家不能讨论别人眼睛的颜色。</li><li>如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。</li></ol><p>有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，根据规则，其实大家都知道在村里有红/蓝两种眼睛的人，但是大家都不知道自己眼睛是什么颜色的。直到来了外乡人说了一句“你们中有人跟我一样是蓝色眼睛的人”，我们来分析下：假设村里只有1个蓝眼睛的人，那么这个人只知道村里都是红眼睛的，那么那个蓝眼睛就是自己了。那么再假设村里有2个蓝色眼睛的人，那么这两个人都知道对方是蓝眼睛的，但是第一天对方没有去自杀，那么理由只有一个村里蓝眼睛的人不止一个，也就是自己也是蓝眼睛，那么这两个人都会第二天自杀；依次类推，有3个蓝眼睛的人，如果第二天没人死，那么就是村里不止两个蓝眼睛的人，也就是自己就是蓝眼睛。。。。那么，红眼睛的人会死吗？答案是不会，因为红眼睛的人不知道自己眼睛的颜色是什么？可能红色，也可能黑色对不对</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>我们来看下，其实外乡人什么信息都没增加，为什么就发生了这种事情呢？这就要从知识分类来说了，知识分两类：共有知识，公共知识。<br>共有知识：大家都知道的知识<br>公共知识：大家都知道大家知道的知识</p><p>那么，从上面例子可以看出，大家原来都知道村里有红蓝眼睛的人，这就是共有知道，但是当外乡人把这件事情说出来共有知识就变成了公共知识，大家就都知道大家知道这件事情了。其实现实生活中有很多这样的例子，大家可以去发现，只有去讨论，将自己心里知道的东西说出来，才能变成公共知识，发挥出效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大家不能讨论别人眼睛的颜色。&lt;/li&gt;
&lt;li&gt;如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="心理学，悖论" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%8C%E6%82%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>悖论系列之分金问题</title>
    <link href="http://yoursite.com/2018/12/06/%E6%82%96%E8%AE%BA%E4%B9%8B%E4%B8%89%E5%A7%AC%E5%88%86%E9%87%91/"/>
    <id>http://yoursite.com/2018/12/06/悖论之三姬分金/</id>
    <published>2018-12-06T12:10:53.117Z</published>
    <updated>2018-12-06T12:39:30.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>有一期的问题是：</strong><br>从前有一个国王，一天他的三位妃子想玩一个游戏，这个游戏规则是这样的：</p><ol><li>有100金币供三个人A B C分</li><li>每个人按顺序发言，即提议分配这100金的方案</li><li>如果这个人的发言超过半数的人同意，则方案达成，如果没有，提议的人则要被处死。</li><li>每个人都很聪明而且人性本恶，每个人都想尽量多的获得更多的金币，如果还能杀死对方，那么则更好。<br>问题是：最终这个金币会怎么分？</li></ol><hr><p>想一想。。。。。。。。。。。。。。。。。<br>初想下：A应该分的最少吧，因为最先提</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，我们来假设A已经死了，只剩下B和C来分这个金币会出现什么情况，这个时候其实很简单了，按照第四条原则：B不管提出什么方案，C都不同意，那么C就能分到100金币，并且杀死了A和B。那么，<strong>其实在A死的情况下B也一定死</strong>；所以，B要怎么做才能不死呢，答案只有一个：A不能死。这个情况A是知道的，B也知道。<br>那么就是说：无论A提出什么样的方案，B都会同意，这个时候分配方案是A：100/B：0/C：0，那么也有答案是A应该给一块金币B，那么B更加会同意A，如果A死，B一定死而且一毛钱拿不到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们引申下这个问题，如果来了四个人来分金币，会怎么样呢：M A B C？依然遵循上面的分析过程，M会拿到最多的金币，但是A就是一毛拿不到了，B和C反而会各拿到1个金币（大家想想是不是）：如果M死了，B和C都会一毛拿不到，这个时候M如果给B和C一人一个金币，那么B和C必然赞同，而A为了自己利益最大化，当然是想把M干掉，但是BC同意的话A的意见也没什么作用了。</p><p>这个问题很像现在的社会，国家也一样，老大永远提防老二，而老二永远想干掉老大，老大为了压制老二还会去讨好老三老四组成联盟。这个问题其实蛮有趣的，以前没想过这个问题，现在慢慢发现，很多问题其实都来源于人性。这个问题就到此，后面会有其它悖论的题目再分析吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="悖论" scheme="http://yoursite.com/tags/%E6%82%96%E8%AE%BA/"/>
    
      <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Flutter V1.0.0发布</title>
    <link href="http://yoursite.com/2018/12/06/Flutter1.0%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2018/12/06/Flutter1.0发布/</id>
    <published>2018-12-06T06:26:33.488Z</published>
    <updated>2018-12-06T07:01:51.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flutter是什么"><a href="#flutter是什么" class="headerlink" title="flutter是什么"></a>flutter是什么</h2><p>Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编写。2018/12/04Google正式发布了它的V1.0.0稳定版本，也就是说移动端的开发有可能会发生革命性的变化。本人第二天看了youtube上的发布会，然后试玩了一下发布会上说的Google三个员工三个月为这场发布会写的Demo app：The history of everything。个人感觉：完全感觉不出是非原生的，动画，过渡非常流畅，而且我还用的是老的Nexus 6P来运行的，这种表现打破了我对跨平台开发的认知，让我相当震撼，也许原生开发真的要被取代了，喊了N多遍的狼来了看来也只是时间问题了。</p><h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>当变化来的时候，也许最好的方式是去拥抱变化，而不是墨守成规，扛着原生开发的大旗拉上kotlin小弟一起为Google的保守势力买单。技术现在发展月来越快，技术更新周期越来越短，这也对开发者提出了更高的要求，你需要不断的学习新东西，去适应这个快速发展的世界；但是，每个人的精力都是有限的，怎样在这个信息爆炸的时代学习到保命技能做到以不变应万变，这就需要你的眼光，高度以及眼界了，形而上的东西看着像套路但是归根结底被前人总结的其实就是这些东西，如果你具有了这些“能力”，你就会敏锐的知道在这些快速发展的技术中，哪些是革命性的？哪些是过渡的？集中精力去学习革命性的技术会让你在以后有先发优势，而如果你选择错误，则只能看着刚学的内容马上就out了。</p><p>个人总结的几点建议：</p><ol><li>不盲目跟风口。如果自己专业领域就是风口，那就是最好，这里说的是不同领域为了去风口而盲目转型，最少要有关联性，而且是你喜欢的。</li><li>跟随大公司。这里的大公司指的是掌握核心科技的公司，站在业界前沿的公司如Google，他们发布的技术有可能就是革命性的。</li><li>对新技术保持永远的好奇心。还是刚说的要去拥抱变化，而不是抵触。</li><li>抓住机会，去更大的平台。大平台的优势不用说了。在技术变革期，大平台是最敏感的。</li><li>在技术外，丰富自己的知识库，多看书，多阅历，多和优秀的人沟通。</li></ol><h2 id="flutter的特性"><a href="#flutter的特性" class="headerlink" title="flutter的特性"></a>flutter的特性</h2><p>这里就贴一些文章，看到的都是各种赞不绝口，希望我也能把它收进武器库。<br><a href="https://mp.weixin.qq.com/s/lYisub0Zg9Yz6o9KsYopvA" target="_blank" rel="noopener">Google 要用 Flutter 一统移动、桌面开发江湖？</a></p><p><a href="https://mp.weixin.qq.com/s/hCIN42OMmmc6HkOveegwWQ" target="_blank" rel="noopener">Flutter 1.0 正式版: Google 的便携 UI 工具包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flutter是什么&quot;&gt;&lt;a href=&quot;#flutter是什么&quot; class=&quot;headerlink&quot; title=&quot;flutter是什么&quot;&gt;&lt;/a&gt;flutter是什么&lt;/h2&gt;&lt;p&gt;Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Https简介</title>
    <link href="http://yoursite.com/2018/12/04/Https%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/04/Https详解/</id>
    <published>2018-12-04T03:42:18.327Z</published>
    <updated>2018-12-04T06:20:44.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><blockquote><p>Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。</p><p>Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_hd.png" alt=""></p><a id="more"></a><p>下面我们来看下加密图解过程：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxukq90qjfj30a50bf3yj.jpg" alt=""></p><p>加密过程解析：</p><ol><li>客户端发送https请求，服务端返回给客户端证书（证书中含有服务端随机产生的非对称加密的公钥P）==非对称加密的算法首推RSA，可以去看原理，其实就是求一个大数的质数分解==</li><li>客户端验证发送的证书是有有效，是否去信任该证书，并随机产生对称加密的密钥K，使用P对K进行加密。</li><li>将加密后的对称加密密钥K传回给服务端，服务端用非对称加密的私钥将其解开，这样服务端和客户端都有了对称加密密钥K了。（这么做的目的是防止在传输过程中K被泄漏）</li><li>以后客户端会通过K进行数据加密，而服务端也会用K进行解密</li><li>1-2是密钥协商过程，3是加密传输过程，其中密钥协商过程解决了对称加密密钥的传输问题，由于非对称加密比对称加密解析效率低，但是安全的多的特点，因此将非对称加密用来传递对称加密密钥，而用对称加密去加解密数据。这样既保证了对称加密密钥，又保证了数据解析过程中效率。</li></ol><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书应该是第三方认证机构颁发出来的，具有签名的一种信任凭证。而证书是需要购买的：<br>免费的：<br>国内沃通：<a href="https://freessl.wosign.com/" target="_blank" rel="noopener">沃通</a><br>国外：<a href="https://www.startssl.com/" target="_blank" rel="noopener">woturs</a></p><blockquote><p>其实，国内这家的根证书也是startssl签发的，实际上也是国外的。</p></blockquote><p><a href="https://www.jianshu.com/p/55e402bcbc18" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;https协议&quot;&gt;&lt;a href=&quot;#https协议&quot; class=&quot;headerlink&quot; title=&quot;https协议&quot;&gt;&lt;/a&gt;https协议&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。&lt;/p&gt;
&lt;p&gt;Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_hd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Android内存优化（一）</title>
    <link href="http://yoursite.com/2018/11/30/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/30/Android内存优化（一）/</id>
    <published>2018-11-30T03:42:39.112Z</published>
    <updated>2019-03-22T14:41:34.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android内存优化（一）"><a href="#Android内存优化（一）" class="headerlink" title="Android内存优化（一）"></a>Android内存优化（一）</h1><p>在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。</p><a id="more"></a><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap内部使用了一个默认容量为16的数组来存储数据，而数组中每个元素又是一个链表的头结点，所以其实HashMap就是一个数组+链表的数据结构。如图：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxujt3fucij30eo0dijsh.jpg" alt=""></p><p>左边纵向是数组，右边横向为链表。</p><p>这个数据结构中每一个都一个Entry类型，那么Entry的数据结构是怎么样的呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final K key;</span><br><span class="line">V value;</span><br><span class="line">final int hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><p>从中我们可以看到Entry中有key，value，hash值以及下一个结点Entry，那么Entry数据是按照什么规则来存储的呢：通过计算元素key的hash值，然后对HashMap中的数组长度（默认16）取余从而得到该元素应该存在哪里，计算公式为==hash(key)%len==,举一个例子：</p><blockquote><p>hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到<br>hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置</p></blockquote><p>如图：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxujz356pej30fj062weu.jpg" alt=""><br>从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不回覆盖前一个，而是放在链表末尾，从而解决了<strong>Hash冲突</strong>的问题。（问题1:如果key的hash值取余大于15，那么元素该放在哪里？）。</p><p>所以，重点是：我们知道HashMap默认存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap的对象的时候，即使里面没有任何元素，系统也是会分配这么多空间给它的，而且，当我们不断往里面put数据的时候，当达到了一定的容量限制时，HashMap会扩容，而且扩大后的新的空间一定是原来的==两倍==。</p><blockquote><p>扩容条件：HashMap中的数据量&gt;容量*加载因子，默认加载因子是0.75</p></blockquote><p><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">参见HashMap详解</a></p><p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">参见HashMap的实现</a></p><p>只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费。附上hash函数的实现图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt=""></p><blockquote><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。</p></blockquote><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>SparesArray相比HashMap更省内存，某些条件下性能更好。它的内部规则是通过两个数组来存储数据的，一个存储key，另一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约了内存空间。我们从源码中可以看到key和value分别是用数组表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private int[] mKeys;</span><br><span class="line">private Object[] mValues;</span><br></pre></td></tr></table></figure><p>从源码中看到，SparesArray只能存储key为int类型的数据，同时，SparesArray在存储和读取数据的时候，使用的是<strong>二分查找法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line"> public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从==小到大的顺序排列好==，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。<br>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p><p>使用场景：<br>虽然SparesArray性能好，但是由于其添加，查找，删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，还有有下降，所以使用也是要看使用场景的：</p><ul><li>数据量不大，在千以内（Android开发大部分场景吧）</li><li>key必须为int类型<br>以上就是使用它的场景了。</li></ul><h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>ArrayMap其实也是一个key-value映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用了两个数组存储数据，一个数组记录key的hash值，另外一个数组记录value值，和SparesArray一样，也会对可以使用二分法进行从小到大的排序，在添加，删除，查找数据的时候都是使用二分法查到相应的index，然后通过index来进行操作，它的使用场景：</p><ul><li>数据量不大，千以内</li><li>数据结构为Map类型</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>如果我们要兼容api19以下版本，那么导入V4包<br>import android.support.v4.util.ArrayMap;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android内存优化（一）&quot;&gt;&lt;a href=&quot;#Android内存优化（一）&quot; class=&quot;headerlink&quot; title=&quot;Android内存优化（一）&quot;&gt;&lt;/a&gt;Android内存优化（一）&lt;/h1&gt;&lt;p&gt;在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>kotlin之object详解</title>
    <link href="http://yoursite.com/2018/11/28/Kotlin%E4%B9%8Bobject%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/Kotlin之object详解/</id>
    <published>2018-11-28T10:25:55.500Z</published>
    <updated>2018-11-28T13:26:28.012Z</updated>
    
    <content type="html"><![CDATA[<p>在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。</p><p>object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景：</p><ol><li>对象声明（Object Decalaration）</li><li>伴生对象（Companion Object）</li><li>对象表达式（Object Expression）– 上面提到的就是这种</li></ol><a id="more"></a><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>语法：通过object实现kotlin中的单例<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object RepositoryManager&#123;</span><br><span class="line">    fun method()&#123;</span><br><span class="line">        println(&quot;I&apos;m in object declaration&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即将object代替class关键字，声明一个类，这个类就是单例了</p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    RepositoryManager.method()//kotlin的调用</span><br><span class="line">    RepositoryManager.INSTANCE.method();//java的调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像在Java中调用静态方法（kotlin中没有静态方法）一样去调用其中定义的方法。其实，object声明的类最终被编译成：一个类拥有一个静态成员变量来持有对自己的引用，并且这个静态成员的名称是INSTANCE。它等价于java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RepositoryManager&#123;</span><br><span class="line">    private RepositoryManager()&#123;&#125;</span><br><span class="line">    public static final RepositoryManager INSTANCE = new RepositoryManager();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尽管和普通类的声明一样，可以包含属性，方法，初始化代码块以及可以继承其他类或者实现某个接口，但是它不能包含构造器，java中构造器是私有的。</p></blockquote><p>它也可以定义在一个类的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOuter &#123;</span><br><span class="line">     object Inner&#123;</span><br><span class="line">         fun method()&#123;</span><br><span class="line">             println(&quot;I&apos;m in inner class&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">     ObjectOuter.Inner.method()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="伴生对象（Companion-object）"><a href="#伴生对象（Companion-object）" class="headerlink" title="伴生对象（Companion object）"></a>伴生对象（Companion object）</h3><p>在kotlin中是没有static关键字的，也就意味着没有了静态方法和静态成员。那么在kotlin中如果想表示这种概率，取而代之的是==包级别函数==这里的伴生对象。他们的区别在下面会介绍。</p><p>包级别函数是指在kotlin中fun可以不依赖于class，直接新建.kt文件在文件中直接可以写fun方法，调用的时候IDE会自动导入文件急fun的方法名可以在其他类中直接使用。（其实编译后它还是在类中的，只不过类名称是.kt的文件名）</p><p>伴生对象的语法形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    companion object 伴生对象名(可以省略)&#123;</span><br><span class="line">        //define method and field here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ObjectTest &#123;</span><br><span class="line"></span><br><span class="line">    companion object MyObjec&#123;</span><br><span class="line"></span><br><span class="line">        val a = 20</span><br><span class="line"></span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;I&apos;m in companion object&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //方式一</span><br><span class="line">    ObjectTest.MyObject.method()</span><br><span class="line">    println(ObjectTest.MyObject.a)</span><br><span class="line"></span><br><span class="line">    //方式二（推荐方式）</span><br><span class="line">    ObjectTest.method()</span><br><span class="line">    println(ObjectTest.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在定义时如果省略了伴生对象名称，那么编辑器会为其提供默认的名字Companion。在方法二中，我们是直接通过类名称.方法名()的形式调用的，我们在没有生成ObjectTest类对象时，直接调用了其伴生对象中定义的属性和方法，和java中的静态方法很相似。</p></blockquote><p>通过javap命令，让我们看下其生成的字节码：<br><img src="https://img-blog.csdn.net/20180312203901905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180313102935601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><blockquote><p>注意红框中，这个MyObject成员变量的类型，是用$符号连接的，那么说明我们在定义伴生对象的时候，实际上是把它当作了静态内部类来看待的，并且目标类会持有该内部类的一个应用，最终调用的是定义在这个静态内部类中的实例方法。</p></blockquote><p>那么伴生对象和包级别函数的区别是什么呢？我们反编译下kt文件。<br><img src="https://img-blog.csdn.net/20180312204822460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>可以看出，一个名叫ObjectTest2.kt文件实际上会生成一个名叫ObjectTest2Kt的类，而这个顶级函数是作为这个类的静态方法的形式存在的。<br>所以实际上类中的静态方法和内部类中的实例方法的区别，因为成员内部类中的方法是可以访问外部内定义的方法和成员变量的，哪怕是private的，而静态方法是做不到这一点的。<br><img src="https://img-blog.csdn.net/20180314102249748?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3hsaDExOTE4NjA5Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h3 id="对象表达式（Object-Expression）"><a href="#对象表达式（Object-Expression）" class="headerlink" title="对象表达式（Object Expression）"></a>对象表达式（Object Expression）</h3><p>先来看下java中的匿名内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Contents &#123;</span><br><span class="line">    void absMethod();</span><br><span class="line">&#125;</span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new Contents() &#123;</span><br><span class="line">           </span><br><span class="line">            @Override</span><br><span class="line">            public void absMethod() &#123;</span><br><span class="line">                System.out.println(&quot;method invoked...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.contents().absMethod();    //打印method invoked...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指出两点java中内部类的局限性</p><ol><li>如果在匿名内部类中添加了一些方法和属性，那么在外部是无法调用的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return new Contents() &#123;</span><br><span class="line">            private int i = 1;</span><br><span class="line"></span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void absMethod() &#123;</span><br><span class="line">                System.out.println(&quot;method invoked...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.contents().absMethod();</span><br><span class="line">        hello.value();  //Cannot resolve method &apos;value()&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当你想使用这个value方式的时候，编译会报错，因为java的多态导致父类型的引用是无法知晓子类添加的方法的。</p><ol><li>一个匿名内部类肯定只能实现一个接口或者继承一个类。</li></ol><p>在看看kotlin的对象表达式：<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object [ : 接口1,接口2,类型1, 类型2]&#123;&#125;    //中括号中的可省略</span><br></pre></td></tr></table></figure><p>示例：<br>实现一个接口或者类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface AA &#123;</span><br><span class="line">    fun a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    val aa = object : AA &#123;</span><br><span class="line">        override fun a() &#123;</span><br><span class="line">            println(&quot;a invoked&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aa.a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不实现任何接口和类，并且在匿名内部类中添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    val obj = object  &#123;</span><br><span class="line">        fun a() &#123;</span><br><span class="line">            println(&quot;a invoked&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.a()  //打印：a invoked</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子看出kotlin中，新添加的方式是可以调用的<br>那么，实现多个接口和类（NB）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val cc = object : AA, BB() &#123;</span><br><span class="line">        override fun a() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun b() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cc.a()</span><br><span class="line">    cc.b()</span><br><span class="line"></span><br><span class="line">&#125;//注意写法</span><br></pre></td></tr></table></figure><blockquote><p>kotlin官方文档上的一句话：匿名对象只定义局部变量和private成员变量时，才能体现它的真实类型，如果你是将匿名对象作为public函数的返回值或者是public的属性时，你只能将它看作是它的父类，当然你不指定类型时就当Any看待，这时你在匿名对象中添加的方法和属性时不能被访问的。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyTest &#123;</span><br><span class="line"></span><br><span class="line">    private val foo = object &#123;</span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;private&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val foo2 = object &#123;</span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;public&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun m() = object &#123;</span><br><span class="line">        fun method()&#123;</span><br><span class="line">            println(&quot;method&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun invoke()&#123;</span><br><span class="line"></span><br><span class="line">        val local = object &#123;</span><br><span class="line">            fun method()&#123;</span><br><span class="line">                println(&quot;local&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        local.method()  //编译通过</span><br><span class="line">        foo.method()    //编译通过</span><br><span class="line">        foo2.method()   //编译通不过</span><br><span class="line">        m().method()    //编译通不过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后：<br>object声明：当第一次访问它时才初始化，是一种懒加载<br>伴生对象：当他对应的类被加载后，它才初始化，类似java中的额静态代码块<br>对象表达式：一旦被执行，就立刻初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。&lt;/p&gt;
&lt;p&gt;object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象声明（Object Decalaration）&lt;/li&gt;
&lt;li&gt;伴生对象（Companion Object）&lt;/li&gt;
&lt;li&gt;对象表达式（Object Expression）– 上面提到的就是这种&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>怎么用Kotlin去提高生产力：Kotlin Tips</title>
    <link href="http://yoursite.com/2018/11/23/Kotlin-Tips/"/>
    <id>http://yoursite.com/2018/11/23/Kotlin-Tips/</id>
    <published>2018-11-23T02:16:01.495Z</published>
    <updated>2018-11-23T02:23:41.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Tip1-更简洁的字符串">Tip1-更简洁的字符串</a><ul><li>1、三个引号  2、字符串模版</li></ul></li><li><a href="#Tip2-Kotlin中大多数控制结构都是表达式">Tip2-Kotlin中大多数控制结构都是表达式</a><ul><li>1、语句和表达式  2、if  3、when</li></ul></li><li><a href="#Tip3-更好调用的函数-显式参数名及默认参数值">Tip3-更好调用的函数：显式参数名及默认参数值</a><ul><li>1、显式参数名  2、默认参数值  3、@JvmOverloads </li></ul></li><li><a href="#Tip4-扩展函数和属性">Tip4-扩展函数和属性</a><ul><li>1、扩展函数  2、扩展属性</li></ul></li><li><a href="#Tip5-懒初始化bylazy和延迟初始化lateinit">Tip5-懒初始化bylazy和延迟初始化lateinit</a><ul><li>1、by lazy  2、lateinit</li></ul></li><li><a href="#Tip6-不用再手写findViewById">Tip6-不用再手写findViewById</a><ul><li>1、Activity  2、子View或者include标签  3、Fragment</li></ul></li><li><a href="#Tip7-利用局部函数抽取重复代码">Tip7-利用局部函数抽取重复代码</a><ul><li>1、局部函数  2、扩展函数</li></ul></li><li><a href="#Tip8-使用数据类来快速实现model类">Tip8-使用数据类来快速实现model类</a>  </li><li><a href="#Tip9-用类委托来快速实现装饰器模式">Tip9-用类委托来快速实现装饰器模式</a> </li><li><a href="#Tip10-Lambda表达式简化OnClickListener">Tip10-Lambda表达式简化OnClickListener</a></li><li><a href="#Tip11-with函数来简化代码">Tip11-with函数来简化代码</a> </li><li><a href="#Tip12-apply函数来简化代码">Tip12-apply函数来简化代码</a> </li><li><a href="#Tip13-在编译阶段避免掉NullPointerException">Tip13-在编译阶段避免掉NullPointerException</a><ul><li>1、可空和不可空类型  2、let  3、Elvis操作符</li></ul></li><li><a href="#Tip14-运算符重载">Tip14-运算符重载</a> </li><li><a href="#Tip15-高阶函数简化代码">Tip15-高阶函数简化代码</a> </li><li><a href="#Tip16-用Lambda来简化策略模式">Tip16-用Lambda来简化策略模式</a> <a id="more"></a></li></ul><hr><h2 id="Tip1-更简洁的字符串"><a href="#Tip1-更简洁的字符串" class="headerlink" title="Tip1-更简洁的字符串"></a>Tip1-更简洁的字符串</h2><p><a href="#目录">回到目录</a></p><h4 id="三个引号"><a href="#三个引号" class="headerlink" title="三个引号"></a>三个引号</h4><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip1/KotlinTip1.kt" target="_blank" rel="noopener">KotlinTip1</a></p><p>Kotlin中的字符串基本Java中的类似，有一点区别是加入了三个引号”””来方便长篇字符的编写。<br>而在Java中，这些都需要转义，先看看java中的式例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    String str2 = <span class="string">"line1\n"</span> +</span><br><span class="line">            <span class="string">"line2\n"</span> +</span><br><span class="line">            <span class="string">"line3"</span>;</span><br><span class="line">    String js = <span class="string">"function myFunction()\n"</span> +</span><br><span class="line">            <span class="string">"&#123;\n"</span> +</span><br><span class="line">            <span class="string">"    document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";\n"</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>;</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">    System.out.println(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin除了有单个双引号的字符串，还对字符串的加强，引入了<strong>三个引号</strong>，”””中可以包含换行、反斜杠等等特殊字符：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin对字符串的加强，三个引号"""中可以包含换行、反斜杠等等特殊字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str1 = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">val</span> str2 = <span class="string">"""line1\n</span></span><br><span class="line"><span class="string">        line2</span></span><br><span class="line"><span class="string">        line3</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    <span class="keyword">val</span> js = <span class="string">"""</span></span><br><span class="line"><span class="string">        function myFunction()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            document.getElementById("demo").innerHTML="My First JavaScript Function";</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    println(str1)</span><br><span class="line">    println(str2)</span><br><span class="line">    println(js)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h4><p>同时，Kotlin中引入了<strong>字符串模版</strong>，方便字符串的拼接，可以用$符号拼接变量和表达式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin字符串模版，可以用$符号拼接变量和表达式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> strings = arrayListOf(<span class="string">"abc"</span>, <span class="string">"efd"</span>, <span class="string">"gfg"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="variable">$strings</span>"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;strings[<span class="number">0</span>]&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;if (strings.size &gt; <span class="number">0</span>) strings[<span class="number">0</span>] else "null"&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，在Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是${‘$’}<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是$&#123;'$'&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"First content is \$strings"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>strings"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip2-Kotlin中大多数控制结构都是表达式"><a href="#Tip2-Kotlin中大多数控制结构都是表达式" class="headerlink" title="Tip2-Kotlin中大多数控制结构都是表达式"></a>Tip2-Kotlin中大多数控制结构都是表达式</h2><p><a href="#目录">回到目录</a></p><p>首先，需要弄清楚一个概念<strong>语句和表达式</strong>，然后会介绍控制结构表达式的优点：<strong>简洁</strong></p><h4 id="语句和表达式是什么？"><a href="#语句和表达式是什么？" class="headerlink" title="语句和表达式是什么？"></a>语句和表达式是什么？</h4><ul><li>表达式有值，并且能作为另一个表达式的一部分使用</li><li>语句总是包围着它的代码块中的顶层元素，并且没有自己的值<h4 id="Kotlin与Java的区别"><a href="#Kotlin与Java的区别" class="headerlink" title="Kotlin与Java的区别"></a>Kotlin与Java的区别</h4></li><li>Java中，所有的控制结构都是语句，也就是控制结构都没有值</li><li>Kotlin中，除了循环（for、do和do/while）以外，大多数控制结构都是表达式(if/when等)</li></ul><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip2" target="_blank" rel="noopener">tip2</a></p><h4 id="Example1：if语句"><a href="#Example1：if语句" class="headerlink" title="Example1：if语句"></a>Example1：if语句</h4><p>java中，if 是语句，没有值，必须显式的return<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的if语句</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin中，if 是表达式，不是语句，因为表达式有值，可以作为值return出去<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，if 是表达式，不是语句，类似于java中的三目运算符a &gt; b ? a : b</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的if中的分支最后一行语句就是该分支的值，会作为函数的返回值。这其实跟java中的三元运算符类似，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java的三元运算符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是java中的三元运算符，kotlin中if是表达式有值，完全可以替代，<strong>故kotlin中已没有三元运算符了</strong>，用if来替代。<br>上面的max函数还可以简化成下面的形式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin简化版本</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p><h4 id="Example2：when语句"><a href="#Example2：when语句" class="headerlink" title="Example2：when语句"></a>Example2：when语句</h4><p>Kotlin中的when非常强大，完全可以取代Java中的switch和if/else，同时，<strong>when也是表达式</strong>，when的每个分支的最后一行为当前分支的值<br>先看一下java中的switch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的switch</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPoint</span><span class="params">(<span class="keyword">char</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"GOOD"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"BAD"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UN_KNOW"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>java中的switch有太多限制，我们再看看Kotlin怎样去简化的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，when是表达式，可以取代Java 中的switch，when的每个分支的最后一行为当前分支的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPoint</span><span class="params">(grade: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span> (grade) &#123;</span><br><span class="line">    <span class="string">'A'</span> -&gt; <span class="string">"GOOD"</span></span><br><span class="line">    <span class="string">'B'</span>, <span class="string">'C'</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">"test when"</span>)</span><br><span class="line">        <span class="string">"OK"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">'D'</span> -&gt; <span class="string">"BAD"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"UN_KNOW"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，when语句还可以取代java中的if/else if，其是表达式有值，并且更佳简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的if else</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPoint2</span><span class="params">(Integer point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (point &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GOOD"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point &gt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point.hashCode() == <span class="number">0x100</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"STH"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UN_KNOW"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看kotlin的版本，使用<strong>不带参数的when</strong>，只需要6行代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，when是表达式，可以取代java的if/else，when的每个分支的最后一行为当前分支的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPoint2</span><span class="params">(grade: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    grade &gt; <span class="number">90</span> -&gt; <span class="string">"GOOD"</span></span><br><span class="line">    grade &gt; <span class="number">60</span> -&gt; <span class="string">"OK"</span></span><br><span class="line">    grade.hashCode() == <span class="number">0x100</span> -&gt; <span class="string">"STH"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"UN_KNOW"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip3-更好调用的函数-显式参数名及默认参数值"><a href="#Tip3-更好调用的函数-显式参数名及默认参数值" class="headerlink" title="Tip3-更好调用的函数-显式参数名及默认参数值"></a>Tip3-更好调用的函数-显式参数名及默认参数值</h2><p><a href="#目录">回到目录</a></p><h4 id="显式参数名"><a href="#显式参数名" class="headerlink" title="显式参数名"></a>显式参数名</h4><p>Kotlin的函数更加好调用，主要是表现在两个方面：1，显式的<strong>标示参数名</strong>，可以方便代码阅读；2，函数可以有<strong>默认参数值</strong>，可以大大<strong>减少Java中的函数重载</strong>。<br>例如现在需要实现一个工具函数，打印列表的内容：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip3/KotlinTip3.kt" target="_blank" rel="noopener">KotlinTip3</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 打印列表的内容</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                     separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     prefix: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     postfix: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 不标明参数名</span></span><br><span class="line">    println(joinToString(list, <span class="string">" - "</span>, <span class="string">"["</span>, <span class="string">"]"</span>))</span><br><span class="line">    <span class="comment">// 显式的标明参数名称</span></span><br><span class="line">    println(joinToString(list, separator = <span class="string">" - "</span>, prefix = <span class="string">"["</span>, postfix = <span class="string">"]"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码所示，函数joinToString想要打印列表的内容，需要传入四个参数：列表、分隔符、前缀和后缀。<br>由于参数很多，在后续使用该函数的时候不是很直观的知道每个参数是干什么用的，这时候可以显式的标明参数名称，增加代码可读性。</p><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>同时，定义函数的时候还可以给函数默认的参数，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 打印列表的内容，带有默认的参数，可以避免java的函数重载</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                      separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    println(joinToString2(list, <span class="string">" - "</span>))</span><br><span class="line">    println(joinToString2(list, <span class="string">" , "</span>, <span class="string">"["</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样有了默认参数后，在使用函数时，如果不传入该参数，默认会使用默认的值，这样可以避免Java中大量的函数重载。</p><h4 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h4><p>在java与kotlin的混合项目中，会发现用kotlin实现的带默认参数的函数，在java中去调用的化就不能利用这个特性了，还是需要给所有参数赋值，像下面java这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123;add(<span class="number">2</span>);add(<span class="number">4</span>);add(<span class="number">0</span>);&#125;&#125;;</span><br><span class="line">String res = joinToString2(arr, <span class="string">"-"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure></p><p>这时候可以在kotlin的函数前添加注解@JvmOverloads，添加注解后翻译为class的时候kotlin会帮你去生成多个函数实现函数重载，kotlin代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过注解@JvmOverloads解决java调用kotlin时不支持默认参数的问题</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2New</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样以后，java调用kotlin的带默认参数的函数就跟kotlin一样方便了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123;add(<span class="number">2</span>);add(<span class="number">4</span>);add(<span class="number">0</span>);&#125;&#125;;</span><br><span class="line">String res = joinToString2New(arr, <span class="string">"-"</span>);</span><br><span class="line">System.out.println(res);</span><br><span class="line">String res2 = joinToString2New(arr, <span class="string">"-"</span>, <span class="string">"=&gt;"</span>);</span><br><span class="line">System.out.println(res2);</span><br></pre></td></tr></table></figure></p><h2 id="Tip4-扩展函数和属性"><a href="#Tip4-扩展函数和属性" class="headerlink" title="Tip4-扩展函数和属性"></a>Tip4-扩展函数和属性</h2><p><a href="#目录">回到目录</a></p><p>扩展函数和扩展属性是Kotlin非常方便实用的一个功能，它可以让我们随意的扩展第三方的库，你如果觉得别人给的SDK的Api不好用，或者不能满足你的需求，这时候你可以用扩展函数完全去自定义。</p><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><p>例如String类中，我们想获取最后一个字符，String中没有这样的直接函数，你可以用.后声明这样一个扩展函数：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/KotlinTip4.kt" target="_blank" rel="noopener">KotlinTip4</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFunExtension</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"test extension fun"</span>;</span><br><span class="line">    println(str.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样定义好lastChar()函数后，之后只需要import进来后，就可以用String类直接调用该函数了，跟调用它自己的方法没有区别。这样可以避免重复代码和一些静态工具类，而且代码更加简洁明了。<br>例如我们可以改造上面tip3中的打印列表内容的函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用扩展函数改造Tip3中的列表打印内容函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString3</span><span class="params">(separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    println(list.joinToString3(<span class="string">"/"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>除了扩展函数，还可以扩展属性，例如我想实现String和StringBuilder通过属性去直接获得最后字符：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展属性 lastChar获取String的最后一个字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展属性 lastChar获取StringBuilder的最后一个字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value: <span class="built_in">Char</span>) &#123;</span><br><span class="line">        setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testExtension</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line">    println(s.lastChar)</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder(<span class="string">"abc"</span>)</span><br><span class="line">    println(sb.lastChar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义好扩展属性后，之后只需import完了就跟使用自己的属性一样方便了。</p><h4 id="Why？Kotlin为什么能实现扩展函数和属性这样的特性？"><a href="#Why？Kotlin为什么能实现扩展函数和属性这样的特性？" class="headerlink" title="Why？Kotlin为什么能实现扩展函数和属性这样的特性？"></a>Why？Kotlin为什么能实现扩展函数和属性这样的特性？</h4><p>在Kotlin中要理解一些语法，只要认识到<strong>Kotlin语言最后需要编译为class字节码，Java也是编译为class执行，也就是可以大致理解为Kotlin需要转成Java一样的语法结构</strong>，<br>Kotlin就是一种<strong>强大的语法糖</strong>而已，Java不具备的功能Kotlin也不能越界的。</p><ul><li>那Kotlin的扩展函数怎么实现的呢？介绍一种万能的办法去理解Kotlin的语法：<strong>将Kotlin代码转化成Java语言</strong>去理解，步骤如下：<ul><li>在Android Studio中选择Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode 这样就把Kotlin转化为class字节码了</li><li>class码阅读不太友好，点击左上角的Decompile就转化为Java</li></ul></li><li>再介绍一个小窍门，在前期对Kotlin语法不熟悉的时候，可以先用Java写好代码，再利用AndroidStudio工具<strong>将Java代码转化为Kotlin代码</strong>，步骤如下：<ul><li>在Android Studio中选中要转换的Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File</li></ul></li></ul><p>我们看看将上面的扩展函数转成Java后的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展函数会转化为一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">lastChar</span><span class="params">(@NotNull String $receiver)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.charAt($receiver.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">getLastChar</span><span class="params">(@NotNull StringBuilder $receiver)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.charAt($receiver.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setLastChar</span><span class="params">(@NotNull StringBuilder $receiver, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    $receiver.setCharAt($receiver.length() - <span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看上面的代码可知：对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象，这样把类的实例传入函数以后，函数内部就可以访问到类的公有方法。<br>对于扩展属性也类似，获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象，设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象。<br>函数内部可以访问公有的方法和属性。顶层的扩展函数是static的，<strong>不能被override</strong></p><ul><li><p>从上面转换的源码其实可以看到<strong>扩展函数和扩展属性适用的地方和缺陷</strong>：</p><ul><li>扩展函数和扩展属性内<strong>只能访问到类的公有方法和属性</strong>，私有的和protected是访问不了的</li><li><p>扩展函数<strong>不是真的修改了原来的类</strong>，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型，案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/StaticllyExtension.kt" target="_blank" rel="noopener">StaticllyExtension.kt</a></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">C</span></span>()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* https://kotlinlang.org/docs/reference/extensions.html</span></span><br><span class="line"><span class="comment">* Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,</span></span><br><span class="line"><span class="comment">* but merely make new functions callable with the dot-notation on variables of this type. Extension functions are</span></span><br><span class="line"><span class="comment">* dispatched statically.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">  println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testStatically</span><span class="params">()</span></span> &#123;</span><br><span class="line">  printFoo(C()) <span class="comment">// print c</span></span><br><span class="line">  printFoo(D()) <span class="comment">// also print c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面的案例中即使调用printFoo(D())还是打印出c，而不是d。转成java中会看到下面的代码，D类型在调用的时候会强制转换为C类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">foo</span><span class="params">(@NotNull C $receiver)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">foo</span><span class="params">(@NotNull D $receiver)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"d"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printFoo</span><span class="params">(@NotNull C c)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull(c, <span class="string">"c"</span>);</span><br><span class="line">  String var1 = foo(c);</span><br><span class="line">  System.out.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">testStatically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printFoo(<span class="keyword">new</span> C());</span><br><span class="line">  printFoo((C)(<span class="keyword">new</span> D()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>声明扩展函数作为类的成员变量<ul><li>上面的例子扩展函数是作为顶层函数，如果把扩展函数申明为类的成员变量，即扩展函数的作用域就在类的内部有效，案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/ExtensionsAsMembers.kt" target="_blank" rel="noopener">ExtensionsAsMembers.kt</a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// call the extension function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAsMembers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C().caller(D())   <span class="comment">// prints "D.foo in C"</span></span><br><span class="line">    C1().caller(D())  <span class="comment">// prints "D.foo in C1" - dispatch receiver is resolved virtually</span></span><br><span class="line">    C().caller(D1())  <span class="comment">// prints "D.foo in C" - extension receiver is resolved statically</span></span><br><span class="line">    C1().caller(D1()) <span class="comment">// prints "D.foo in C1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>函数caller的类型是D，即使调用C().caller(D1())，打印的结果还是D.foo in C，而不是D1.foo in C，不是运行时来动态决定类型，成员扩展函数申明为open，<br>一旦在子类中被override，就调用不到在父类中的扩展函数，在子类中的作用域内的只能访问到override后的函数，不能像普通函数override那样通过super关键字访问了。</p><ul><li>下面再举几个扩展函数的例子，让大家感受一下扩展函数的方便：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* show toast in activity</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">toast</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Context.inputMethodManager: InputMethodManager?</span><br><span class="line">    <span class="keyword">get</span>() = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span> InputMethodManager</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* hide soft input</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">hideSoftInput</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    inputMethodManager?.hideSoftInputFromWindow(view.windowToken, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * screen width in pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Context.screenWidth</span><br><span class="line">    <span class="keyword">get</span>() = resources.displayMetrics.widthPixels</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * screen height in pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Context.screenHeight</span><br><span class="line">    <span class="keyword">get</span>() = resources.displayMetrics.heightPixels</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * returns dip(dp) dimension value in pixels</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">dip2px</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = (value * resources.displayMetrics.density).toInt()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Tip5-懒初始化bylazy和延迟初始化lateinit"><a href="#Tip5-懒初始化bylazy和延迟初始化lateinit" class="headerlink" title="Tip5-懒初始化bylazy和延迟初始化lateinit"></a>Tip5-懒初始化bylazy和延迟初始化lateinit</h2><p><a href="#目录">回到目录</a></p><h4 id="懒初始化by-lazy"><a href="#懒初始化by-lazy" class="headerlink" title="懒初始化by lazy"></a>懒初始化by lazy</h4><p>懒初始化是指推迟一个变量的初始化时机，变量在使用的时候才去实例化，这样会更加的高效。因为我们通常会遇到这样的情况，一个变量直到使用时才需要被初始化，或者仅仅是它的初始化依赖于某些无法立即获得的上下文。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip5/KotlinTip5.kt" target="_blank" rel="noopener">KotlinTip5</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒初始化api实例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> purchasingApi: PurchasingApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit: Retrofit = Retrofit.Builder()</span><br><span class="line">            .baseUrl(API_URL)</span><br><span class="line">            .addConverterFactory(MoshiConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">    retrofit.create(PurchasingApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面的代码，retrofit生成的api实例会在首次使用到的时候才去实例化。需要注意的是by lazy一般只能修饰val不变的对象，不能修饰var可变对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒初始化by lazy</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> user1: User <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    User(<span class="string">"jack"</span>, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="延迟初始化lateinit"><a href="#延迟初始化lateinit" class="headerlink" title="延迟初始化lateinit"></a>延迟初始化lateinit</h4><p>另外，对于var的变量，如果类型是非空的，是必须初始化的，不然编译不通过，这时候需要用到lateinit延迟初始化，使用的时候再去实例化。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 延迟初始化lateinit</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user2: User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLateInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user2 = User(<span class="string">"Lily"</span>, <span class="number">14</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="by-lazy-和-lateinit-的区别"><a href="#by-lazy-和-lateinit-的区别" class="headerlink" title="by lazy 和 lateinit 的区别"></a>by lazy 和 lateinit 的区别</h4><ul><li>by lazy 修饰val的变量</li><li>lateinit 修饰var的变量，且变量是非空的类型</li></ul><h2 id="Tip6-不用再手写findViewById"><a href="#Tip6-不用再手写findViewById" class="headerlink" title="Tip6-不用再手写findViewById"></a>Tip6-不用再手写findViewById</h2><p><a href="#目录">回到目录</a></p><h4 id="在Activity中使用"><a href="#在Activity中使用" class="headerlink" title="在Activity中使用"></a>在Activity中使用</h4><p>在Android的View中，会有很多代码是在声明一个View，然后通过findViewById后从xml中实例化赋值给对应的View。在kotlin中可以完全解放出来了，利用kotlin-android-extensions插件，不用再手写findViewById。步骤如下：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip6/KotlinTip6.kt" target="_blank" rel="noopener">KotlinTip6</a></p><ul><li>步骤1，在项目的gradle中 apply plugin: ‘kotlin-android-extensions’</li><li><p>步骤2，按照原来的习惯书写布局xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Tv"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Img"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Btn"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤3，在java代码中import对应的布局就可以开始使用了，View不用提前声明，插件会自动根据布局的id生成对应的View成员（其实没有生成属性，原理见下面）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sw.kotlin.tips.R</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 导入插件生成的View</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_tip6.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTip6</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自动根据layout的id生成对应的view</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_tip6)</span><br><span class="line">        tip6Tv.text = <span class="string">"Auto find view for TextView"</span></span><br><span class="line">        tip6Img.setImageBitmap(<span class="literal">null</span>)</span><br><span class="line">        tip6Btn.setOnClickListener &#123;</span><br><span class="line">            test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tip6Tv.text = <span class="string">"update"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>像上面代码这样，Activity里的三个View自动生成了，不用再去声明，然后findViewById，然后转型赋值，是不是减少了很多没必要的代码，让代码非常的干净。</p><h4 id="Why？原理是什么？插件帮我们做了什么？"><a href="#Why？原理是什么？插件帮我们做了什么？" class="headerlink" title="Why？原理是什么？插件帮我们做了什么？"></a>Why？原理是什么？插件帮我们做了什么？</h4><p>要看原理还是将上面的代码转为java语言来理解，参照tips4提供的方式转换为如下的java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinTip6</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      <span class="keyword">this</span>.setContentView(<span class="number">2131296284</span>);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">"Auto find view for TextView"</span>);</span><br><span class="line">      ((ImageView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Img)).setImageBitmap((Bitmap)<span class="keyword">null</span>);</span><br><span class="line">      ((Button)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Btn)).setOnClickListener((OnClickListener)(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View it)</span> </span>&#123;</span><br><span class="line">            KotlinTip6.<span class="keyword">this</span>.test();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence) <span class="string">"update"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(Integer.valueOf(var1));</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         var2 = <span class="keyword">this</span>.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(Integer.valueOf(var1), var2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> _$_clearFindViewByIdCache() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.clear();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码所示，在编译阶段，插件会帮我们生成视图缓存，视图由一个Hashmap结构的_$_findViewCache变量缓存，<br>会根据对应的id先从缓存里查找，缓存没命中再去真正调用findViewById查找出来，再存在HashMap中。</p><h4 id="子View或者include标签中findViewById"><a href="#子View或者include标签中findViewById" class="headerlink" title="子View或者include标签中findViewById"></a>子View或者include标签中findViewById</h4><p>子子View或者include标签中，同样可以省略findViewById，但需要主要默认的activity的布局import是不会将这个include的View引入进来<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/layout_tip6"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//include layout</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/test_inside_id"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/app_name"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>需要我们引入对应的View的id，像这样import kotlinx.android.synthetic.main.layout_tip6.*<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入插件生成的View</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_tip6.*</span><br><span class="line"><span class="comment">//include layout的View</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.layout_tip6.*</span><br><span class="line"></span><br><span class="line">test_inside_id.text = <span class="string">"Test include"</span></span><br></pre></td></tr></table></figure></p><h4 id="在Fragment中findViewById"><a href="#在Fragment中findViewById" class="headerlink" title="在Fragment中findViewById"></a>在Fragment中findViewById</h4><p>在Fragment中也类似，但有一点需要注意但地方，例子如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tip6Fragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>?, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater?.inflate(R.layout.fragment_tip6, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这时候不能在onCreateView方法里用view，需要在onViewCreate里，原理是插件用了getView来findViewById</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">// tip6Tv.text = "test2"</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要在onViewCreate里，原理是插件用了getView来findViewById</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        tip6Tv.text = <span class="string">"test"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，Fragment需要注意，不能在onCreateView方法里用view，不然会出现空指针异常，需要在onViewCreate里，原理是插件用了getView来findViewById，<br>我们看看将上面的代码转成java后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tip6Fragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@Nullable LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      View view = inflater != <span class="keyword">null</span>?inflater.inflate(<span class="number">2131296286</span>, container, <span class="keyword">false</span>):<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@Nullable View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">"test"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(Integer.valueOf(var1));</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         View var10000 = <span class="keyword">this</span>.getView();</span><br><span class="line">         <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         var2 = var10000.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(Integer.valueOf(var1), var2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> _$_clearFindViewByIdCache() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">      <span class="keyword">this</span>._$_clearFindViewByIdCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟Activity中类似，会有一个View的HashMap，关键不同的地方在_$<em>findCachedViewById里面，需要getView获得当前Fragment的View，<br>故在onViewCreated中getView还是空的，原理就好理解了。另外在onDestroyView会调用</em>$_clearFindViewByIdCache方法清掉缓存。</p><h2 id="Tip7-利用局部函数抽取重复代码"><a href="#Tip7-利用局部函数抽取重复代码" class="headerlink" title="Tip7-利用局部函数抽取重复代码"></a>Tip7-利用局部函数抽取重复代码</h2><p><a href="#目录">回到目录</a></p><h4 id="局部函数抽取代码"><a href="#局部函数抽取代码" class="headerlink" title="局部函数抽取代码"></a>局部函数抽取代码</h4><p>Kotlin中提供了函数的嵌套，在函数内部还可以定义新的函数。这样我们可以在函数中嵌套这些提前的函数，来抽取重复代码。如下面的案例所示:<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip7/KotlinTip7.kt" target="_blank" rel="noopener">KotlinTip7</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String, <span class="keyword">val</span> email: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Address"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.email.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Email"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码在判断name、address等是否为空的处理其实很类似。这时候，我们可以利用在函数内部嵌套的声明一个通用的判空函数将相同的代码抽取到一起：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用局部函数抽取相同的逻辑，去除重复的代码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser2</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fildName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$fildName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(user.name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(user.address, <span class="string">"Address"</span>)</span><br><span class="line">    validate(user.email, <span class="string">"Email"</span>)</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="扩展函数抽取代码"><a href="#扩展函数抽取代码" class="headerlink" title="扩展函数抽取代码"></a>扩展函数抽取代码</h4><p>除了利用嵌套函数去抽取，此时，其实也可以用扩展函数来抽取，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用扩展函数抽取逻辑</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fildName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="variable">$id</span>: empty <span class="variable">$fildName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(address, <span class="string">"Address"</span>)</span><br><span class="line">    validate(email, <span class="string">"Email"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser3</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateAll()</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip8-使用数据类来快速实现model类"><a href="#Tip8-使用数据类来快速实现model类" class="headerlink" title="Tip8-使用数据类来快速实现model类"></a>Tip8-使用数据类来快速实现model类</h2><p><a href="#目录">回到目录</a></p><p>在java中要声明一个model类需要实现很多的代码，首先需要将变量声明为private，然后需要实现get和set方法，还要实现对应的hashcode equals toString方法等，如下所示：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip8" target="_blank" rel="noopener">Tip8</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">int</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender="</span> + gender +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (gender != user.gender) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> ? !name.equals(user.name) : user.name != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> address != <span class="keyword">null</span> ? address.equals(user.address) : user.address == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        result = <span class="number">31</span> * result + gender;</span><br><span class="line">        result = <span class="number">31</span> * result + (address != <span class="keyword">null</span> ? address.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码Java需要70行左右，而如果用kotlin，只需要一行代码就可以做到。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kotlin会为类的参数自动实现get set方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> gender: <span class="built_in">Int</span>, <span class="keyword">var</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用data关键词来声明一个数据类，除了会自动实现get set，还会自动生成equals hashcode toString</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> gender: <span class="built_in">Int</span>, <span class="keyword">var</span> address: String)</span><br></pre></td></tr></table></figure></p><p>对于Kotlin中的类，会为它的参数自动实现get set方法。而如果加上data关键字，还会自动生成equals hashcode toString。原理其实数据类中的大部分代码都是模版代码，Kotlin聪明的将这个模版代码的实现放在了编译器处理的阶段。</p><h2 id="Tip9-用类委托来快速实现装饰器模式"><a href="#Tip9-用类委托来快速实现装饰器模式" class="headerlink" title="Tip9-用类委托来快速实现装饰器模式"></a>Tip9-用类委托来快速实现装饰器模式</h2><p><a href="#目录">回到目录</a></p><p>通过继承的实现容易导致脆弱性，例如如果需要修改其他类的一些行为，这时候Java中的一种策略是采用<strong>装饰器模式</strong>：创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个成员变量。<br>与原始类拥有相同行为的方法不用修改，只需要直接转发给原始类的实例。如下所示：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip9/KotlinTip9.kt" target="_blank" rel="noopener">KotlinTip9</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常见的装饰器模式，为了修改部分的函数，却需要实现所有的接口函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectAdded = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = innerSet.size</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要修改的方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要修改的方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.contains(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.containsAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        innerSet.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: MutableIterator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.remove(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.removeAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">retainAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.retainAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，想要修改HashSet的某些行为函数add和addAll，需要实现MutableCollection接口的所有方法，将这些方法转发给innerSet去具体的实现。虽然只需要修改其中的两个方法，其他代码都是模版代码。<br><strong>只要是重复的模版代码，Kotlin这种全新的语法糖就会想办法将它放在编译阶段再去生成。</strong><br>这时候可以用到<strong>类委托by关键字</strong>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet2</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了，通过类委托将10行代码就可以实现上面接近100行的功能，简洁明了，去掉了模版代码。</p><h2 id="Tip10-Lambda表达式简化OnClickListener"><a href="#Tip10-Lambda表达式简化OnClickListener" class="headerlink" title="Tip10-Lambda表达式简化OnClickListener"></a>Tip10-Lambda表达式简化OnClickListener</h2><p><a href="#目录">回到目录</a></p><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip10/KotlinTip10.kt" target="_blank" rel="noopener">KotlinTip10</a><br>lambda表达式可以简化我们的代码。以Android中常见的OnClickListener来说明，在Java中我们一般这样设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextView textView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Java中需要声明一个匿名内部类去处理，这种情况可以用lambda表达式来简化。</p><ul><li>lambda表达式一般长这样<ul><li>{ x:Int, y:Int -&gt; x+y }</li><li>参数 -&gt; 表达式 并且始终在大括号中</li><li>it作为默认参数名</li><li>lambda捕捉，当捕捉final变量时，它的值和lambda代码一起存储</li><li>非final变量，它的值被封装在一个特殊的包装器中，这个包装器的引用会和lambda代码一起存储</li></ul></li></ul><p>我们来看看Kotlin中的例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> textView = TextView(context)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 传统方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(<span class="keyword">object</span> : android.view.View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda的方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当lambda的参数没有使用时可以省略，省略的时候用it来替代<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda的参数如果没有使用可以省略，省略的时候用it来替代</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(&#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>lambda在参数的最后一个的情况可以将之提出去<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda在参数的最后一个的情况可以将之提出去</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener() &#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lambda提出去之后，函数如果没有其他参数括号可以省略<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda提出去之后，函数如果没有其他参数括号可以省略</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再看看如果自己去实现一个带lambda参数的函数应该怎么去定义：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> listener: OnClickListener? = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 传统方式</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClickListener</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSth</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// some case:</span></span><br><span class="line">        listener?.onClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 声明lambda方式，listener: () -&gt; Unit</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在函数参数中需要声明lambda的类型后，再调用该函数的时候就可以传入一个lambda表达式了。</p><h2 id="Tip11-with函数来简化代码"><a href="#Tip11-with函数来简化代码" class="headerlink" title="Tip11-with函数来简化代码"></a>Tip11-with函数来简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li><p>with 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure></li><li><p>with函数并不是扩展函数，返回值是最后一行，可以直接调用对象的方法</p></li></ul><p>Kotlin中可以用with语句来省略同一个变量的多次声明，例如下面的函数<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip11/KotlinTip11.kt" target="_blank" rel="noopener">KotlinTip11</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*打印字母表函数，在函数内result变量在好几处有使用到</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    result.append(<span class="string">"START\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">"\nEND"</span>)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的函数中，result变量出现了5次，如果用with语句，可以将这5次都不用再出现了，我们来一步一步地看是怎么实现的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.append(<span class="string">"\nEND"</span>)</span><br><span class="line">        <span class="keyword">this</span>.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了，而且这个this是可以省略的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，将result参数作为参数，在内部this也可以省略掉</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(result) &#123;</span><br><span class="line">        append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nEND"</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部this省略掉后，现在只有一个result了，这个其实也是没必要的，于是出现了下面的最终版本：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，可以直接将对象传入，省掉对象的声明</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet4</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nEND"</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面这样，我们可以把同一个变量的显式调用从5次变为0次，发现Kotlin的魅力了吧。</p><h2 id="Tip12-apply函数来简化代码"><a href="#Tip12-apply函数来简化代码" class="headerlink" title="Tip12-apply函数来简化代码"></a>Tip12-apply函数来简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li><p>apply 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象</p></li></ul><p>除了用上面的with可以简化同一个变量的多次声明，还可以用apply关键字，我们来改造一下tip11中的函数：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip12/KotlinTip12.kt" target="_blank" rel="noopener">KotlinTip12</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用apply语句简化代码，在apply的大括号里可以访问类的公有属性和方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet5</span><span class="params">()</span></span> = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">"START\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nEND"</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure></p><p>像上面这样的，通过apply后，在apply的大括号里可以访问类的公有属性和方法。这在对应类的初始化是非常方便的，例如下面的例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用apply语句简化类的初始化，在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testApply</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> imgView = ImageView(context).apply &#123;</span><br><span class="line">        setBackgroundColor(<span class="number">0</span>)</span><br><span class="line">        setImageBitmap(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textView = TextView(context).apply &#123;</span><br><span class="line">        text = <span class="string">"content"</span></span><br><span class="line">        textSize = <span class="number">20.0f</span></span><br><span class="line">        setPadding(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> user = User().apply &#123; </span><br><span class="line">        age = <span class="number">15</span></span><br><span class="line">        name = <span class="string">"Jack"</span></span><br><span class="line">        <span class="keyword">val</span> a = address</span><br><span class="line">        address = <span class="string">"bbb"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁</p><h2 id="Tip13-在编译阶段避免掉NullPointerException"><a href="#Tip13-在编译阶段避免掉NullPointerException" class="headerlink" title="Tip13-在编译阶段避免掉NullPointerException"></a>Tip13-在编译阶段避免掉NullPointerException</h2><p><a href="#目录">回到目录</a></p><h4 id="可空类型和不可空类型"><a href="#可空类型和不可空类型" class="headerlink" title="可空类型和不可空类型"></a>可空类型和不可空类型</h4><p>NullPointerException是Java程序员非常头痛的一个问题，我们知道Java 中分受检异常和非受检异常，NullPointerException是非受检异常，也就是说NullPointerException不需要显示的去catch住，<br>往往在运行期间，程序就可能报出一个NullPointerException然后crash掉，Kotlin作为一门高效安全的语言，它尝试在编译阶段就把空指针问题显式的检测出来，把问题留在了编译阶段，让程序更加健壮。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip13/KotlinTip13.kt" target="_blank" rel="noopener">KotlinTip13</a></p><ul><li><p>Kotlin中类型分为可空类型和不可空类型，通过？代表可空，不带？代表不可为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNullType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: String = <span class="string">"aa"</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * a是非空类型，下面的给a赋值为null将会编译不通过</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">// a = null</span></span><br><span class="line">    a.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * ？声明是可空类型，可以赋值为null</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">var</span> b: String? = <span class="string">"bb"</span></span><br><span class="line">    b = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * b是可空类型，直接访问可空类型将编译不通过，需要通过?.或者!!.来访问</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">// b.length</span></span><br><span class="line">    b?.length</span><br><span class="line">    b!!.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过</p></li><li>对于一个可空类型：通过？声明，在访问该类型的时候直接访问不能编译通过，需要通过?.或者!!.<ul><li>?.  代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性</li><li>!!. 代表着如果该类型为空的话就抛出NullPointerException，如果不为空就去访问对应的方法或者属性，<br>所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出NullPointerException。<br>而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不推荐这样的写法：链式的连续用!!.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> user = User()</span><br><span class="line">user!!.name!!.subSequence(<span class="number">0</span>,<span class="number">5</span>)!!.length</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>对应一个可空类型，每次对它的访问都需要带上?.判断<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user: User? = User()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 每次访问都用用?.判断</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    user?.name</span><br><span class="line">    user?.age</span><br><span class="line">    user?.toString()</span><br></pre></td></tr></table></figure></p><p>但这样多了很多代码，kotlin做了一些优化，<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 或者提前判断是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    user.name</span><br><span class="line">    user.age</span><br><span class="line">    user.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过if提前判断类型是否为空，如果不为空在这个分支里会<strong>自动转化为非空类型</strong>就可以直接访问了。</p><h4 id="let语句简化对可空对象对访问"><a href="#let语句简化对可空对象对访问" class="headerlink" title="let语句简化对可空对象对访问"></a>let语句简化对可空对象对访问</h4><ul><li><p>let 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></li><li><p>let函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。</p></li></ul><p>上面的代码还可以用?.let语句进行，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">user?.let &#123;</span><br><span class="line">    it.name</span><br><span class="line">    it.age</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</p><h4 id="Elvis操作符-简化对空值的处理"><a href="#Elvis操作符-简化对空值的处理" class="headerlink" title="Elvis操作符 ?: 简化对空值的处理"></a>Elvis操作符 ?: 简化对空值的处理</h4><p>如果值可能为空，对空值的处理可能会比较麻烦，像下面这样：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对空值的处理</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testElvis</span><span class="params">(input: <span class="type">String</span>?, user: <span class="type">User</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span>?</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        a = -<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = input?.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> newOne = User()</span><br><span class="line">        newOne.save()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        user.save()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Elvis操作符?:能够简化上面的操作，?:符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。<strong>跟?.let正好相反</strong>，例如我们可以用两行代码来简化上面从操作：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Elvis操作符 ?: 简化对空值的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testElvis2</span><span class="params">(input: <span class="type">String</span>?, user: <span class="type">User</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = input?.length ?: -<span class="number">1</span>;</span><br><span class="line">    user?.save() ?: User().save()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip14-运算符重载"><a href="#Tip14-运算符重载" class="headerlink" title="Tip14-运算符重载"></a>Tip14-运算符重载</h2><p><a href="#目录">回到目录</a></p><p>Kotlin支持对运算符的重载，这对于对一些对象的操作更加灵活直观。</p><ul><li>使用operator来修饰plus\minus函数</li><li>可重载的二元算术符<ul><li>A * B  times</li><li>A / B  div</li><li>A % B  mod</li><li>A + B  plus</li><li>A - B  minus</li></ul></li></ul><p>以下面对坐标点Point的案例说明怎么去重载运算符：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip14/KotlinTip14.kt" target="_blank" rel="noopener">KotlinTip14</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * plus函数重载对Point对象的加法运算符</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * minus函数重载对Point对象的减法运算符</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - other.x, y - other.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[x:<span class="variable">$x</span>, y:<span class="variable">$y</span>]"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，通过plus函数重载对Point对象的加法运算符，通过minus函数重载对Point对象的减法运算符，然后就可以用+、-号对两个对象进行操作了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testOperator</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point1 = Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> point2 = Point(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> point3 = point1 + point2</span><br><span class="line">    println(point3)</span><br><span class="line">    println(point1 - point2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip15-高阶函数简化代码"><a href="#Tip15-高阶函数简化代码" class="headerlink" title="Tip15-高阶函数简化代码"></a>Tip15-高阶函数简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li>高阶函数：以另一个函数作为参数或者返回值的函数</li><li>函数类型   <ul><li>(Int, String) -&gt; Unit</li><li>参数类型-&gt;返回类型 Unit不能省略</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 传入函数来过滤</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">println(list.filter &#123; it &gt; <span class="number">4</span> &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义函数类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> action = &#123; println(<span class="number">42</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sum2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> action2: () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="number">42</span>) &#125;</span><br></pre></td></tr></table></figure><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>函数作为参数，即高阶函数中，函数的参数可以是一个函数类型，例如要定义一个函数，该函数根据传入的操作函数来对2和3做相应的处理。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip15/KotlinTip15.kt" target="_blank" rel="noopener">KotlinTip15</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义对2和3的操作函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoAndThree</span><span class="params">(<span class="keyword">operator</span>: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">operator</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    println(<span class="string">"Result:<span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">    twoAndThree &#123; a, b -&gt; a + b &#125;</span><br><span class="line">    twoAndThree &#123; a, b -&gt; a * b &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator是函数类型，函数的具体类型为(Int, Int) -&gt; Int，即输入两个Int返回一个Int值。定义完了后就可以像上面这样使用了。<br>再举一个例子，实现String类的字符过滤：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 函数作为参数，实现String类的字符过滤</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">filter</span><span class="params">(predicate: (<span class="type">Char</span>)</span></span> -&gt; <span class="built_in">Boolean</span>): String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until length) &#123;</span><br><span class="line">        <span class="keyword">val</span> element = <span class="keyword">get</span>(index)</span><br><span class="line">        <span class="keyword">if</span> (predicate(element)) sb.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test04</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"12eafsfsfdbzzsa"</span>.filter &#123; it <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'f'</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面这样predicate是函数类型，它会根据传入的char来判断得到一个Boolean值。</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>函数作为返回值也非常实用，例如我们的需求是根据不同的快递类型返回不同计价公式，普通快递和高级快递的计价规则不一样，这时候我们可以将计价规则函数作为返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span> </span>&#123;</span><br><span class="line">    STANDARD, EXPEDITED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据不同的运输类型返回不同的快递方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getShippingCostCalculator</span><span class="params">(delivery: <span class="type">Delivery</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delivery == Delivery.EXPEDITED) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="number">6</span> + <span class="number">2.1</span> * it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1.3</span> * it &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test05</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> calculator1 = getShippingCostCalculator(Delivery.EXPEDITED)</span><br><span class="line">    <span class="keyword">val</span> calculator2 = getShippingCostCalculator(Delivery.STANDARD)</span><br><span class="line">    println(<span class="string">"Ex costs <span class="subst">$&#123;calculator1(<span class="number">5</span>)&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"St costs <span class="subst">$&#123;calculator2(<span class="number">5</span>)&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是普通快递，采用1.3 <em> it的规则计算价格，如果是高级快递按照6 + 2.1 </em> it计算价格，根据不同的类型返回不同的计价函数。</p><h2 id="Tip16-用Lambda来简化策略模式"><a href="#Tip16-用Lambda来简化策略模式" class="headerlink" title="Tip16-用Lambda来简化策略模式"></a>Tip16-用Lambda来简化策略模式</h2><p><a href="#目录">回到目录</a></p><p>策略模式是常见的模式之一，java的例子如下。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip16" target="_blank" rel="noopener">Tip16</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义策略接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Do A Strategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * B策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Do B Strategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略实施者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"START"</span>);</span><br><span class="line">            <span class="keyword">if</span> (strategy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                strategy.doSth();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"END"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上面的例子所示，有A、B两种策略，Worker根据不同的策略做不同的工作，使用策略时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Worker worker1 = <span class="keyword">new</span> Worker(<span class="keyword">new</span> AStrategy());</span><br><span class="line">Worker worker2 = <span class="keyword">new</span> Worker(<span class="keyword">new</span> BStrategy());</span><br><span class="line">worker1.work();</span><br><span class="line">worker2.work();</span><br></pre></td></tr></table></figure></p><p>在java中实现这种策略模式难免需要先定义好策略的接口，然后根据接口实现不同的策略，<br>在Kotlin中完全可以用用Lambda来简化策略模式，上面的例子用Kotlin实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实施者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strategy lambda类型的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> strategy: () -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"START"</span>)</span><br><span class="line">        strategy.invoke()</span><br><span class="line">        println(<span class="string">"END"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testStrategy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> worker1 = Worker(&#123;</span><br><span class="line">        println(<span class="string">"Do A Strategy"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> bStrategy = &#123;</span><br><span class="line">        println(<span class="string">"Do B Strategy"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> worker2 = Worker(bStrategy)</span><br><span class="line">    worker1.work()</span><br><span class="line">    worker2.work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不需要先定义策略的接口，直接把策略以lambda表达式的形式传进来就行了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li>《Kotlin in Action》</li><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/</a></li><li><a href="https://savvyapps.com/blog/kotlin-tips-android-development" target="_blank" rel="noopener">https://savvyapps.com/blog/kotlin-tips-android-development</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Tip1-更简洁的字符串&quot;&gt;Tip1-更简洁的字符串&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、三个引号  2、字符串模版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip2-Kotlin中大多数控制结构都是表达式&quot;&gt;Tip2-Kotlin中大多数控制结构都是表达式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、语句和表达式  2、if  3、when&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip3-更好调用的函数-显式参数名及默认参数值&quot;&gt;Tip3-更好调用的函数：显式参数名及默认参数值&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、显式参数名  2、默认参数值  3、@JvmOverloads &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip4-扩展函数和属性&quot;&gt;Tip4-扩展函数和属性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、扩展函数  2、扩展属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip5-懒初始化bylazy和延迟初始化lateinit&quot;&gt;Tip5-懒初始化bylazy和延迟初始化lateinit&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、by lazy  2、lateinit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip6-不用再手写findViewById&quot;&gt;Tip6-不用再手写findViewById&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、Activity  2、子View或者include标签  3、Fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip7-利用局部函数抽取重复代码&quot;&gt;Tip7-利用局部函数抽取重复代码&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、局部函数  2、扩展函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip8-使用数据类来快速实现model类&quot;&gt;Tip8-使用数据类来快速实现model类&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip9-用类委托来快速实现装饰器模式&quot;&gt;Tip9-用类委托来快速实现装饰器模式&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip10-Lambda表达式简化OnClickListener&quot;&gt;Tip10-Lambda表达式简化OnClickListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip11-with函数来简化代码&quot;&gt;Tip11-with函数来简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip12-apply函数来简化代码&quot;&gt;Tip12-apply函数来简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip13-在编译阶段避免掉NullPointerException&quot;&gt;Tip13-在编译阶段避免掉NullPointerException&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、可空和不可空类型  2、let  3、Elvis操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip14-运算符重载&quot;&gt;Tip14-运算符重载&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip15-高阶函数简化代码&quot;&gt;Tip15-高阶函数简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip16-用Lambda来简化策略模式&quot;&gt;Tip16-用Lambda来简化策略模式&lt;/a&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
