<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-06T12:39:30.824Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>悖论系列之分金问题</title>
    <link href="http://yoursite.com/2018/12/06/%E6%82%96%E8%AE%BA%E4%B9%8B%E4%B8%89%E5%A7%AC%E5%88%86%E9%87%91/"/>
    <id>http://yoursite.com/2018/12/06/悖论之三姬分金/</id>
    <published>2018-12-06T12:10:53.117Z</published>
    <updated>2018-12-06T12:39:30.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>有一期的问题是：</strong><br>从前有一个国王，一天他的三位妃子想玩一个游戏，这个游戏规则是这样的：</p><ol><li>有100金币供三个人A B C分</li><li>每个人按顺序发言，即提议分配这100金的方案</li><li>如果这个人的发言超过半数的人同意，则方案达成，如果没有，提议的人则要被处死。</li><li>每个人都很聪明而且人性本恶，每个人都想尽量多的获得更多的金币，如果还能杀死对方，那么则更好。<br>问题是：最终这个金币会怎么分？</li></ol><hr><p>想一想。。。。。。。。。。。。。。。。。<br>初想下：A应该分的最少吧，因为最先提</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，我们来假设A已经死了，只剩下B和C来分这个金币会出现什么情况，这个时候其实很简单了，按照第四条原则：B不管提出什么方案，C都不同意，那么C就能分到100金币，并且杀死了A和B。那么，<strong>其实在A死的情况下B也一定死</strong>；所以，B要怎么做才能不死呢，答案只有一个：A不能死。这个情况A是知道的，B也知道。<br>那么就是说：无论A提出什么样的方案，B都会同意，这个时候分配方案是A：100/B：0/C：0，那么也有答案是A应该给一块金币B，那么B更加会同意A，如果A死，B一定死而且一毛钱拿不到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们引申下这个问题，如果来了四个人来分金币，会怎么样呢：M A B C？依然遵循上面的分析过程，M会拿到最多的金币，但是A就是一毛拿不到了，B和C反而会各拿到1个金币（大家想想是不是）：如果M死了，B和C都会一毛拿不到，这个时候M如果给B和C一人一个金币，那么B和C必然赞同，而A为了自己利益最大化，当然是想把M干掉，但是BC同意的话A的意见也没什么作用了。</p><p>这个问题很像现在的社会，国家也一样，老大永远提防老二，而老二永远想干掉老大，老大为了压制老二还会去讨好老三老四组成联盟。这个问题其实蛮有趣的，以前没想过这个问题，现在慢慢发现，很多问题其实都来源于人性。这个问题就到此，后面会有其它悖论的题目再分析吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="悖论" scheme="http://yoursite.com/tags/%E6%82%96%E8%AE%BA/"/>
    
      <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Flutter V1.0.0发布</title>
    <link href="http://yoursite.com/2018/12/06/Flutter1.0%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2018/12/06/Flutter1.0发布/</id>
    <published>2018-12-06T06:26:33.488Z</published>
    <updated>2018-12-06T07:01:51.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flutter是什么"><a href="#flutter是什么" class="headerlink" title="flutter是什么"></a>flutter是什么</h2><p>Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编写。2018/12/04Google正式发布了它的V1.0.0稳定版本，也就是说移动端的开发有可能会发生革命性的变化。本人第二天看了youtube上的发布会，然后试玩了一下发布会上说的Google三个员工三个月为这场发布会写的Demo app：The history of everything。个人感觉：完全感觉不出是非原生的，动画，过渡非常流畅，而且我还用的是老的Nexus 6P来运行的，这种表现打破了我对跨平台开发的认知，让我相当震撼，也许原生开发真的要被取代了，喊了N多遍的狼来了看来也只是时间问题了。</p><h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>当变化来的时候，也许最好的方式是去拥抱变化，而不是墨守成规，扛着原生开发的大旗拉上kotlin小弟一起为Google的保守势力买单。技术现在发展月来越快，技术更新周期越来越短，这也对开发者提出了更高的要求，你需要不断的学习新东西，去适应这个快速发展的世界；但是，每个人的精力都是有限的，怎样在这个信息爆炸的时代学习到保命技能做到以不变应万变，这就需要你的眼光，高度以及眼界了，形而上的东西看着像套路但是归根结底被前人总结的其实就是这些东西，如果你具有了这些“能力”，你就会敏锐的知道在这些快速发展的技术中，哪些是革命性的？哪些是过渡的？集中精力去学习革命性的技术会让你在以后有先发优势，而如果你选择错误，则只能看着刚学的内容马上就out了。</p><p>个人总结的几点建议：</p><ol><li>不盲目跟风口。如果自己专业领域就是风口，那就是最好，这里说的是不同领域为了去风口而盲目转型，最少要有关联性，而且是你喜欢的。</li><li>跟随大公司。这里的大公司指的是掌握核心科技的公司，站在业界前沿的公司如Google，他们发布的技术有可能就是革命性的。</li><li>对新技术保持永远的好奇心。还是刚说的要去拥抱变化，而不是抵触。</li><li>抓住机会，去更大的平台。大平台的优势不用说了。在技术变革期，大平台是最敏感的。</li><li>在技术外，丰富自己的知识库，多看书，多阅历，多和优秀的人沟通。</li></ol><h2 id="flutter的特性"><a href="#flutter的特性" class="headerlink" title="flutter的特性"></a>flutter的特性</h2><p>这里就贴一些文章，看到的都是各种赞不绝口，希望我也能把它收进武器库。<br><a href="https://mp.weixin.qq.com/s/lYisub0Zg9Yz6o9KsYopvA" target="_blank" rel="noopener">Google 要用 Flutter 一统移动、桌面开发江湖？</a></p><p><a href="https://mp.weixin.qq.com/s/hCIN42OMmmc6HkOveegwWQ" target="_blank" rel="noopener">Flutter 1.0 正式版: Google 的便携 UI 工具包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flutter是什么&quot;&gt;&lt;a href=&quot;#flutter是什么&quot; class=&quot;headerlink&quot; title=&quot;flutter是什么&quot;&gt;&lt;/a&gt;flutter是什么&lt;/h2&gt;&lt;p&gt;Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Https简介</title>
    <link href="http://yoursite.com/2018/12/04/Https%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/04/Https详解/</id>
    <published>2018-12-04T03:42:18.327Z</published>
    <updated>2018-12-04T06:20:44.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><blockquote><p>Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。</p><p>Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_hd.png" alt=""></p><a id="more"></a><p>下面我们来看下加密图解过程：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxukq90qjfj30a50bf3yj.jpg" alt=""></p><p>加密过程解析：</p><ol><li>客户端发送https请求，服务端返回给客户端证书（证书中含有服务端随机产生的非对称加密的公钥P）==非对称加密的算法首推RSA，可以去看原理，其实就是求一个大数的质数分解==</li><li>客户端验证发送的证书是有有效，是否去信任该证书，并随机产生对称加密的密钥K，使用P对K进行加密。</li><li>将加密后的对称加密密钥K传回给服务端，服务端用非对称加密的私钥将其解开，这样服务端和客户端都有了对称加密密钥K了。（这么做的目的是防止在传输过程中K被泄漏）</li><li>以后客户端会通过K进行数据加密，而服务端也会用K进行解密</li><li>1-2是密钥协商过程，3是加密传输过程，其中密钥协商过程解决了对称加密密钥的传输问题，由于非对称加密比对称加密解析效率低，但是安全的多的特点，因此将非对称加密用来传递对称加密密钥，而用对称加密去加解密数据。这样既保证了对称加密密钥，又保证了数据解析过程中效率。</li></ol><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书应该是第三方认证机构颁发出来的，具有签名的一种信任凭证。而证书是需要购买的：<br>免费的：<br>国内沃通：<a href="https://freessl.wosign.com/" target="_blank" rel="noopener">沃通</a><br>国外：<a href="https://www.startssl.com/" target="_blank" rel="noopener">woturs</a></p><blockquote><p>其实，国内这家的根证书也是startssl签发的，实际上也是国外的。</p></blockquote><p><a href="https://www.jianshu.com/p/55e402bcbc18" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;https协议&quot;&gt;&lt;a href=&quot;#https协议&quot; class=&quot;headerlink&quot; title=&quot;https协议&quot;&gt;&lt;/a&gt;https协议&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Http协议是运行在TCP之上的应用层协议，所有传输的内容都是明文的并且客户端和服务器端都是无法验证对方的身份的。Http通常运行在80端口（监听）。&lt;/p&gt;
&lt;p&gt;Https协议则是运行在TCP之上还有一层加密层（SSL/TLS），所有的传输内容都是通过对称加密算法去加密的，而对称加密的密钥则是用服务器上的证书（含有非对称加密公钥）去加密的。Https通常运行在443端口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_hd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Android内存优化（一）</title>
    <link href="http://yoursite.com/2018/11/30/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/30/Android内存优化（一）/</id>
    <published>2018-11-30T03:42:39.112Z</published>
    <updated>2018-12-04T03:30:33.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android内存优化（一）"><a href="#Android内存优化（一）" class="headerlink" title="Android内存优化（一）"></a>Android内存优化（一）</h1><p>在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。</p><a id="more"></a><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap内部使用了一个默认容量为16的数组来存储数据，而数组中每个元素又是一个链表的头结点，所以其实HashMap就是一个数组+链表的数据结构。如图：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxujt3fucij30eo0dijsh.jpg" alt=""></p><p>左边纵向是数组，右边横向为链表。</p><p>这个数据结构中每一个都一个Entry类型，那么Entry的数据结构是怎么样的呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final K key;</span><br><span class="line">V value;</span><br><span class="line">final int hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><p>从中我们可以看到Entry中有key，value，hash值以及下一个结点Entry，那么Entry数据是按照什么规则来存储的呢：通过计算元素key的hash值，然后对HashMap中的数组长度（默认16）取余从而得到该元素应该存在哪里，计算公式为==hash(key)%len==,举一个例子：</p><blockquote><p>hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到<br>hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置</p></blockquote><p>如图：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxujz356pej30fj062weu.jpg" alt=""><br>从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不回覆盖前一个，而是放在链表末尾，从而解决了<strong>Hash冲突</strong>的问题。（问题1:如果key的hash值取余大于15，那么元素该放在哪里？）。</p><p>所以，重点是：我们知道HashMap默认存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap的对象的时候，即使里面没有任何元素，系统也是会分配这么多空间给它的，而且，当我们不断往里面put数据的时候，当达到了一定的容量限制时，HashMap会扩容，而且扩大后的新的空间一定是原来的==两倍==。</p><blockquote><p>扩容条件：HashMap中的数据量&gt;容量*加载因子，默认加载因子是0.75</p></blockquote><p><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">参见HashMap详解</a></p><p>只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费。附上hash函数的实现图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt=""></p><blockquote><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。</p></blockquote><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>SparesArray相比HashMap更省内存，某些条件下性能更好。它的内部规则是通过两个数组来存储数据的，一个存储key，另一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约了内存空间。我们从源码中可以看到key和value分别是用数组表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private int[] mKeys;</span><br><span class="line">private Object[] mValues;</span><br></pre></td></tr></table></figure><p>从源码中看到，SparesArray只能存储key为int类型的数据，同时，SparesArray在存储和读取数据的时候，使用的是<strong>二分查找法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line"> public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从==小到大的顺序排列好==，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。<br>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p><p>使用场景：<br>虽然SparesArray性能好，但是由于其添加，查找，删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，还有有下降，所以使用也是要看使用场景的：</p><ul><li>数据量不大，在千以内（Android开发大部分场景吧）</li><li>key必须为int类型<br>以上就是使用它的场景了。</li></ul><h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>ArrayMap其实也是一个key-value映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用了两个数组存储数据，一个数组记录key的hash值，另外一个数组记录value值，和SparesArray一样，也会对可以使用二分法进行从小到大的排序，在添加，删除，查找数据的时候都是使用二分法查到相应的index，然后通过index来进行操作，它的使用场景：</p><ul><li>数据量不大，千以内</li><li>数据结构为Map类型</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>如果我们要兼容api19以下版本，那么导入V4包<br>import android.support.v4.util.ArrayMap;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android内存优化（一）&quot;&gt;&lt;a href=&quot;#Android内存优化（一）&quot; class=&quot;headerlink&quot; title=&quot;Android内存优化（一）&quot;&gt;&lt;/a&gt;Android内存优化（一）&lt;/h1&gt;&lt;p&gt;在Android开发的时候，我们大部分使用的是java的api，但是对于移动端来说，内存是一个很敏感的资源，如果不注意的话很容易crash，而内存优化又没有一个可以立竿见影的东西说是使用了就会很显著的降低内存消耗，而是需要在代码中根据具体的使用场景来合理去优化，每个细节都做到了优化那么整体的性能当然就会提升。所针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray（稀疏数组）以及ArrayMap用来代替HashMap，在某些情况下合理使用会带来更好的性能提升。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin之object详解</title>
    <link href="http://yoursite.com/2018/11/28/Kotlin%E4%B9%8Bobject%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/Kotlin之object详解/</id>
    <published>2018-11-28T10:25:55.500Z</published>
    <updated>2018-11-28T13:26:28.012Z</updated>
    
    <content type="html"><![CDATA[<p>在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。</p><p>object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景：</p><ol><li>对象声明（Object Decalaration）</li><li>伴生对象（Companion Object）</li><li>对象表达式（Object Expression）– 上面提到的就是这种</li></ol><a id="more"></a><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>语法：通过object实现kotlin中的单例<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object RepositoryManager&#123;</span><br><span class="line">    fun method()&#123;</span><br><span class="line">        println(&quot;I&apos;m in object declaration&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即将object代替class关键字，声明一个类，这个类就是单例了</p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    RepositoryManager.method()//kotlin的调用</span><br><span class="line">    RepositoryManager.INSTANCE.method();//java的调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像在Java中调用静态方法（kotlin中没有静态方法）一样去调用其中定义的方法。其实，object声明的类最终被编译成：一个类拥有一个静态成员变量来持有对自己的引用，并且这个静态成员的名称是INSTANCE。它等价于java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RepositoryManager&#123;</span><br><span class="line">    private RepositoryManager()&#123;&#125;</span><br><span class="line">    public static final RepositoryManager INSTANCE = new RepositoryManager();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尽管和普通类的声明一样，可以包含属性，方法，初始化代码块以及可以继承其他类或者实现某个接口，但是它不能包含构造器，java中构造器是私有的。</p></blockquote><p>它也可以定义在一个类的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOuter &#123;</span><br><span class="line">     object Inner&#123;</span><br><span class="line">         fun method()&#123;</span><br><span class="line">             println(&quot;I&apos;m in inner class&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">     ObjectOuter.Inner.method()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="伴生对象（Companion-object）"><a href="#伴生对象（Companion-object）" class="headerlink" title="伴生对象（Companion object）"></a>伴生对象（Companion object）</h3><p>在kotlin中是没有static关键字的，也就意味着没有了静态方法和静态成员。那么在kotlin中如果想表示这种概率，取而代之的是==包级别函数==这里的伴生对象。他们的区别在下面会介绍。</p><p>包级别函数是指在kotlin中fun可以不依赖于class，直接新建.kt文件在文件中直接可以写fun方法，调用的时候IDE会自动导入文件急fun的方法名可以在其他类中直接使用。（其实编译后它还是在类中的，只不过类名称是.kt的文件名）</p><p>伴生对象的语法形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    companion object 伴生对象名(可以省略)&#123;</span><br><span class="line">        //define method and field here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ObjectTest &#123;</span><br><span class="line"></span><br><span class="line">    companion object MyObjec&#123;</span><br><span class="line"></span><br><span class="line">        val a = 20</span><br><span class="line"></span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;I&apos;m in companion object&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //方式一</span><br><span class="line">    ObjectTest.MyObject.method()</span><br><span class="line">    println(ObjectTest.MyObject.a)</span><br><span class="line"></span><br><span class="line">    //方式二（推荐方式）</span><br><span class="line">    ObjectTest.method()</span><br><span class="line">    println(ObjectTest.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在定义时如果省略了伴生对象名称，那么编辑器会为其提供默认的名字Companion。在方法二中，我们是直接通过类名称.方法名()的形式调用的，我们在没有生成ObjectTest类对象时，直接调用了其伴生对象中定义的属性和方法，和java中的静态方法很相似。</p></blockquote><p>通过javap命令，让我们看下其生成的字节码：<br><img src="https://img-blog.csdn.net/20180312203901905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180313102935601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><blockquote><p>注意红框中，这个MyObject成员变量的类型，是用$符号连接的，那么说明我们在定义伴生对象的时候，实际上是把它当作了静态内部类来看待的，并且目标类会持有该内部类的一个应用，最终调用的是定义在这个静态内部类中的实例方法。</p></blockquote><p>那么伴生对象和包级别函数的区别是什么呢？我们反编译下kt文件。<br><img src="https://img-blog.csdn.net/20180312204822460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxoMTE5MTg2MDkzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>可以看出，一个名叫ObjectTest2.kt文件实际上会生成一个名叫ObjectTest2Kt的类，而这个顶级函数是作为这个类的静态方法的形式存在的。<br>所以实际上类中的静态方法和内部类中的实例方法的区别，因为成员内部类中的方法是可以访问外部内定义的方法和成员变量的，哪怕是private的，而静态方法是做不到这一点的。<br><img src="https://img-blog.csdn.net/20180314102249748?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3hsaDExOTE4NjA5Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h3 id="对象表达式（Object-Expression）"><a href="#对象表达式（Object-Expression）" class="headerlink" title="对象表达式（Object Expression）"></a>对象表达式（Object Expression）</h3><p>先来看下java中的匿名内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Contents &#123;</span><br><span class="line">    void absMethod();</span><br><span class="line">&#125;</span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new Contents() &#123;</span><br><span class="line">           </span><br><span class="line">            @Override</span><br><span class="line">            public void absMethod() &#123;</span><br><span class="line">                System.out.println(&quot;method invoked...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.contents().absMethod();    //打印method invoked...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指出两点java中内部类的局限性</p><ol><li>如果在匿名内部类中添加了一些方法和属性，那么在外部是无法调用的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return new Contents() &#123;</span><br><span class="line">            private int i = 1;</span><br><span class="line"></span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void absMethod() &#123;</span><br><span class="line">                System.out.println(&quot;method invoked...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.contents().absMethod();</span><br><span class="line">        hello.value();  //Cannot resolve method &apos;value()&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当你想使用这个value方式的时候，编译会报错，因为java的多态导致父类型的引用是无法知晓子类添加的方法的。</p><ol><li>一个匿名内部类肯定只能实现一个接口或者继承一个类。</li></ol><p>在看看kotlin的对象表达式：<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object [ : 接口1,接口2,类型1, 类型2]&#123;&#125;    //中括号中的可省略</span><br></pre></td></tr></table></figure><p>示例：<br>实现一个接口或者类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface AA &#123;</span><br><span class="line">    fun a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    val aa = object : AA &#123;</span><br><span class="line">        override fun a() &#123;</span><br><span class="line">            println(&quot;a invoked&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aa.a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不实现任何接口和类，并且在匿名内部类中添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    val obj = object  &#123;</span><br><span class="line">        fun a() &#123;</span><br><span class="line">            println(&quot;a invoked&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.a()  //打印：a invoked</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子看出kotlin中，新添加的方式是可以调用的<br>那么，实现多个接口和类（NB）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val cc = object : AA, BB() &#123;</span><br><span class="line">        override fun a() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun b() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cc.a()</span><br><span class="line">    cc.b()</span><br><span class="line"></span><br><span class="line">&#125;//注意写法</span><br></pre></td></tr></table></figure><blockquote><p>kotlin官方文档上的一句话：匿名对象只定义局部变量和private成员变量时，才能体现它的真实类型，如果你是将匿名对象作为public函数的返回值或者是public的属性时，你只能将它看作是它的父类，当然你不指定类型时就当Any看待，这时你在匿名对象中添加的方法和属性时不能被访问的。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyTest &#123;</span><br><span class="line"></span><br><span class="line">    private val foo = object &#123;</span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;private&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val foo2 = object &#123;</span><br><span class="line">        fun method() &#123;</span><br><span class="line">            println(&quot;public&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun m() = object &#123;</span><br><span class="line">        fun method()&#123;</span><br><span class="line">            println(&quot;method&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun invoke()&#123;</span><br><span class="line"></span><br><span class="line">        val local = object &#123;</span><br><span class="line">            fun method()&#123;</span><br><span class="line">                println(&quot;local&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        local.method()  //编译通过</span><br><span class="line">        foo.method()    //编译通过</span><br><span class="line">        foo2.method()   //编译通不过</span><br><span class="line">        m().method()    //编译通不过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后：<br>object声明：当第一次访问它时才初始化，是一种懒加载<br>伴生对象：当他对应的类被加载后，它才初始化，类似java中的额静态代码块<br>对象表达式：一旦被执行，就立刻初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写kotlin代码的时候，特别是在写Rxjava的时候经常会碰到（object：类名称）这样的表达式，完全不知道怎么回事，故搜集了些资料彻底搞清楚kotlin中object的含义。&lt;/p&gt;
&lt;p&gt;object是kotlin中的一个重要关键字，也是java中没有的。object主要有以下三种使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象声明（Object Decalaration）&lt;/li&gt;
&lt;li&gt;伴生对象（Companion Object）&lt;/li&gt;
&lt;li&gt;对象表达式（Object Expression）– 上面提到的就是这种&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>怎么用Kotlin去提高生产力：Kotlin Tips</title>
    <link href="http://yoursite.com/2018/11/23/Kotlin-Tips/"/>
    <id>http://yoursite.com/2018/11/23/Kotlin-Tips/</id>
    <published>2018-11-23T02:16:01.495Z</published>
    <updated>2018-11-23T02:23:41.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Tip1-更简洁的字符串">Tip1-更简洁的字符串</a><ul><li>1、三个引号  2、字符串模版</li></ul></li><li><a href="#Tip2-Kotlin中大多数控制结构都是表达式">Tip2-Kotlin中大多数控制结构都是表达式</a><ul><li>1、语句和表达式  2、if  3、when</li></ul></li><li><a href="#Tip3-更好调用的函数-显式参数名及默认参数值">Tip3-更好调用的函数：显式参数名及默认参数值</a><ul><li>1、显式参数名  2、默认参数值  3、@JvmOverloads </li></ul></li><li><a href="#Tip4-扩展函数和属性">Tip4-扩展函数和属性</a><ul><li>1、扩展函数  2、扩展属性</li></ul></li><li><a href="#Tip5-懒初始化bylazy和延迟初始化lateinit">Tip5-懒初始化bylazy和延迟初始化lateinit</a><ul><li>1、by lazy  2、lateinit</li></ul></li><li><a href="#Tip6-不用再手写findViewById">Tip6-不用再手写findViewById</a><ul><li>1、Activity  2、子View或者include标签  3、Fragment</li></ul></li><li><a href="#Tip7-利用局部函数抽取重复代码">Tip7-利用局部函数抽取重复代码</a><ul><li>1、局部函数  2、扩展函数</li></ul></li><li><a href="#Tip8-使用数据类来快速实现model类">Tip8-使用数据类来快速实现model类</a>  </li><li><a href="#Tip9-用类委托来快速实现装饰器模式">Tip9-用类委托来快速实现装饰器模式</a> </li><li><a href="#Tip10-Lambda表达式简化OnClickListener">Tip10-Lambda表达式简化OnClickListener</a></li><li><a href="#Tip11-with函数来简化代码">Tip11-with函数来简化代码</a> </li><li><a href="#Tip12-apply函数来简化代码">Tip12-apply函数来简化代码</a> </li><li><a href="#Tip13-在编译阶段避免掉NullPointerException">Tip13-在编译阶段避免掉NullPointerException</a><ul><li>1、可空和不可空类型  2、let  3、Elvis操作符</li></ul></li><li><a href="#Tip14-运算符重载">Tip14-运算符重载</a> </li><li><a href="#Tip15-高阶函数简化代码">Tip15-高阶函数简化代码</a> </li><li><a href="#Tip16-用Lambda来简化策略模式">Tip16-用Lambda来简化策略模式</a> <a id="more"></a></li></ul><hr><h2 id="Tip1-更简洁的字符串"><a href="#Tip1-更简洁的字符串" class="headerlink" title="Tip1-更简洁的字符串"></a>Tip1-更简洁的字符串</h2><p><a href="#目录">回到目录</a></p><h4 id="三个引号"><a href="#三个引号" class="headerlink" title="三个引号"></a>三个引号</h4><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip1/KotlinTip1.kt" target="_blank" rel="noopener">KotlinTip1</a></p><p>Kotlin中的字符串基本Java中的类似，有一点区别是加入了三个引号”””来方便长篇字符的编写。<br>而在Java中，这些都需要转义，先看看java中的式例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc"</span>;</span><br><span class="line">    String str2 = <span class="string">"line1\n"</span> +</span><br><span class="line">            <span class="string">"line2\n"</span> +</span><br><span class="line">            <span class="string">"line3"</span>;</span><br><span class="line">    String js = <span class="string">"function myFunction()\n"</span> +</span><br><span class="line">            <span class="string">"&#123;\n"</span> +</span><br><span class="line">            <span class="string">"    document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";\n"</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>;</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">    System.out.println(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin除了有单个双引号的字符串，还对字符串的加强，引入了<strong>三个引号</strong>，”””中可以包含换行、反斜杠等等特殊字符：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin对字符串的加强，三个引号"""中可以包含换行、反斜杠等等特殊字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str1 = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">val</span> str2 = <span class="string">"""line1\n</span></span><br><span class="line"><span class="string">        line2</span></span><br><span class="line"><span class="string">        line3</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    <span class="keyword">val</span> js = <span class="string">"""</span></span><br><span class="line"><span class="string">        function myFunction()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            document.getElementById("demo").innerHTML="My First JavaScript Function";</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    println(str1)</span><br><span class="line">    println(str2)</span><br><span class="line">    println(js)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h4><p>同时，Kotlin中引入了<strong>字符串模版</strong>，方便字符串的拼接，可以用$符号拼接变量和表达式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin字符串模版，可以用$符号拼接变量和表达式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> strings = arrayListOf(<span class="string">"abc"</span>, <span class="string">"efd"</span>, <span class="string">"gfg"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="variable">$strings</span>"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;strings[<span class="number">0</span>]&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;if (strings.size &gt; <span class="number">0</span>) strings[<span class="number">0</span>] else "null"&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，在Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是${‘$’}<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kotlin中，美元符号$是特殊字符，在字符串中不能直接显示，必须经过转义，方法1是用反斜杠，方法二是$&#123;'$'&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testString3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"First content is \$strings"</span>)</span><br><span class="line">    println(<span class="string">"First content is <span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>strings"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip2-Kotlin中大多数控制结构都是表达式"><a href="#Tip2-Kotlin中大多数控制结构都是表达式" class="headerlink" title="Tip2-Kotlin中大多数控制结构都是表达式"></a>Tip2-Kotlin中大多数控制结构都是表达式</h2><p><a href="#目录">回到目录</a></p><p>首先，需要弄清楚一个概念<strong>语句和表达式</strong>，然后会介绍控制结构表达式的优点：<strong>简洁</strong></p><h4 id="语句和表达式是什么？"><a href="#语句和表达式是什么？" class="headerlink" title="语句和表达式是什么？"></a>语句和表达式是什么？</h4><ul><li>表达式有值，并且能作为另一个表达式的一部分使用</li><li>语句总是包围着它的代码块中的顶层元素，并且没有自己的值<h4 id="Kotlin与Java的区别"><a href="#Kotlin与Java的区别" class="headerlink" title="Kotlin与Java的区别"></a>Kotlin与Java的区别</h4></li><li>Java中，所有的控制结构都是语句，也就是控制结构都没有值</li><li>Kotlin中，除了循环（for、do和do/while）以外，大多数控制结构都是表达式(if/when等)</li></ul><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip2" target="_blank" rel="noopener">tip2</a></p><h4 id="Example1：if语句"><a href="#Example1：if语句" class="headerlink" title="Example1：if语句"></a>Example1：if语句</h4><p>java中，if 是语句，没有值，必须显式的return<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的if语句</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin中，if 是表达式，不是语句，因为表达式有值，可以作为值return出去<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，if 是表达式，不是语句，类似于java中的三目运算符a &gt; b ? a : b</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的if中的分支最后一行语句就是该分支的值，会作为函数的返回值。这其实跟java中的三元运算符类似，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java的三元运算符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是java中的三元运算符，kotlin中if是表达式有值，完全可以替代，<strong>故kotlin中已没有三元运算符了</strong>，用if来替代。<br>上面的max函数还可以简化成下面的形式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin简化版本</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p><h4 id="Example2：when语句"><a href="#Example2：when语句" class="headerlink" title="Example2：when语句"></a>Example2：when语句</h4><p>Kotlin中的when非常强大，完全可以取代Java中的switch和if/else，同时，<strong>when也是表达式</strong>，when的每个分支的最后一行为当前分支的值<br>先看一下java中的switch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的switch</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPoint</span><span class="params">(<span class="keyword">char</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"GOOD"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"BAD"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UN_KNOW"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>java中的switch有太多限制，我们再看看Kotlin怎样去简化的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，when是表达式，可以取代Java 中的switch，when的每个分支的最后一行为当前分支的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPoint</span><span class="params">(grade: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span> (grade) &#123;</span><br><span class="line">    <span class="string">'A'</span> -&gt; <span class="string">"GOOD"</span></span><br><span class="line">    <span class="string">'B'</span>, <span class="string">'C'</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">"test when"</span>)</span><br><span class="line">        <span class="string">"OK"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">'D'</span> -&gt; <span class="string">"BAD"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"UN_KNOW"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，when语句还可以取代java中的if/else if，其是表达式有值，并且更佳简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java中的if else</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPoint2</span><span class="params">(Integer point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (point &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GOOD"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point &gt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point.hashCode() == <span class="number">0x100</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"STH"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UN_KNOW"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看kotlin的版本，使用<strong>不带参数的when</strong>，只需要6行代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kotlin中，when是表达式，可以取代java的if/else，when的每个分支的最后一行为当前分支的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPoint2</span><span class="params">(grade: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    grade &gt; <span class="number">90</span> -&gt; <span class="string">"GOOD"</span></span><br><span class="line">    grade &gt; <span class="number">60</span> -&gt; <span class="string">"OK"</span></span><br><span class="line">    grade.hashCode() == <span class="number">0x100</span> -&gt; <span class="string">"STH"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"UN_KNOW"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip3-更好调用的函数-显式参数名及默认参数值"><a href="#Tip3-更好调用的函数-显式参数名及默认参数值" class="headerlink" title="Tip3-更好调用的函数-显式参数名及默认参数值"></a>Tip3-更好调用的函数-显式参数名及默认参数值</h2><p><a href="#目录">回到目录</a></p><h4 id="显式参数名"><a href="#显式参数名" class="headerlink" title="显式参数名"></a>显式参数名</h4><p>Kotlin的函数更加好调用，主要是表现在两个方面：1，显式的<strong>标示参数名</strong>，可以方便代码阅读；2，函数可以有<strong>默认参数值</strong>，可以大大<strong>减少Java中的函数重载</strong>。<br>例如现在需要实现一个工具函数，打印列表的内容：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip3/KotlinTip3.kt" target="_blank" rel="noopener">KotlinTip3</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 打印列表的内容</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                     separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     prefix: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     postfix: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 不标明参数名</span></span><br><span class="line">    println(joinToString(list, <span class="string">" - "</span>, <span class="string">"["</span>, <span class="string">"]"</span>))</span><br><span class="line">    <span class="comment">// 显式的标明参数名称</span></span><br><span class="line">    println(joinToString(list, separator = <span class="string">" - "</span>, prefix = <span class="string">"["</span>, postfix = <span class="string">"]"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码所示，函数joinToString想要打印列表的内容，需要传入四个参数：列表、分隔符、前缀和后缀。<br>由于参数很多，在后续使用该函数的时候不是很直观的知道每个参数是干什么用的，这时候可以显式的标明参数名称，增加代码可读性。</p><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>同时，定义函数的时候还可以给函数默认的参数，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 打印列表的内容，带有默认的参数，可以避免java的函数重载</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                      separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    println(joinToString2(list, <span class="string">" - "</span>))</span><br><span class="line">    println(joinToString2(list, <span class="string">" , "</span>, <span class="string">"["</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样有了默认参数后，在使用函数时，如果不传入该参数，默认会使用默认的值，这样可以避免Java中大量的函数重载。</p><h4 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h4><p>在java与kotlin的混合项目中，会发现用kotlin实现的带默认参数的函数，在java中去调用的化就不能利用这个特性了，还是需要给所有参数赋值，像下面java这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123;add(<span class="number">2</span>);add(<span class="number">4</span>);add(<span class="number">0</span>);&#125;&#125;;</span><br><span class="line">String res = joinToString2(arr, <span class="string">"-"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure></p><p>这时候可以在kotlin的函数前添加注解@JvmOverloads，添加注解后翻译为class的时候kotlin会帮你去生成多个函数实现函数重载，kotlin代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过注解@JvmOverloads解决java调用kotlin时不支持默认参数的问题</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString2New</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样以后，java调用kotlin的带默认参数的函数就跟kotlin一样方便了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123;add(<span class="number">2</span>);add(<span class="number">4</span>);add(<span class="number">0</span>);&#125;&#125;;</span><br><span class="line">String res = joinToString2New(arr, <span class="string">"-"</span>);</span><br><span class="line">System.out.println(res);</span><br><span class="line">String res2 = joinToString2New(arr, <span class="string">"-"</span>, <span class="string">"=&gt;"</span>);</span><br><span class="line">System.out.println(res2);</span><br></pre></td></tr></table></figure></p><h2 id="Tip4-扩展函数和属性"><a href="#Tip4-扩展函数和属性" class="headerlink" title="Tip4-扩展函数和属性"></a>Tip4-扩展函数和属性</h2><p><a href="#目录">回到目录</a></p><p>扩展函数和扩展属性是Kotlin非常方便实用的一个功能，它可以让我们随意的扩展第三方的库，你如果觉得别人给的SDK的Api不好用，或者不能满足你的需求，这时候你可以用扩展函数完全去自定义。</p><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><p>例如String类中，我们想获取最后一个字符，String中没有这样的直接函数，你可以用.后声明这样一个扩展函数：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/KotlinTip4.kt" target="_blank" rel="noopener">KotlinTip4</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFunExtension</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"test extension fun"</span>;</span><br><span class="line">    println(str.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样定义好lastChar()函数后，之后只需要import进来后，就可以用String类直接调用该函数了，跟调用它自己的方法没有区别。这样可以避免重复代码和一些静态工具类，而且代码更加简洁明了。<br>例如我们可以改造上面tip3中的打印列表内容的函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用扩展函数改造Tip3中的列表打印内容函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString3</span><span class="params">(separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    postfix: <span class="type">String</span> = <span class="string">""</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    println(list.joinToString3(<span class="string">"/"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>除了扩展函数，还可以扩展属性，例如我想实现String和StringBuilder通过属性去直接获得最后字符：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展属性 lastChar获取String的最后一个字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展属性 lastChar获取StringBuilder的最后一个字符</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value: <span class="built_in">Char</span>) &#123;</span><br><span class="line">        setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testExtension</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line">    println(s.lastChar)</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder(<span class="string">"abc"</span>)</span><br><span class="line">    println(sb.lastChar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义好扩展属性后，之后只需import完了就跟使用自己的属性一样方便了。</p><h4 id="Why？Kotlin为什么能实现扩展函数和属性这样的特性？"><a href="#Why？Kotlin为什么能实现扩展函数和属性这样的特性？" class="headerlink" title="Why？Kotlin为什么能实现扩展函数和属性这样的特性？"></a>Why？Kotlin为什么能实现扩展函数和属性这样的特性？</h4><p>在Kotlin中要理解一些语法，只要认识到<strong>Kotlin语言最后需要编译为class字节码，Java也是编译为class执行，也就是可以大致理解为Kotlin需要转成Java一样的语法结构</strong>，<br>Kotlin就是一种<strong>强大的语法糖</strong>而已，Java不具备的功能Kotlin也不能越界的。</p><ul><li>那Kotlin的扩展函数怎么实现的呢？介绍一种万能的办法去理解Kotlin的语法：<strong>将Kotlin代码转化成Java语言</strong>去理解，步骤如下：<ul><li>在Android Studio中选择Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode 这样就把Kotlin转化为class字节码了</li><li>class码阅读不太友好，点击左上角的Decompile就转化为Java</li></ul></li><li>再介绍一个小窍门，在前期对Kotlin语法不熟悉的时候，可以先用Java写好代码，再利用AndroidStudio工具<strong>将Java代码转化为Kotlin代码</strong>，步骤如下：<ul><li>在Android Studio中选中要转换的Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File</li></ul></li></ul><p>我们看看将上面的扩展函数转成Java后的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展函数会转化为一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">lastChar</span><span class="params">(@NotNull String $receiver)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.charAt($receiver.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">getLastChar</span><span class="params">(@NotNull StringBuilder $receiver)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.charAt($receiver.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setLastChar</span><span class="params">(@NotNull StringBuilder $receiver, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">    $receiver.setCharAt($receiver.length() - <span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看上面的代码可知：对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象，这样把类的实例传入函数以后，函数内部就可以访问到类的公有方法。<br>对于扩展属性也类似，获取的扩展属性会转化为一个静态的get函数，同时这个静态函数的第一个参数就是该类的实例对象，设置的扩展属性会转化为一个静态的set函数，同时这个静态函数的第一个参数就是该类的实例对象。<br>函数内部可以访问公有的方法和属性。顶层的扩展函数是static的，<strong>不能被override</strong></p><ul><li><p>从上面转换的源码其实可以看到<strong>扩展函数和扩展属性适用的地方和缺陷</strong>：</p><ul><li>扩展函数和扩展属性内<strong>只能访问到类的公有方法和属性</strong>，私有的和protected是访问不了的</li><li><p>扩展函数<strong>不是真的修改了原来的类</strong>，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型，案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/StaticllyExtension.kt" target="_blank" rel="noopener">StaticllyExtension.kt</a></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">C</span></span>()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* https://kotlinlang.org/docs/reference/extensions.html</span></span><br><span class="line"><span class="comment">* Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,</span></span><br><span class="line"><span class="comment">* but merely make new functions callable with the dot-notation on variables of this type. Extension functions are</span></span><br><span class="line"><span class="comment">* dispatched statically.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">  println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testStatically</span><span class="params">()</span></span> &#123;</span><br><span class="line">  printFoo(C()) <span class="comment">// print c</span></span><br><span class="line">  printFoo(D()) <span class="comment">// also print c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面的案例中即使调用printFoo(D())还是打印出c，而不是d。转成java中会看到下面的代码，D类型在调用的时候会强制转换为C类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">foo</span><span class="params">(@NotNull C $receiver)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">foo</span><span class="params">(@NotNull D $receiver)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"d"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printFoo</span><span class="params">(@NotNull C c)</span> </span>&#123;</span><br><span class="line">  Intrinsics.checkParameterIsNotNull(c, <span class="string">"c"</span>);</span><br><span class="line">  String var1 = foo(c);</span><br><span class="line">  System.out.println(var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">testStatically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printFoo(<span class="keyword">new</span> C());</span><br><span class="line">  printFoo((C)(<span class="keyword">new</span> D()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>声明扩展函数作为类的成员变量<ul><li>上面的例子扩展函数是作为顶层函数，如果把扩展函数申明为类的成员变量，即扩展函数的作用域就在类的内部有效，案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip4/ExtensionsAsMembers.kt" target="_blank" rel="noopener">ExtensionsAsMembers.kt</a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// call the extension function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAsMembers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C().caller(D())   <span class="comment">// prints "D.foo in C"</span></span><br><span class="line">    C1().caller(D())  <span class="comment">// prints "D.foo in C1" - dispatch receiver is resolved virtually</span></span><br><span class="line">    C().caller(D1())  <span class="comment">// prints "D.foo in C" - extension receiver is resolved statically</span></span><br><span class="line">    C1().caller(D1()) <span class="comment">// prints "D.foo in C1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>函数caller的类型是D，即使调用C().caller(D1())，打印的结果还是D.foo in C，而不是D1.foo in C，不是运行时来动态决定类型，成员扩展函数申明为open，<br>一旦在子类中被override，就调用不到在父类中的扩展函数，在子类中的作用域内的只能访问到override后的函数，不能像普通函数override那样通过super关键字访问了。</p><ul><li>下面再举几个扩展函数的例子，让大家感受一下扩展函数的方便：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* show toast in activity</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">toast</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Context.inputMethodManager: InputMethodManager?</span><br><span class="line">    <span class="keyword">get</span>() = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span> InputMethodManager</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* hide soft input</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">hideSoftInput</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    inputMethodManager?.hideSoftInputFromWindow(view.windowToken, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * screen width in pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Context.screenWidth</span><br><span class="line">    <span class="keyword">get</span>() = resources.displayMetrics.widthPixels</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * screen height in pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> Context.screenHeight</span><br><span class="line">    <span class="keyword">get</span>() = resources.displayMetrics.heightPixels</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * returns dip(dp) dimension value in pixels</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">dip2px</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = (value * resources.displayMetrics.density).toInt()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Tip5-懒初始化bylazy和延迟初始化lateinit"><a href="#Tip5-懒初始化bylazy和延迟初始化lateinit" class="headerlink" title="Tip5-懒初始化bylazy和延迟初始化lateinit"></a>Tip5-懒初始化bylazy和延迟初始化lateinit</h2><p><a href="#目录">回到目录</a></p><h4 id="懒初始化by-lazy"><a href="#懒初始化by-lazy" class="headerlink" title="懒初始化by lazy"></a>懒初始化by lazy</h4><p>懒初始化是指推迟一个变量的初始化时机，变量在使用的时候才去实例化，这样会更加的高效。因为我们通常会遇到这样的情况，一个变量直到使用时才需要被初始化，或者仅仅是它的初始化依赖于某些无法立即获得的上下文。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip5/KotlinTip5.kt" target="_blank" rel="noopener">KotlinTip5</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒初始化api实例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> purchasingApi: PurchasingApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit: Retrofit = Retrofit.Builder()</span><br><span class="line">            .baseUrl(API_URL)</span><br><span class="line">            .addConverterFactory(MoshiConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">    retrofit.create(PurchasingApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面的代码，retrofit生成的api实例会在首次使用到的时候才去实例化。需要注意的是by lazy一般只能修饰val不变的对象，不能修饰var可变对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒初始化by lazy</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> user1: User <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    User(<span class="string">"jack"</span>, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="延迟初始化lateinit"><a href="#延迟初始化lateinit" class="headerlink" title="延迟初始化lateinit"></a>延迟初始化lateinit</h4><p>另外，对于var的变量，如果类型是非空的，是必须初始化的，不然编译不通过，这时候需要用到lateinit延迟初始化，使用的时候再去实例化。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 延迟初始化lateinit</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user2: User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLateInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user2 = User(<span class="string">"Lily"</span>, <span class="number">14</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="by-lazy-和-lateinit-的区别"><a href="#by-lazy-和-lateinit-的区别" class="headerlink" title="by lazy 和 lateinit 的区别"></a>by lazy 和 lateinit 的区别</h4><ul><li>by lazy 修饰val的变量</li><li>lateinit 修饰var的变量，且变量是非空的类型</li></ul><h2 id="Tip6-不用再手写findViewById"><a href="#Tip6-不用再手写findViewById" class="headerlink" title="Tip6-不用再手写findViewById"></a>Tip6-不用再手写findViewById</h2><p><a href="#目录">回到目录</a></p><h4 id="在Activity中使用"><a href="#在Activity中使用" class="headerlink" title="在Activity中使用"></a>在Activity中使用</h4><p>在Android的View中，会有很多代码是在声明一个View，然后通过findViewById后从xml中实例化赋值给对应的View。在kotlin中可以完全解放出来了，利用kotlin-android-extensions插件，不用再手写findViewById。步骤如下：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip6/KotlinTip6.kt" target="_blank" rel="noopener">KotlinTip6</a></p><ul><li>步骤1，在项目的gradle中 apply plugin: ‘kotlin-android-extensions’</li><li><p>步骤2，按照原来的习惯书写布局xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Tv"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Img"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tip6Btn"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤3，在java代码中import对应的布局就可以开始使用了，View不用提前声明，插件会自动根据布局的id生成对应的View成员（其实没有生成属性，原理见下面）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sw.kotlin.tips.R</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 导入插件生成的View</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_tip6.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTip6</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自动根据layout的id生成对应的view</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_tip6)</span><br><span class="line">        tip6Tv.text = <span class="string">"Auto find view for TextView"</span></span><br><span class="line">        tip6Img.setImageBitmap(<span class="literal">null</span>)</span><br><span class="line">        tip6Btn.setOnClickListener &#123;</span><br><span class="line">            test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tip6Tv.text = <span class="string">"update"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>像上面代码这样，Activity里的三个View自动生成了，不用再去声明，然后findViewById，然后转型赋值，是不是减少了很多没必要的代码，让代码非常的干净。</p><h4 id="Why？原理是什么？插件帮我们做了什么？"><a href="#Why？原理是什么？插件帮我们做了什么？" class="headerlink" title="Why？原理是什么？插件帮我们做了什么？"></a>Why？原理是什么？插件帮我们做了什么？</h4><p>要看原理还是将上面的代码转为java语言来理解，参照tips4提供的方式转换为如下的java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinTip6</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      <span class="keyword">this</span>.setContentView(<span class="number">2131296284</span>);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">"Auto find view for TextView"</span>);</span><br><span class="line">      ((ImageView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Img)).setImageBitmap((Bitmap)<span class="keyword">null</span>);</span><br><span class="line">      ((Button)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Btn)).setOnClickListener((OnClickListener)(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View it)</span> </span>&#123;</span><br><span class="line">            KotlinTip6.<span class="keyword">this</span>.test();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence) <span class="string">"update"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(Integer.valueOf(var1));</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         var2 = <span class="keyword">this</span>.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(Integer.valueOf(var1), var2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> _$_clearFindViewByIdCache() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.clear();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码所示，在编译阶段，插件会帮我们生成视图缓存，视图由一个Hashmap结构的_$_findViewCache变量缓存，<br>会根据对应的id先从缓存里查找，缓存没命中再去真正调用findViewById查找出来，再存在HashMap中。</p><h4 id="子View或者include标签中findViewById"><a href="#子View或者include标签中findViewById" class="headerlink" title="子View或者include标签中findViewById"></a>子View或者include标签中findViewById</h4><p>子子View或者include标签中，同样可以省略findViewById，但需要主要默认的activity的布局import是不会将这个include的View引入进来<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/layout_tip6"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//include layout</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/test_inside_id"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/app_name"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>需要我们引入对应的View的id，像这样import kotlinx.android.synthetic.main.layout_tip6.*<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入插件生成的View</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_tip6.*</span><br><span class="line"><span class="comment">//include layout的View</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.layout_tip6.*</span><br><span class="line"></span><br><span class="line">test_inside_id.text = <span class="string">"Test include"</span></span><br></pre></td></tr></table></figure></p><h4 id="在Fragment中findViewById"><a href="#在Fragment中findViewById" class="headerlink" title="在Fragment中findViewById"></a>在Fragment中findViewById</h4><p>在Fragment中也类似，但有一点需要注意但地方，例子如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tip6Fragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>?, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater?.inflate(R.layout.fragment_tip6, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这时候不能在onCreateView方法里用view，需要在onViewCreate里，原理是插件用了getView来findViewById</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">// tip6Tv.text = "test2"</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要在onViewCreate里，原理是插件用了getView来findViewById</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        tip6Tv.text = <span class="string">"test"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，Fragment需要注意，不能在onCreateView方法里用view，不然会出现空指针异常，需要在onViewCreate里，原理是插件用了getView来findViewById，<br>我们看看将上面的代码转成java后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tip6Fragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@Nullable LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      View view = inflater != <span class="keyword">null</span>?inflater.inflate(<span class="number">2131296286</span>, container, <span class="keyword">false</span>):<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@Nullable View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.tip6Tv);</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tip6Tv"</span>);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">"test"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(Integer.valueOf(var1));</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         View var10000 = <span class="keyword">this</span>.getView();</span><br><span class="line">         <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         var2 = var10000.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(Integer.valueOf(var1), var2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> _$_clearFindViewByIdCache() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">      <span class="keyword">this</span>._$_clearFindViewByIdCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟Activity中类似，会有一个View的HashMap，关键不同的地方在_$<em>findCachedViewById里面，需要getView获得当前Fragment的View，<br>故在onViewCreated中getView还是空的，原理就好理解了。另外在onDestroyView会调用</em>$_clearFindViewByIdCache方法清掉缓存。</p><h2 id="Tip7-利用局部函数抽取重复代码"><a href="#Tip7-利用局部函数抽取重复代码" class="headerlink" title="Tip7-利用局部函数抽取重复代码"></a>Tip7-利用局部函数抽取重复代码</h2><p><a href="#目录">回到目录</a></p><h4 id="局部函数抽取代码"><a href="#局部函数抽取代码" class="headerlink" title="局部函数抽取代码"></a>局部函数抽取代码</h4><p>Kotlin中提供了函数的嵌套，在函数内部还可以定义新的函数。这样我们可以在函数中嵌套这些提前的函数，来抽取重复代码。如下面的案例所示:<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip7/KotlinTip7.kt" target="_blank" rel="noopener">KotlinTip7</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String, <span class="keyword">val</span> email: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Address"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.email.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Email"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码在判断name、address等是否为空的处理其实很类似。这时候，我们可以利用在函数内部嵌套的声明一个通用的判空函数将相同的代码抽取到一起：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用局部函数抽取相同的逻辑，去除重复的代码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser2</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fildName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$fildName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(user.name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(user.address, <span class="string">"Address"</span>)</span><br><span class="line">    validate(user.email, <span class="string">"Email"</span>)</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="扩展函数抽取代码"><a href="#扩展函数抽取代码" class="headerlink" title="扩展函数抽取代码"></a>扩展函数抽取代码</h4><p>除了利用嵌套函数去抽取，此时，其实也可以用扩展函数来抽取，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用扩展函数抽取逻辑</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fildName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="variable">$id</span>: empty <span class="variable">$fildName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(address, <span class="string">"Address"</span>)</span><br><span class="line">    validate(email, <span class="string">"Email"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser3</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateAll()</span><br><span class="line">    <span class="comment">// save to db ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip8-使用数据类来快速实现model类"><a href="#Tip8-使用数据类来快速实现model类" class="headerlink" title="Tip8-使用数据类来快速实现model类"></a>Tip8-使用数据类来快速实现model类</h2><p><a href="#目录">回到目录</a></p><p>在java中要声明一个model类需要实现很多的代码，首先需要将变量声明为private，然后需要实现get和set方法，还要实现对应的hashcode equals toString方法等，如下所示：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip8" target="_blank" rel="noopener">Tip8</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">int</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender="</span> + gender +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (gender != user.gender) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> ? !name.equals(user.name) : user.name != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> address != <span class="keyword">null</span> ? address.equals(user.address) : user.address == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        result = <span class="number">31</span> * result + gender;</span><br><span class="line">        result = <span class="number">31</span> * result + (address != <span class="keyword">null</span> ? address.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码Java需要70行左右，而如果用kotlin，只需要一行代码就可以做到。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kotlin会为类的参数自动实现get set方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> gender: <span class="built_in">Int</span>, <span class="keyword">var</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用data关键词来声明一个数据类，除了会自动实现get set，还会自动生成equals hashcode toString</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> gender: <span class="built_in">Int</span>, <span class="keyword">var</span> address: String)</span><br></pre></td></tr></table></figure></p><p>对于Kotlin中的类，会为它的参数自动实现get set方法。而如果加上data关键字，还会自动生成equals hashcode toString。原理其实数据类中的大部分代码都是模版代码，Kotlin聪明的将这个模版代码的实现放在了编译器处理的阶段。</p><h2 id="Tip9-用类委托来快速实现装饰器模式"><a href="#Tip9-用类委托来快速实现装饰器模式" class="headerlink" title="Tip9-用类委托来快速实现装饰器模式"></a>Tip9-用类委托来快速实现装饰器模式</h2><p><a href="#目录">回到目录</a></p><p>通过继承的实现容易导致脆弱性，例如如果需要修改其他类的一些行为，这时候Java中的一种策略是采用<strong>装饰器模式</strong>：创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个成员变量。<br>与原始类拥有相同行为的方法不用修改，只需要直接转发给原始类的实例。如下所示：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip9/KotlinTip9.kt" target="_blank" rel="noopener">KotlinTip9</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常见的装饰器模式，为了修改部分的函数，却需要实现所有的接口函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectAdded = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = innerSet.size</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要修改的方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要修改的方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.contains(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.containsAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        innerSet.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: MutableIterator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.remove(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.removeAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">retainAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerSet.retainAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，想要修改HashSet的某些行为函数add和addAll，需要实现MutableCollection接口的所有方法，将这些方法转发给innerSet去具体的实现。虽然只需要修改其中的两个方法，其他代码都是模版代码。<br><strong>只要是重复的模版代码，Kotlin这种全新的语法糖就会想办法将它放在编译阶段再去生成。</strong><br>这时候可以用到<strong>类委托by关键字</strong>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet2</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过by关键字将接口的实现委托给innerSet成员变量，需要修改的函数再去override就可以了，通过类委托将10行代码就可以实现上面接近100行的功能，简洁明了，去掉了模版代码。</p><h2 id="Tip10-Lambda表达式简化OnClickListener"><a href="#Tip10-Lambda表达式简化OnClickListener" class="headerlink" title="Tip10-Lambda表达式简化OnClickListener"></a>Tip10-Lambda表达式简化OnClickListener</h2><p><a href="#目录">回到目录</a></p><p>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip10/KotlinTip10.kt" target="_blank" rel="noopener">KotlinTip10</a><br>lambda表达式可以简化我们的代码。以Android中常见的OnClickListener来说明，在Java中我们一般这样设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextView textView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Java中需要声明一个匿名内部类去处理，这种情况可以用lambda表达式来简化。</p><ul><li>lambda表达式一般长这样<ul><li>{ x:Int, y:Int -&gt; x+y }</li><li>参数 -&gt; 表达式 并且始终在大括号中</li><li>it作为默认参数名</li><li>lambda捕捉，当捕捉final变量时，它的值和lambda代码一起存储</li><li>非final变量，它的值被封装在一个特殊的包装器中，这个包装器的引用会和lambda代码一起存储</li></ul></li></ul><p>我们来看看Kotlin中的例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> textView = TextView(context)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 传统方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(<span class="keyword">object</span> : android.view.View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda的方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当lambda的参数没有使用时可以省略，省略的时候用it来替代<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda的参数如果没有使用可以省略，省略的时候用it来替代</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener(&#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>lambda在参数的最后一个的情况可以将之提出去<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda在参数的最后一个的情况可以将之提出去</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener() &#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lambda提出去之后，函数如果没有其他参数括号可以省略<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* lambda提出去之后，函数如果没有其他参数括号可以省略</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">textView.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// handle click</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再看看如果自己去实现一个带lambda参数的函数应该怎么去定义：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> listener: OnClickListener? = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 传统方式</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClickListener</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSth</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// some case:</span></span><br><span class="line">        listener?.onClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 声明lambda方式，listener: () -&gt; Unit</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在函数参数中需要声明lambda的类型后，再调用该函数的时候就可以传入一个lambda表达式了。</p><h2 id="Tip11-with函数来简化代码"><a href="#Tip11-with函数来简化代码" class="headerlink" title="Tip11-with函数来简化代码"></a>Tip11-with函数来简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li><p>with 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure></li><li><p>with函数并不是扩展函数，返回值是最后一行，可以直接调用对象的方法</p></li></ul><p>Kotlin中可以用with语句来省略同一个变量的多次声明，例如下面的函数<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip11/KotlinTip11.kt" target="_blank" rel="noopener">KotlinTip11</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*打印字母表函数，在函数内result变量在好几处有使用到</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    result.append(<span class="string">"START\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">"\nEND"</span>)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的函数中，result变量出现了5次，如果用with语句，可以将这5次都不用再出现了，我们来一步一步地看是怎么实现的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.append(<span class="string">"\nEND"</span>)</span><br><span class="line">        <span class="keyword">this</span>.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过with语句，将result作为参数传入，在内部就可以通过this来表示result变量了，而且这个this是可以省略的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，将result参数作为参数，在内部this也可以省略掉</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(result) &#123;</span><br><span class="line">        append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nEND"</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部this省略掉后，现在只有一个result了，这个其实也是没必要的，于是出现了下面的最终版本：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过with语句，可以直接将对象传入，省掉对象的声明</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet4</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        append(<span class="string">"START\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nEND"</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面这样，我们可以把同一个变量的显式调用从5次变为0次，发现Kotlin的魅力了吧。</p><h2 id="Tip12-apply函数来简化代码"><a href="#Tip12-apply函数来简化代码" class="headerlink" title="Tip12-apply函数来简化代码"></a>Tip12-apply函数来简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li><p>apply 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象</p></li></ul><p>除了用上面的with可以简化同一个变量的多次声明，还可以用apply关键字，我们来改造一下tip11中的函数：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip12/KotlinTip12.kt" target="_blank" rel="noopener">KotlinTip12</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用apply语句简化代码，在apply的大括号里可以访问类的公有属性和方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet5</span><span class="params">()</span></span> = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">"START\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nEND"</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure></p><p>像上面这样的，通过apply后，在apply的大括号里可以访问类的公有属性和方法。这在对应类的初始化是非常方便的，例如下面的例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用apply语句简化类的初始化，在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testApply</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> imgView = ImageView(context).apply &#123;</span><br><span class="line">        setBackgroundColor(<span class="number">0</span>)</span><br><span class="line">        setImageBitmap(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textView = TextView(context).apply &#123;</span><br><span class="line">        text = <span class="string">"content"</span></span><br><span class="line">        textSize = <span class="number">20.0f</span></span><br><span class="line">        setPadding(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> user = User().apply &#123; </span><br><span class="line">        age = <span class="number">15</span></span><br><span class="line">        name = <span class="string">"Jack"</span></span><br><span class="line">        <span class="keyword">val</span> a = address</span><br><span class="line">        address = <span class="string">"bbb"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在类实例化的时候，就可以通过apply把需要初始化的步骤全部实现，非常的简洁</p><h2 id="Tip13-在编译阶段避免掉NullPointerException"><a href="#Tip13-在编译阶段避免掉NullPointerException" class="headerlink" title="Tip13-在编译阶段避免掉NullPointerException"></a>Tip13-在编译阶段避免掉NullPointerException</h2><p><a href="#目录">回到目录</a></p><h4 id="可空类型和不可空类型"><a href="#可空类型和不可空类型" class="headerlink" title="可空类型和不可空类型"></a>可空类型和不可空类型</h4><p>NullPointerException是Java程序员非常头痛的一个问题，我们知道Java 中分受检异常和非受检异常，NullPointerException是非受检异常，也就是说NullPointerException不需要显示的去catch住，<br>往往在运行期间，程序就可能报出一个NullPointerException然后crash掉，Kotlin作为一门高效安全的语言，它尝试在编译阶段就把空指针问题显式的检测出来，把问题留在了编译阶段，让程序更加健壮。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip13/KotlinTip13.kt" target="_blank" rel="noopener">KotlinTip13</a></p><ul><li><p>Kotlin中类型分为可空类型和不可空类型，通过？代表可空，不带？代表不可为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNullType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: String = <span class="string">"aa"</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * a是非空类型，下面的给a赋值为null将会编译不通过</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">// a = null</span></span><br><span class="line">    a.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * ？声明是可空类型，可以赋值为null</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">var</span> b: String? = <span class="string">"bb"</span></span><br><span class="line">    b = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * b是可空类型，直接访问可空类型将编译不通过，需要通过?.或者!!.来访问</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">// b.length</span></span><br><span class="line">    b?.length</span><br><span class="line">    b!!.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过</p></li><li>对于一个可空类型：通过？声明，在访问该类型的时候直接访问不能编译通过，需要通过?.或者!!.<ul><li>?.  代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性</li><li>!!. 代表着如果该类型为空的话就抛出NullPointerException，如果不为空就去访问对应的方法或者属性，<br>所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出NullPointerException。<br>而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不推荐这样的写法：链式的连续用!!.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> user = User()</span><br><span class="line">user!!.name!!.subSequence(<span class="number">0</span>,<span class="number">5</span>)!!.length</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>对应一个可空类型，每次对它的访问都需要带上?.判断<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user: User? = User()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 每次访问都用用?.判断</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    user?.name</span><br><span class="line">    user?.age</span><br><span class="line">    user?.toString()</span><br></pre></td></tr></table></figure></p><p>但这样多了很多代码，kotlin做了一些优化，<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 或者提前判断是否为空，如果不为空在这个分支里会自动转化为非空类型就可以直接访问了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    user.name</span><br><span class="line">    user.age</span><br><span class="line">    user.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过if提前判断类型是否为空，如果不为空在这个分支里会<strong>自动转化为非空类型</strong>就可以直接访问了。</p><h4 id="let语句简化对可空对象对访问"><a href="#let语句简化对可空对象对访问" class="headerlink" title="let语句简化对可空对象对访问"></a>let语句简化对可空对象对访问</h4><ul><li><p>let 函数原型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></li><li><p>let函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。</p></li></ul><p>上面的代码还可以用?.let语句进行，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">user?.let &#123;</span><br><span class="line">    it.name</span><br><span class="line">    it.age</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过let语句，在?.let之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</p><h4 id="Elvis操作符-简化对空值的处理"><a href="#Elvis操作符-简化对空值的处理" class="headerlink" title="Elvis操作符 ?: 简化对空值的处理"></a>Elvis操作符 ?: 简化对空值的处理</h4><p>如果值可能为空，对空值的处理可能会比较麻烦，像下面这样：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对空值的处理</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testElvis</span><span class="params">(input: <span class="type">String</span>?, user: <span class="type">User</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span>?</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        a = -<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = input?.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> newOne = User()</span><br><span class="line">        newOne.save()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        user.save()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Elvis操作符?:能够简化上面的操作，?:符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。<strong>跟?.let正好相反</strong>，例如我们可以用两行代码来简化上面从操作：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Elvis操作符 ?: 简化对空值的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testElvis2</span><span class="params">(input: <span class="type">String</span>?, user: <span class="type">User</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = input?.length ?: -<span class="number">1</span>;</span><br><span class="line">    user?.save() ?: User().save()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip14-运算符重载"><a href="#Tip14-运算符重载" class="headerlink" title="Tip14-运算符重载"></a>Tip14-运算符重载</h2><p><a href="#目录">回到目录</a></p><p>Kotlin支持对运算符的重载，这对于对一些对象的操作更加灵活直观。</p><ul><li>使用operator来修饰plus\minus函数</li><li>可重载的二元算术符<ul><li>A * B  times</li><li>A / B  div</li><li>A % B  mod</li><li>A + B  plus</li><li>A - B  minus</li></ul></li></ul><p>以下面对坐标点Point的案例说明怎么去重载运算符：<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip14/KotlinTip14.kt" target="_blank" rel="noopener">KotlinTip14</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * plus函数重载对Point对象的加法运算符</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * minus函数重载对Point对象的减法运算符</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - other.x, y - other.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[x:<span class="variable">$x</span>, y:<span class="variable">$y</span>]"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，通过plus函数重载对Point对象的加法运算符，通过minus函数重载对Point对象的减法运算符，然后就可以用+、-号对两个对象进行操作了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testOperator</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point1 = Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> point2 = Point(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> point3 = point1 + point2</span><br><span class="line">    println(point3)</span><br><span class="line">    println(point1 - point2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tip15-高阶函数简化代码"><a href="#Tip15-高阶函数简化代码" class="headerlink" title="Tip15-高阶函数简化代码"></a>Tip15-高阶函数简化代码</h2><p><a href="#目录">回到目录</a></p><ul><li>高阶函数：以另一个函数作为参数或者返回值的函数</li><li>函数类型   <ul><li>(Int, String) -&gt; Unit</li><li>参数类型-&gt;返回类型 Unit不能省略</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 传入函数来过滤</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">println(list.filter &#123; it &gt; <span class="number">4</span> &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义函数类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> action = &#123; println(<span class="number">42</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sum2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> action2: () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="number">42</span>) &#125;</span><br></pre></td></tr></table></figure><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>函数作为参数，即高阶函数中，函数的参数可以是一个函数类型，例如要定义一个函数，该函数根据传入的操作函数来对2和3做相应的处理。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip15/KotlinTip15.kt" target="_blank" rel="noopener">KotlinTip15</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义对2和3的操作函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoAndThree</span><span class="params">(<span class="keyword">operator</span>: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">operator</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    println(<span class="string">"Result:<span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">    twoAndThree &#123; a, b -&gt; a + b &#125;</span><br><span class="line">    twoAndThree &#123; a, b -&gt; a * b &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator是函数类型，函数的具体类型为(Int, Int) -&gt; Int，即输入两个Int返回一个Int值。定义完了后就可以像上面这样使用了。<br>再举一个例子，实现String类的字符过滤：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 函数作为参数，实现String类的字符过滤</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">filter</span><span class="params">(predicate: (<span class="type">Char</span>)</span></span> -&gt; <span class="built_in">Boolean</span>): String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until length) &#123;</span><br><span class="line">        <span class="keyword">val</span> element = <span class="keyword">get</span>(index)</span><br><span class="line">        <span class="keyword">if</span> (predicate(element)) sb.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test04</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"12eafsfsfdbzzsa"</span>.filter &#123; it <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'f'</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像上面这样predicate是函数类型，它会根据传入的char来判断得到一个Boolean值。</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>函数作为返回值也非常实用，例如我们的需求是根据不同的快递类型返回不同计价公式，普通快递和高级快递的计价规则不一样，这时候我们可以将计价规则函数作为返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span> </span>&#123;</span><br><span class="line">    STANDARD, EXPEDITED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据不同的运输类型返回不同的快递方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getShippingCostCalculator</span><span class="params">(delivery: <span class="type">Delivery</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delivery == Delivery.EXPEDITED) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="number">6</span> + <span class="number">2.1</span> * it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1.3</span> * it &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test05</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> calculator1 = getShippingCostCalculator(Delivery.EXPEDITED)</span><br><span class="line">    <span class="keyword">val</span> calculator2 = getShippingCostCalculator(Delivery.STANDARD)</span><br><span class="line">    println(<span class="string">"Ex costs <span class="subst">$&#123;calculator1(<span class="number">5</span>)&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"St costs <span class="subst">$&#123;calculator2(<span class="number">5</span>)&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是普通快递，采用1.3 <em> it的规则计算价格，如果是高级快递按照6 + 2.1 </em> it计算价格，根据不同的类型返回不同的计价函数。</p><h2 id="Tip16-用Lambda来简化策略模式"><a href="#Tip16-用Lambda来简化策略模式" class="headerlink" title="Tip16-用Lambda来简化策略模式"></a>Tip16-用Lambda来简化策略模式</h2><p><a href="#目录">回到目录</a></p><p>策略模式是常见的模式之一，java的例子如下。<br>详见案例代码<a href="https://github.com/heimashi/kotlin_tips/blob/master/app/src/main/java/com/sw/kotlin/tip16" target="_blank" rel="noopener">Tip16</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义策略接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Do A Strategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * B策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Do B Strategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略实施者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"START"</span>);</span><br><span class="line">            <span class="keyword">if</span> (strategy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                strategy.doSth();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"END"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上面的例子所示，有A、B两种策略，Worker根据不同的策略做不同的工作，使用策略时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Worker worker1 = <span class="keyword">new</span> Worker(<span class="keyword">new</span> AStrategy());</span><br><span class="line">Worker worker2 = <span class="keyword">new</span> Worker(<span class="keyword">new</span> BStrategy());</span><br><span class="line">worker1.work();</span><br><span class="line">worker2.work();</span><br></pre></td></tr></table></figure></p><p>在java中实现这种策略模式难免需要先定义好策略的接口，然后根据接口实现不同的策略，<br>在Kotlin中完全可以用用Lambda来简化策略模式，上面的例子用Kotlin实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实施者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strategy lambda类型的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> strategy: () -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"START"</span>)</span><br><span class="line">        strategy.invoke()</span><br><span class="line">        println(<span class="string">"END"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testStrategy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> worker1 = Worker(&#123;</span><br><span class="line">        println(<span class="string">"Do A Strategy"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> bStrategy = &#123;</span><br><span class="line">        println(<span class="string">"Do B Strategy"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> worker2 = Worker(bStrategy)</span><br><span class="line">    worker1.work()</span><br><span class="line">    worker2.work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不需要先定义策略的接口，直接把策略以lambda表达式的形式传进来就行了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li>《Kotlin in Action》</li><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/</a></li><li><a href="https://savvyapps.com/blog/kotlin-tips-android-development" target="_blank" rel="noopener">https://savvyapps.com/blog/kotlin-tips-android-development</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Tip1-更简洁的字符串&quot;&gt;Tip1-更简洁的字符串&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、三个引号  2、字符串模版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip2-Kotlin中大多数控制结构都是表达式&quot;&gt;Tip2-Kotlin中大多数控制结构都是表达式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、语句和表达式  2、if  3、when&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip3-更好调用的函数-显式参数名及默认参数值&quot;&gt;Tip3-更好调用的函数：显式参数名及默认参数值&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、显式参数名  2、默认参数值  3、@JvmOverloads &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip4-扩展函数和属性&quot;&gt;Tip4-扩展函数和属性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、扩展函数  2、扩展属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip5-懒初始化bylazy和延迟初始化lateinit&quot;&gt;Tip5-懒初始化bylazy和延迟初始化lateinit&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、by lazy  2、lateinit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip6-不用再手写findViewById&quot;&gt;Tip6-不用再手写findViewById&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、Activity  2、子View或者include标签  3、Fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip7-利用局部函数抽取重复代码&quot;&gt;Tip7-利用局部函数抽取重复代码&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、局部函数  2、扩展函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip8-使用数据类来快速实现model类&quot;&gt;Tip8-使用数据类来快速实现model类&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip9-用类委托来快速实现装饰器模式&quot;&gt;Tip9-用类委托来快速实现装饰器模式&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip10-Lambda表达式简化OnClickListener&quot;&gt;Tip10-Lambda表达式简化OnClickListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip11-with函数来简化代码&quot;&gt;Tip11-with函数来简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip12-apply函数来简化代码&quot;&gt;Tip12-apply函数来简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip13-在编译阶段避免掉NullPointerException&quot;&gt;Tip13-在编译阶段避免掉NullPointerException&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1、可空和不可空类型  2、let  3、Elvis操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip14-运算符重载&quot;&gt;Tip14-运算符重载&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip15-高阶函数简化代码&quot;&gt;Tip15-高阶函数简化代码&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Tip16-用Lambda来简化策略模式&quot;&gt;Tip16-用Lambda来简化策略模式&lt;/a&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>寒冬将至，Android的出路</title>
    <link href="http://yoursite.com/2018/11/14/%E5%AF%92%E5%86%AC%E5%B7%B2%E8%87%B3%EF%BC%8CAndroid%E7%9A%84%E5%87%BA%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/11/14/寒冬已至，Android的出路/</id>
    <published>2018-11-14T01:17:29.390Z</published>
    <updated>2018-11-14T07:14:22.521Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。</p></blockquote><h2 id="Android开发的天花板"><a href="#Android开发的天花板" class="headerlink" title="Android开发的天花板"></a>Android开发的天花板</h2><p>很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。</p><a id="more"></a><p>再说职业上，确实Android应用开发很难升任CTO，一般的CTO主要是后端，这主要是两个原因：后端的技术栈很早就成熟了，我8年前转做Android开发时，那帮30多岁的Java开发就已经很厉害了，随着时间的推移，后端技术大牛远比Android大牛的人数要多，也更厉害，他们做技术经理时，我们都还在搬砖；</p><p>后端确实可以统筹全局，在公司业务上属于重要地位。</p><p>不过我们忽略了最重要的一点，如果我们是做后端的，一定能做到CTO吗？我想也是很难的，所以不要眼睛只盯着高处，先想想自己能达到什么程度，站在半山腰就说山下面的风景不开阔本身也不合理啊。</p><h2 id="是否要转行"><a href="#是否要转行" class="headerlink" title="是否要转行"></a>是否要转行</h2><p>Android不热门了，很多Android开发已经转行了，有的正走在转行的路上，还有的迟疑不决，到底要不要转呢？我们来分析下。</p><h3 id="转什么好"><a href="#转什么好" class="headerlink" title="转什么好"></a>转什么好</h3><p>每个人的自身情况不同，转的方向也会有所区别，转人工智能相关开发肯定是最好的，毕竟风口上的猪也能飞，跟着风口无可厚非。只可惜人工智能相关对学历和算法要求很高，最起码得是个硕士吧，而且这只是低配。那么大多数Android开发可以转的方向主要有前端、后端和Python等等。我大概说一下：</p><p><strong>转前端</strong>，这个是我认为最好转的一个方向，前端的理念很多都和Android类似，也可以作为Android的延伸，向大前端发展，如果对界面感兴趣的可以转前端试试。</p><p><strong>转后端</strong>，后端这个就是完全的转行了，看似Java大家都会，但是后端的技术栈可不是只有Java，各种框架绝对叫你头大，很多人强调后端技术深，各种处理高并发看似十分有技术含量，不过这只是为数不多的公司在做。如果想要稳定的可以转后端试试。</p><p><strong>转Python</strong>，Python最近真是很火，因为他跟人工智能发生了关联，其实大部分学Python的没有搞什么人工智能相关，基本都是在搞爬虫。追求浪潮的可以转Python试试。</p><h3 id="不要轻易转行，要转就早点转"><a href="#不要轻易转行，要转就早点转" class="headerlink" title="不要轻易转行，要转就早点转"></a>不要轻易转行，要转就早点转</h3><p>转行有两种我认为是正常的，一种是行业消失或者没落了，个人无法施展才华。另一种是兴趣不在本行，因此转一个自己感兴趣的。而现在大部分转行纯属是为了跟风，为了那点钱，而忽略了长期的发展。我们来看看下面的图。<br><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.nosdn.127.net%2F123f022a99659255e455bf21d37d4150.jpeg&amp;thumbnail=690x2147483647&amp;quality=75&amp;type=jpg" alt=""></p><p>从图中可以看出，大部分人在35岁前是在加速期，35岁后是上升或者衰落期。以Android开发转前端来说，假设一个Android高级A同学转行前端会变为前端初级，这时从事前端的人都在加速提高，A同学要想赶超前面的拥有同样加速度的人是不可能办到的，这就导致他在转行前期极为被动，A同学还要保证在35岁前成为前端专家或者Leader才有可能在35岁后不进入衰落期，当然这时A同学的Android基本也就荒废了，很难成为专家。如果还想要在技术领域走的更远，就不要轻易的进行转行，如果想要转越早越好，越快越好，因为其他的竞争者都在加速提高，没人会停下等你的。</p><h3 id="转行大部分都不是质变"><a href="#转行大部分都不是质变" class="headerlink" title="转行大部分都不是质变"></a>转行大部分都不是质变</h3><p>一个开发的质变可以理解为在一个领域的大幅提升，或者是不相关领域的跨界，举个例子：可以在Android领域由高级质变为了专家，或者是由一个高级开发升到了Leader，再或者跨界开始做了一些技术相关的培训、演讲、出书等等而被人所熟知。凡是能帮助35岁后进入上升期的都可以看做是一次质变，而转行很少是质变，更多的是倒退回到原点重新出发，形象点来说，就是换了个不同的砖头接着搬砖而已（高技术含量的除外）。因此我们更应该去追求质变，而不是平行或者倒退，一次倒退可以承受，多次倒退就很难在35岁后进入上升期。</p><h2 id="如何提升竞争力"><a href="#如何提升竞争力" class="headerlink" title="如何提升竞争力"></a>如何提升竞争力</h2><h3 id="选择一个细分领域"><a href="#选择一个细分领域" class="headerlink" title="选择一个细分领域"></a>选择一个细分领域</h3><p>Android现在细分的领域非常多，前面说到的有应用开发、逆向安全、音视频、车联网、物联网、手机开发、SDK开发和智能电视盒子开发等等，在这些领域中选择一个并不断深入。比如音视频，在8年前我刚入门Android时，音视频就是闷声发大财了（PC端），工资高的令人乍舌，现在在移动端，音视频更是青出于蓝，是一个非常好的选择，如果想要入门可以看看何俊林《Android音视频开发》。</p><h3 id="尽量学习半衰期长的知识"><a href="#尽量学习半衰期长的知识" class="headerlink" title="尽量学习半衰期长的知识"></a><strong>尽量学习半衰期长的知识</strong></h3><p>知识半衰期指的是：随着知识更新周期变短，知识裂变速度加快，一个知识落伍的周期。知识半衰期长的职业都是越老越值钱的，比如英语老师和外科医生，知识更新慢并且几乎不会落伍。这一点我们程序员是绝对比不了的，我们的大部分知识半衰期是比较短的，一个框架短短几年可能就会被淘汰，这也导致程序员需要不断的学习新知识，而我们每个人的时间和精力是有限的，那么根据知识半衰期，有策略的进行学习就变得尤为重要。（这个观点很有吸引力）</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.nosdn.127.net%2F50daaac532daa7e224ddf4da5f436bdf.jpeg&amp;thumbnail=690x2147483647&amp;quality=75&amp;type=jpg" alt=""></p><p>上面的半衰期图不完全准确，但是却值得参考，如果你是其他的技术领域也可以参考这个半衰期图。这个图不是告诉我们不要去学RN和小程序，而是结合自身工作尽量学习半衰期长的知识。</p><h3 id="做减法，尽量专精一门技术"><a href="#做减法，尽量专精一门技术" class="headerlink" title="做减法，尽量专精一门技术"></a>做减法，尽量专精一门技术</h3><p>现在的社会，技术分工越来越细，越细就意味着大部分企业（小作坊除外）需要专精的人才（最好是精通一门通多门）。你会发现身边脱颖而出的技术人大多都是靠一门技术，却很少看到会一堆技术却都不精通的冒出来。好比在武侠的世界，高手对决都在同一个时间段拿出看家武学，如果看家武学都不精，分分钟被虐，剩下的武学也无需拿出来献丑了。联想到现实版本就是去大公司面试Android，结果Android技术了解不深，被各种虐，剩下的前端技术、后端技术、Python什么的，面试官也没兴趣了解了。</p><p>所以并不是你会的技术越多越好，一定要做好减法，先专精一门，然后再去学别的技术。（值得借鉴）</p><h3 id="说说最近Android火热的技术"><a href="#说说最近Android火热的技术" class="headerlink" title="说说最近Android火热的技术"></a>说说最近Android火热的技术</h3><p>Android相关的火热技术最近几年也是频出，没事就在刷屏，我来说说对这些火热技术的看法。</p><p><strong>Kotlin</strong>，从知识的半衰期来看，这门语言非常值得学习，不过想要普及还是非常难，因为Kotlin还没有表现出非用它不可的竞争力，另外很多企业使用的成本比较高，大多数领导都是不求有功但求无过，不会下力气推广。</p><p><strong>Flutter</strong>，从知识的半衰期来看，这个框架存在的时间相对不会长，目前也就一些有技术储备的公司去试验去尝试，如果自己公司技术储备不够，就贸然当小白鼠显然不是很明智。</p><p>这两个技术都建议大家来学习，但不要指望它们会给你增加什么太大竞争力，李四1周能学会，张三同样也能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文摘自CSND的《寒冬已至？四面楚歌的Android工程师该何去何从》，对于文中的一些观点比较认同，转载部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Android开发的天花板&quot;&gt;&lt;a href=&quot;#Android开发的天花板&quot; class=&quot;headerlink&quot; title=&quot;Android开发的天花板&quot;&gt;&lt;/a&gt;Android开发的天花板&lt;/h2&gt;&lt;p&gt;很多人觉得很多人会觉得Android技术深度不深，技术栈不庞大，Android职业发展有限，这个真是大大的误解。先说技术上，Android的技术栈随着时间的推移变得越来越庞大，细分领域也越来越多，主要有Android应用开发、逆向安全、音视频、车联网、物联网、手机开发和SDK开发等等，每个细分领域都有很多技术栈组成，深度都足够精深，就拿所有细分领域通用的Android系统底层源码来说，就会叫你学起来生不如死。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="规划" scheme="http://yoursite.com/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="半衰期" scheme="http://yoursite.com/tags/%E5%8D%8A%E8%A1%B0%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>小程序之CSS入门</title>
    <link href="http://yoursite.com/2018/11/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BCSS/"/>
    <id>http://yoursite.com/2018/11/09/微信小程序之CSS/</id>
    <published>2018-11-09T04:07:35.660Z</published>
    <updated>2018-11-14T07:24:37.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解css中的display属性（行内元素和块级元素）"><a href="#详解css中的display属性（行内元素和块级元素）" class="headerlink" title="详解css中的display属性（行内元素和块级元素）"></a>详解css中的display属性（行内元素和块级元素）</h1><blockquote><p>首先，所有主流浏览器都支持<strong>display</strong>属性。其次，display属性规定了元素应该生成的框的类型。默认值：<strong>inline</strong></p></blockquote><p>我们常用的display属性有：</p><ol><li>inline</li><li>block</li><li>inlien-block</li><li>none</li></ol><a id="more"></a><p>把display设置成none就不会保留元素本该显示的空间（元素直接不显示），但是visibility：hidden会保留。那么其他三个有什么区别呢？看下下面css代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;span class=&quot;inline&quot;&gt;</span><br><span class="line">inline</span><br><span class="line">&lt;/span&gt;inline </span><br><span class="line">&lt;span class=&quot;block&quot;&gt;</span><br><span class="line">block</span><br><span class="line">&lt;/span&gt;block </span><br><span class="line">&lt;span class=&quot;inline-block&quot;&gt;</span><br><span class="line">inline-block</span><br><span class="line">&lt;/span&gt; inline-block</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><a href="http://jsfiddle.net/qjgcjLm8/" target="_blank" rel="noopener">点此看效果</a></p><h2 id="inline特性"><a href="#inline特性" class="headerlink" title="inline特性"></a>inline特性</h2><p>我们发现内联对象inline给它设置属性height和width是没用的，致使它变宽变大的原因是：</p><blockquote><p>内部元素的宽高‘+padding’。观察inline对象的前后元素我们会发现inline<strong>不单独占一行</strong>，其他元素会紧跟其后。</p></blockquote><h2 id="block特性"><a href="#block特性" class="headerlink" title="block特性"></a>block特性</h2><blockquote><p>而块对象‘block’是可以设置宽高的，但是它的实际宽高是本身宽高+’padding‘。观察block的前后元素，我们会发现block<strong>会独占一行</strong>。</p></blockquote><p>如果，我们即希望div有宽高，又不希望它独占一行要怎么办？</p><h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>这个时候我们就需要’inline-block‘属性了，我们看下显示效果，就会发现：</p><blockquote><p>inline-block即具有block的宽高特性又具有inline的同行元素特性。</p></blockquote><p>也就是说，当我们想让一个元素即不独占一行，又可以设置其宽高属性的时候，我们就可以选择inline-block了。</p><h2 id="行内元素特点"><a href="#行内元素特点" class="headerlink" title="行内元素特点"></a>行内元素特点</h2><ol><li>和其他元素都在一行上；</li><li>元素的高度，宽度，行高及顶部和底部边距<strong>不可设置</strong>；</li><li>元素的宽度就是它包含的文字或图片的宽度，不可改变。</li></ol><h2 id="块级元素特点"><a href="#块级元素特点" class="headerlink" title="块级元素特点"></a>块级元素特点</h2><ol><li>每个块级元素都是从新的一行开始，并且其后的元素也另起一行；</li><li>元素的高度，宽度，行高及顶部和底部边距都是可以设置的；</li><li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素一致），除非设定一个宽度。</li></ol><p>在html中，span,a,lable,input,img,strong和em就是典型的行内元素。div,p,h1,form,ul,li就是块级元素。</p><p><strong>块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。</strong></p><p><a href="http://www.w3school.com.cn/cssref/pr_class_display.asp" target="_blank" rel="noopener">更多CSS display请参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;详解css中的display属性（行内元素和块级元素）&quot;&gt;&lt;a href=&quot;#详解css中的display属性（行内元素和块级元素）&quot; class=&quot;headerlink&quot; title=&quot;详解css中的display属性（行内元素和块级元素）&quot;&gt;&lt;/a&gt;详解css中的display属性（行内元素和块级元素）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先，所有主流浏览器都支持&lt;strong&gt;display&lt;/strong&gt;属性。其次，display属性规定了元素应该生成的框的类型。默认值：&lt;strong&gt;inline&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们常用的display属性有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;inline&lt;/li&gt;
&lt;li&gt;block&lt;/li&gt;
&lt;li&gt;inlien-block&lt;/li&gt;
&lt;li&gt;none&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程中的TCP和UDP通信方式简介</title>
    <link href="http://yoursite.com/2018/11/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP%E5%92%8CUDP/"/>
    <id>http://yoursite.com/2018/11/03/网络协议-TCP和UDP/</id>
    <published>2018-11-03T07:43:29.701Z</published>
    <updated>2018-12-04T06:23:24.449Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code）</p></blockquote><ol><li>TCP方式和UDP的区别</li><li>TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现</li><li>UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现</li></ol><div style="text-align: center"><img width="460" src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxuoyiu9cjj30kl0jj40i.jpg"></div><br><a id="more"></a><br><br>### 网络协议简介<br><br>通过上图知道不管是TCP还是UDP都是<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网络协议</a>中的一层—传输层协议。<br><br><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060804.png"></div><p>图中简单对网络协议做了分层，金典的网络协议是四层，这里给了不同的四层。</p><ol><li>最底层的以太网协议规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信，但是以太网协议不能解决多个局域网如何互通，这由IP协议解决（IP协议可以连接多个局域网）</li><li>IP协议定义了一套自己的地址规则，成为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息（路由器就是基于IP协议，局域网之间靠路由器连接）。</li><li>路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入很多根网线，路由器内部有一张路由表，规定了A段IP地址走出口一，B段IP地址走出口二。…通过这套指路牌，实现了数据包的转发。</li><li>IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要靠TCP协议了。</li></ol><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060806.jpg"></div><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>具体的TCP协议可能是一本书的内容，这里管中窥豹一下。简单来说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。</p><p>原来，我们只是简单知道TCP协议的七次==连接==，三挥四别，这里我们来完整了解下他其中的原理。</p><h6 id="TCP数据包大小"><a href="#TCP数据包大小" class="headerlink" title="TCP数据包大小"></a>TCP数据包大小</h6><p>以太网数据包（pakage）的大小是固定的，最初是1518字节，后来增加到了1522字节。其中，1500字节是负载（payload），22字节是头信息（head）。IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少20字节，所以IP数据包的负载最多1480字节，TCP数据包在IP数据包的负载里面，TCP的头也要占20字节，因此TCP数据包最大负载1460字节。由于，IP和TCP协议往往还有额外的头信心，所以TCP实际负载为1400字节左右，下图会清晰的表明这种关系：</p><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg20170060810.png"></div><p>因此，一条1500字节的信息需要两个TCP数据包来承载发送。==HTTP/2协议==的一大改进就是压缩了HTTP协议的头信息，使得一个HTTP请求可以放在一个TCP数据包里面，而不是分成多个，这样就提高了传输速度。</p><h6 id="TCP数据包的编号（SEQ）"><a href="#TCP数据包的编号（SEQ）" class="headerlink" title="TCP数据包的编号（SEQ）"></a>TCP数据包的编号（SEQ）</h6><p>一个包1400字节，那么发送一个10M大小的数据包，需要发送7100多个包，发送的时候，TCP协议会给每个包编号，一边接收方按照顺序还原，万一发生丢包，也可以知道丢失的是哪个包。一般第一个包编号是随机的。假设我们叫第一个包编号为1号包，这个包负载100字节，那么可以推算出下一个包的编号应该是101，就是说，每个数据包都可以得到两个编号：一个自身的编号，及下一个数据包的编号。几首方由此知道，应该按照什么顺序将他们还原成原始文件。（可以用抓包工具抓来看）</p><h6 id="TCP数据包的组装"><a href="#TCP数据包的组装" class="headerlink" title="TCP数据包的组装"></a>TCP数据包的组装</h6><p>收到TCP数据包以后，由操作系统来完成组装操作，应用程序是不会直接处理TCP数据包的，而是处理由他封装的例如HTTP协议的数据包。对应用程序来说，不用关心数据通信的细节，应用程序需要的数据放在了TCP数据包里面，有自己的格式（比如常见的HTTP协议），TCP不能标识原始文件大小，这个只能由应用层协议来规定，如HTTP头COntent-length，表示了信息体的大小。对于操作系统来说，就是持续的接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据，一旦组装好TCP数据包，就把他们交给引用程序（怎么组装呢？？），TCP数据包里面有个端口（port）就是用来指定转交给监听该端口的应用程序。</p><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060808.jpg"></div><p>如上图：系统根据TCP数据包中端口，将组装好的数据转交给相应的应用程序。如21端口是FTP服务器，25端口是SMTP（邮件协议）服务，80是Web服务器（常用的Http请求）。这些一般都是在服务端的。</p><h6 id="慢启动和ACK"><a href="#慢启动和ACK" class="headerlink" title="慢启动和ACK"></a>慢启动和ACK</h6><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。==TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。==（NB）。Linux 内核里面设定了（常量==TCP_INIT_CWND==），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。</p><ul><li>ACK 携带两个信息。<ul><li>期待要收到下一个数据包的编号。</li><li>接收方的接收窗口剩余容量</li></ul></li></ul><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060812.jpg"></div><p>（图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。）</p><p>即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。</p><h6 id="数据包的遗失处理"><a href="#数据包的遗失处理" class="headerlink" title="数据包的遗失处理"></a>数据包的遗失处理</h6><p>丢包时有发生，TCP的可靠性是怎么保证的呢？简单来说：由于每一数据包都带有编号，如有下一个数据包没收到，那么ACK的编号就不会发生变化。</p><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。==这会导致大量重复内容的 ACK==。如果发送方发现收到了==三个==连续重复的ACK，或者超时没收到任何ACK，就会确认丢包了，及5号包丢了，从而再次发送这个包，通过这种机制，TCP保证了不会有数据包丢失。==（好像TCP会丢包的）== 。下图比较形象说明了这个例子：</p><div style="text-align: center"><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060811.png"></div><p>（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><hr><hr><h3 id="Java的TCP实现（Socket）"><a href="#Java的TCP实现（Socket）" class="headerlink" title="Java的TCP实现（Socket）"></a>Java的TCP实现（Socket）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// InetAddress.getLocalHost()为客户端请求连接的主机号，此处设置为本地主机，服务进程的端口号是8090</span></span><br><span class="line">       <span class="comment">// 主机号和端口号唯一确定了唯一主机上面的唯一进程。</span></span><br><span class="line">       Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">8090</span>);</span><br><span class="line">       <span class="comment">// socket.getOutputStream()获得输出流，通过输出流像主机发送数据。</span></span><br><span class="line">       OutputStream os = socket.getOutputStream();</span><br><span class="line">       os.write(<span class="string">"黑猫呼叫白猫收到请回复!"</span>.getBytes());</span><br><span class="line">       <span class="comment">// 关闭数据输出，如果不关闭的话服务端并不知道数据传输已经结束还会一直等待。</span></span><br><span class="line">       socket.shutdownOutput();</span><br><span class="line">       <span class="comment">// 接收server端发送的数据</span></span><br><span class="line">       InputStream is = socket.getInputStream();</span><br><span class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           String str = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">       is.close();</span><br><span class="line">       os.close();</span><br><span class="line">       socket.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 给服务端一个端口号8090使得客户端可以连接。</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8090</span>);</span><br><span class="line">        <span class="comment">// 接受客户端的连接</span></span><br><span class="line">        Socket socket = ss.accept();</span><br><span class="line">        <span class="comment">// 获得客户端的输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 输出client端发送的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 通过输出流向客户端发送数据。</span></span><br><span class="line">        os.write(<span class="string">"黑猫这里是白猫，我已收到你的呼叫!"</span>.getBytes());</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="comment">// socket.shutdownOutput();</span></span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要通过以下几个方面来解释两种方式的区别（enough talk and let’s look at some code）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;TCP方式和UDP的区别&lt;/li&gt;
&lt;li&gt;TCP的上层应用Socket实现：Socket，ServerSocket以及代码实现&lt;/li&gt;
&lt;li&gt;UDP的上层应用Socket实现：DatagramSocket，DatagramPacket以及代码实现&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&quot;text-align: center&quot;&gt;&lt;img width=&quot;460&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNbRwgy1fxuoyiu9cjj30kl0jj40i.jpg&quot;&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HEXO+Github搭建个人Blog</title>
    <link href="http://yoursite.com/2018/10/24/HEXO+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog/"/>
    <id>http://yoursite.com/2018/10/24/HEXO+Github搭建个人Blog/</id>
    <published>2018-10-24T10:53:18.938Z</published>
    <updated>2018-11-14T07:31:04.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HEXO背景"><a href="#HEXO背景" class="headerlink" title="HEXO背景"></a>HEXO背景</h2><p>hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面</p><ul><li>超快部署</li><li>支持MarkDown</li><li>一键部署</li><li>丰富的插件</li></ul><blockquote><p>下面以我的<a href="https://ervinsae.github.io/" target="_blank" rel="noopener">Blog</a>为例，记录搭建过程。</p></blockquote><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li><strong>安装NodeJs</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//mac下安装node很简单，使用mac下的包管理工具brew命令就可以了</span><br><span class="line"></span><br><span class="line">$ brew install node</span><br><span class="line">$ brew install npm</span><br><span class="line"></span><br><span class="line">//brew一般被安装在/usr/local/bin 目录下面</span><br><span class="line"></span><br><span class="line">//验证是否安装成功</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure><ul><li><strong>安装HEXO</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><ul><li><strong>运行</strong></li></ul><p>装上Hexo后就可以在本地跑服务了，执行一下命令（HEXO的常见命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">// 生成静态网页</span><br><span class="line">$ hexo g / hexo generator</span><br><span class="line">// 开启服务</span><br><span class="line">$ hexo s / hexo server</span><br><span class="line"></span><br><span class="line">运行：localhost：4000</span><br></pre></td></tr></table></figure><h2 id="托管"><a href="#托管" class="headerlink" title="托管"></a>托管</h2><p>托管就是将你生成的静态网页保存在服务器上，别人可以通过域名去访问（当然需要在hexo上去配置）.</p><p>一般是在github上免费托管，也可以自己去买个小鸡，既可以搭个小机场，也可以托管博客.</p><blockquote><p>如果要部署到github上，首先要有GitHub账号（没有的可以不用看了），然后在仓库建一个”github账号.github.io” <strong>名字一定要一样</strong></p></blockquote><ul><li>添加部署插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>添加git源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编辑根目录.config.yml</span><br><span class="line">vim .config.yml</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br></pre></td></tr></table></figure><blockquote><p>branch为分支，默认为master,可以不配置 repo为仓库地址，在github上新建仓库后，可复制此地址</p></blockquote><ul><li>添加源后就可以部署了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>关于hexo的配置都在根目录下的.config_yml下面，而关于主题的配置都在/theme/**/.config_yml下面，详细配置可以查看<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官方文档</a></p><ul><li><strong>title</strong> -&gt; 网站标题</li><li><strong>subtitle</strong> -&gt; 网站副标题</li><li><strong>description</strong> -&gt; 网站描述</li><li><strong>author</strong> -&gt; 您的名字</li><li><strong>language</strong> -&gt; 网站使用的语言</li><li><strong>theme</strong> -&gt; 主题配置（主题名字 /theme目录下）</li></ul><blockquote><p>坑：<strong>进行配置时，需要在冒号:后加一个英文空格</strong></p></blockquote><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>Hexo 中有很多主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>查看。主题现在比较流行的是Next — <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>。</p><ul><li>下载：<br>推荐去官方看最新下载。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><ul><li>设置<br>主要是在theme/next/_config.yml文件。然后去找官方或者别人的方案修改即可。</li></ul><ul><li>发布文章</li></ul><ol><li>使用命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new test</span><br></pre></td></tr></table></figure></li></ol><p>此时会在<code>source/_posts</code>目录下生成<code>test.md</code>文件，输入些许内容，然后保存.</p><ol start="2"><li>直接将写好的markdown文件放在_posts文件下面即可，在markdown下添加头部</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">categories: []</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ol start="3"><li>使用命令查看效果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h3><p>主题美化借鉴了一些前人的集思广益，参考了网上许多文章教程，本博客就是实践出来的，感谢！</p><p>这里mark一些借鉴连接，供大家详参！</p><p><a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/" target="_blank" rel="noopener">Hexo主题美化</a></p><p><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">干货</a></p><p><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">Hexo官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HEXO背景&quot;&gt;&lt;a href=&quot;#HEXO背景&quot; class=&quot;headerlink&quot; title=&quot;HEXO背景&quot;&gt;&lt;/a&gt;HEXO背景&lt;/h2&gt;&lt;p&gt;hexo是基于NodeJS的静态博客框架，简单，轻量，其生成的静态页面可以托管在Github或者Heroku上面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超快部署&lt;/li&gt;
&lt;li&gt;支持MarkDown&lt;/li&gt;
&lt;li&gt;一键部署&lt;/li&gt;
&lt;li&gt;丰富的插件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;下面以我的&lt;a href=&quot;https://ervinsae.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Blog&lt;/a&gt;为例，记录搭建过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="主题" scheme="http://yoursite.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Android存储</title>
    <link href="http://yoursite.com/2018/10/22/Android%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/10/22/Android存储/</id>
    <published>2018-10-22T02:47:38.297Z</published>
    <updated>2018-11-14T07:24:52.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android存储路径"><a href="#Android存储路径" class="headerlink" title="Android存储路径"></a>Android存储路径</h2><p>先来看一张大图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6375763-1a6adf86e6c05e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p><a id="more"></a><h3 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h3><blockquote><p>Environment.getDataDirectory().getParentFile();也就是根目录，一般就是指/data/data目录下的数据，需要root之后可以看见</p></blockquote><ol><li>/data/app</li></ol><p>该文件存放着系统中安装的第三方应用apk</p><blockquote><p>Android的应用安装就是将应用安装包拷贝到/data/app目录下面，每个包本质是一个zip压缩文件。为了提升启动效率，Android会将解压的dex提取出来，缓存在/data/dalvik-cache目录下</p></blockquote><table><thead><tr><th>api</th><th>路径</th></tr></thead><tbody><tr><td>getDataDirectory()</td><td>/data</td></tr><tr><td>getDownloadCacheDirectory()</td><td>/cache</td></tr><tr><td>getRootDirectory()</td><td>/system</td></tr></tbody></table><ol start="2"><li>/data/data</li></ol><p>该文件夹存放存储包==私有数据==，对于设备中每一个安装的App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。用户卸载 App 时，系统自动删除data/data目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类：</p><table><thead><tr><th>地址</th><th>说明</th><th>api</th></tr></thead><tbody><tr><td>data/data/包名/cache</td><td>存放缓存信息</td><td>context.getCacheDir()</td></tr><tr><td>data/data/包名/database</td><td>APP数据库信息</td><td>context.getDataDir() / context.getDatabasePath(name)</td></tr><tr><td>data/data/包名/files</td><td>存放APP的文件信息</td><td>context.getFilesDir()</td></tr></tbody></table><h3 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h3><p>每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/200711-d0e0749ef4cc8a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p><ol><li>获取外部存储路径及状态</li></ol><ul><li><p>Environment.getExternalStorageState()</p></li><li><p>Environment.getExternalStorageDirectory()</p></li></ul><ol start="2"><li>公共目录</li></ol><blockquote><p>Android在外部存储上提供了十个公共目录来存储对应的文件，通过api：Environment.getExternalStoragePublicDirectory(type)来访问</p></blockquote><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>DIRECTORY_MUSIC</td><td>/storage/emulated/0/Music</td></tr><tr><td>DIRECTORY_PODCASTS</td><td>/storage/emulated/0/Podcasts</td></tr><tr><td>DIRECTORY_RINGTONES</td><td>/storage/emulated/0/Ringtones</td></tr><tr><td>DIRECTORY_ALARMS</td><td>/storage/emulated/0/Alarms</td></tr><tr><td>DIRECTORY_NOTIFICATIONS</td><td>/storage/emulated/0/Notifications</td></tr><tr><td>DIRECTORY_PICTURES</td><td>/storage/emulated/0/Pictures</td></tr><tr><td>DIRECTORY_MOVIES</td><td>/storage/emulated/0/Movies</td></tr><tr><td>DIRECTORY_DOWNLOADS</td><td>/storage/emulated/0/Downloads</td></tr><tr><td>DIRECTORY_DCIM</td><td>/storage/emulated/0/Dcim</td></tr><tr><td>DIRECTORY_DOCUMENTS</td><td>/storage/emulated/0/Documents</td></tr></tbody></table><p><strong>3. 私有目录</strong></p><p>Android2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。==与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。==<br>==和内部存储一样，会在 SD 卡的 Android/data ++目录下生成对应包名的文件夹++==</p><table><thead><tr><th>地址</th><th>api</th></tr></thead><tbody><tr><td>/storage/emulated/0/Android/data/应用包名/files</td><td>context.getExternalFilesDir(type)</td></tr><tr><td>/storage/emulated/0/Android/data/应用包名/cache</td><td>context.getExternalCacheDir()</td></tr><tr><td>/storage/emulated/0/Android/obb/应用包名</td><td>context.getObbDir()</td></tr></tbody></table><h3 id="Android其它目录"><a href="#Android其它目录" class="headerlink" title="Android其它目录"></a>Android其它目录</h3><blockquote><p>/system/app 和 /data/app 的区别</p></blockquote><ul><li>/data/app 里软件权限没全开，/system/app 里的软件获取了所有权限</li><li>/data/app 可以应用卸载，/system/app 只能 root 后删除</li><li>/data/app 文件夹大小随便，/system/app 文件夹有大小限制</li><li>卸载/system/app 目录下的文件并不会增加系统空间，即可用 ROM 空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android存储路径&quot;&gt;&lt;a href=&quot;#Android存储路径&quot; class=&quot;headerlink&quot; title=&quot;Android存储路径&quot;&gt;&lt;/a&gt;Android存储路径&lt;/h2&gt;&lt;p&gt;先来看一张大图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6375763-1a6adf86e6c05e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>思维的误区-幸存者偏见</title>
    <link href="http://yoursite.com/2018/10/21/%E6%80%9D%E7%BB%B4%E7%9A%84%E8%AF%AF%E5%8C%BA-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81%20/"/>
    <id>http://yoursite.com/2018/10/21/思维的误区-幸存者偏见 /</id>
    <published>2018-10-21T08:23:35.256Z</published>
    <updated>2018-11-14T07:23:02.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为“幸存者偏见”"><a href="#何为“幸存者偏见”" class="headerlink" title="何为“幸存者偏见”"></a>何为“幸存者偏见”</h2><p>   “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。</p><p>&emsp;&emsp;&emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：<br>当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。<br>为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下：</p><blockquote><p>有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。<br>某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？</p></blockquote><a id="more"></a><h2 id="不同领域中的“幸存者偏见”"><a href="#不同领域中的“幸存者偏见”" class="headerlink" title="不同领域中的“幸存者偏见”"></a>不同领域中的“幸存者偏见”</h2><p>西赛罗的那个故事，属于宗教领域的“幸存者偏见”。除了宗教领域，还有很多领域（甚至可以说，所有的领域）都会存在这类偏见。下面，俺挑选几个领域来举例。</p><ul><li>IT 领域——创业的“银弹”</li></ul><p>&emsp;&emsp;&emsp;作为 IT 从业人员，俺经常在某些 IT 网站上看到某某公司的创业事迹。如果你也跟俺一样，估计这方面的故事也看了不少。</p><p>&emsp;&emsp;&emsp;不知你有没有发现，那些广为流传的创业案例，都是【成功】案例。越成功的，越具有传奇色彩，被宣传的次数就越多（比如乔布斯、盖茨）。相反，那些创业【失败】的案例，（相比而言）被提及的次数非常非常少。</p><p>&emsp;&emsp;&emsp;这会产生啥问题捏？</p><p>&emsp;&emsp;&emsp;假设某个有志青年想要创业，他看了很多创业成功的案例，这些案例都提到某些共同的因素。于是捏，此人就误以为这些共同的因素是“银弹”——只要具备这些银弹，创业必定成功。这就如同西赛罗的那个故事——只看到存活的祈祷者，就误以为“祈祷”是存活的【充分条件】。</p><ul><li>成功学领域——虚假的“充分条件”</li></ul><p>&emsp;&emsp;&emsp;说完“创业”，很自然就联想到“成功学”。那些鼓吹“成功学”的文章/书籍，通常存在很多谬误，其中一个谬误是——号称“某某方法论”是成功的【充分条件】。换句话说，只要具备了该方法论，就一定可以获得成功。</p><p>&emsp;&emsp;&emsp;为啥俺说这是一个谬误捏？因为这些鼓吹成功学的文章/书籍，通常都【没有】去检验：该方法论是否也出现在失败者身上。只要有一个失败者也采用了该方法论，就足以说明——这个方法论【不是】成功的充分条件。比如说，很多成功学的理论提到了“勤奋”是成功的充分条件。但其实捏，勤奋而没有成功的，大有人在。</p><ul><li>投资领域——仅凭运气的“股神”</li></ul><p>最近半年，天朝股市迎来新一轮的牛市行情。前几天有读者建议俺聊聊股市的话题，所以今天顺便拿投资领域来说事儿。似乎在每一个国家的股市中，都有那么几个人被誉为“股神”。如果碰到牛市，被冠以“股神”的人还会再多出好几倍。（暂且【不】考虑“弄虚作假、谎报战绩”的情况）假设这些获得股神称号的人，都在实际操作过程中获得远高于大盘的收益率，他们有资格获得“股神”的称号吗？为了说明这个例子，俺转载某篇文章的其中一段（此文写于1984年）。</p><blockquote><p>我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。<br>每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。</p></blockquote><h2 id="“幸存者偏见”导致的问题"><a href="#“幸存者偏见”导致的问题" class="headerlink" title="“幸存者偏见”导致的问题"></a>“幸存者偏见”导致的问题</h2><ul><li>错误的认知</li></ul><p>这个最好理解了——由于“错误的认知”会导致你对“沉默证据”的忽视，所以你对该领域的认知是不完全的。</p><ul><li>错误的归因 </li></ul><p>在【只看到】“显式样本”的情况下，你可能会产生一些错误的归因。“幸存者偏见”导致的“错误归因”会有很多种。俺这里仅举几个例子。</p><p>　　<strong>因果倒置</strong></p><p>想必大伙儿都看过举重比赛。对于举重运动员，很多人都有一个错误的观点——以为这些运动员是在练习举重之后，才导致身材变得矮壮。但实际上捏，举重队在一开始筛选运动员的时候，就把那些身材细长的忽略掉了（这些身材细长的候选人，就是“沉默的样本”）。换句话说，是因为他们身材矮壮，才有可能被选中去参加举重培训，而不是因为参加举重培训导致身材如此——这就是【因果倒置】。</p><p>　　<strong>牵强的归因（无中生有）</strong><br>　　<br>假设某个赌徒去赌场玩“押大小”（此游戏的胜负概率皆为 50%），连续赢了10次。对于大型赌场，每天来玩的人足够多，那么一段时间之后，总会出现某个赌徒玩“押大小”连续赢10次（甚至更多次）。从概率学的角度讲，这是很普通的。但是对该赌徒而言，如果他陷入了“幸存者偏见”这个误区，他就会企图给这个现象找到一个解释（进行“归因”）。假如此人是个宗教信徒，他/她可能会断言——有神明相助。这就属于“牵强的归因”——把【随机事件】看作是有其它原因，并企图在随机性之外寻找一个解释。</p><p>　　　</p><ul><li>错误的决策</li></ul><p>还以刚才赌徒的例子来说事儿。假设这个赌徒是宗教信徒，并且误以为自己连续赢10次是神明相助，那么他/她就会获得一种【虚假的信心】，并在这个“虚假信心”的支持下继续玩，甚至还会加大赌注/筹码。最后的结局很可能是——彻底输光。这就是“幸存者偏见”导致的“错误决策”。如果你比较喜欢琢磨，可以把这个赌场的例子替换成天朝的牛市，你会发现其中有某些相通之处。</p><h2 id="如何对付“幸存者偏见”？"><a href="#如何对付“幸存者偏见”？" class="headerlink" title="如何对付“幸存者偏见”？"></a>如何对付“幸存者偏见”？</h2><ol><li>意识到“沉默证据”的存在</li></ol><p>这是最起码的一点——你首先要能意识到“沉默证据”的存在。这说起来容易，做起来很难——你需要形成这样一种思维习惯：每当看到“显式的证据”，你都要在内心反问：是否存在与之对应的“隐式证据”？</p><ol start="2"><li>找到不同类型、不同层次的“沉默证据”</li></ol><p>在前一条的基础上，你如果能找到“沉默的证据/隐式的证据”，自然就会获得更全面的认知。有必要提醒一下：“隐式的证据”有时候不止一种类型。碰到这种情况，不是每个人都能想到所有的类型。前面提到的“天朝舆论”的例子。那些思考问题不够深入的同学，通常只意识到“网管审查/删贴”导致的“沉默证据”，而忽略了更隐蔽的“沉默证据”——那些连上网条件都没有的人，是无法在网上表达不满的。</p><ol start="3"><li>决定一个样本会成为“隐式样本”or“显式样本”，有两种可能：<br>情况A<br>至少有一个原因在起作用（比如前面提到“莎草纸的例子”，气候是原因之一）<br>情况B<br>根本就【没有任何原因】（比如前面提到的“抛硬币的猩猩”），仅仅是随机性决定了某个样本会成为“显式” or “隐式”。对此种情况，如果你非要去找出一个原因，就会出现前面提到的“牵强的归因”。</li></ol><p>如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。<br>具体该如何排除捏？在本文的最后，咱们重新回到本文开头提到的那篇巴菲特演讲。在说完“猩猩抛硬币”的游戏之后，巴菲特又说了如下一段话。通过这段话，你可以借鉴一下——如何规避“随机因素”的干扰。</p><blockquote><p>然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，<br>(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；<br>(b)如果经过20天的竞赛，只剩下215只赢家；<br>(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。</p></blockquote><blockquote><p>于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……<br>换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。</p></blockquote><blockquote><p>科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。</p></blockquote><blockquote><p>除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。</p></blockquote><blockquote><p>在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。</p></blockquote><blockquote><p>我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。<br>……</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何为“幸存者偏见”&quot;&gt;&lt;a href=&quot;#何为“幸存者偏见”&quot; class=&quot;headerlink&quot; title=&quot;何为“幸存者偏见”&quot;&gt;&lt;/a&gt;何为“幸存者偏见”&lt;/h2&gt;&lt;p&gt;   “幸存者偏见”，洋文写作“survivorship bias”或“survival bias”，维基百科的链接在“这里”。这玩意儿属于“认知偏差”的一种。（关于“认知偏差”这个话题，俺博客上曾经写过几篇，比如：“沉没成本谬误”、“光环效应”、“从众心理”）。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;如果用一句通俗的话来概括“幸存者偏见”，就是【死人没法开口】。如果要说得更具体点，那就是：&lt;br&gt;当你在分析某个事物的时候，可能会面对诸多的证据（样本）。但是大多数人通常只注意到【显式】的样本和证据，而忽略了【隐式】的样本和证据。从而得出错误的认知、错误的结论。&lt;br&gt;为了更形象一些，俺来说一下“幸存者偏见”的出处——古罗马的西赛罗（与凯撒同时代的知名政治家、文学家、演说家）讲过一个故事，大意如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一群宗教信徒在某次沉船事故中幸存。幸存后捏，他们就找人作画（画面上是一群人在事故中祈祷），以此来宣扬说：因为他们作了虔诚的祷告，所以才在沉船事故中幸存。&lt;br&gt;某信徒拿了这幅画给一个无神论者看。这个无神论者直接反问道：那些祈祷之后淹死的人，他们的画像在哪里？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="思维" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="好文" scheme="http://yoursite.com/tags/%E5%A5%BD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>mac下全局翻墙</title>
    <link href="http://yoursite.com/2018/10/20/Mac%E4%B8%8B%E7%9A%84%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/20/Mac下的全局代理/</id>
    <published>2018-10-20T07:26:29.134Z</published>
    <updated>2018-11-14T07:32:01.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下全局翻墙"><a href="#Mac下全局翻墙" class="headerlink" title="Mac下全局翻墙"></a>Mac下全局翻墙</h2><ol><li>路由翻墙</li><li>ssr + .bash_profile</li><li>使用工具，类似profixer，surge等</li></ol><blockquote><p>使用iterm的，环境变量也可以使用.bash的(需要在.zsh中去设置环境变量走.bash_profile)也可以在.zshrc中</p></blockquote><blockquote><p>由于ss或者ssr只是支持了socks5的代理，也就是所有的都走socks5协议，而浏览器本身是支持socks5的（当然还有http，https，ftp等），但是如果你想mac上装的客户端，比如telegram也能通过ssr达到科学上网就想多了，但是这些软件，还比如AS都可以手动去设置代理的（socks5），一般ssr默认的设置如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip：127.0.0.1</span><br><span class="line"># http走的是1087端口</span><br><span class="line">port：1086</span><br></pre></td></tr></table></figure><h2 id="方法2设置步骤"><a href="#方法2设置步骤" class="headerlink" title="方法2设置步骤"></a>方法2设置步骤</h2><ul><li>vimb(vim .bash_profile)</li><li>修改文件（添加下面代码）</li><li>source .bash_profile</li><li>验证：curl <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># proxy</span><br><span class="line">proxy=socks5://127.0.0.1:1086</span><br><span class="line">export http_proxy=$proxy</span><br><span class="line">export https_proxy=$proxy</span><br><span class="line">export ftp_proxy=$proxy</span><br></pre></td></tr></table></figure><p>通过上面设置就能在命令行中发现已经可以科学上网了，目前还有两个蛋痛的地方没解决：</p><ul><li>profixer在mac上装不了了，一直弹窗。权限都给了</li><li>使用Google Drive同步文件用不了，只有将ssr设置全局才可以，MD。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mac下全局翻墙&quot;&gt;&lt;a href=&quot;#Mac下全局翻墙&quot; class=&quot;headerlink&quot; title=&quot;Mac下全局翻墙&quot;&gt;&lt;/a&gt;Mac下全局翻墙&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;路由翻墙&lt;/li&gt;
&lt;li&gt;ssr + .bash_profile&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>网易云集成IM</title>
    <link href="http://yoursite.com/2018/10/20/%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1IM%E9%9B%86%E6%88%90%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/20/网易云信IM集成要点/</id>
    <published>2018-10-20T07:26:20.467Z</published>
    <updated>2018-11-14T07:23:56.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面</p><a id="more"></a><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>集成其实很简单，网易提供了两种方式，jar和gradle，毫无疑问gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 基础功能 (必需)</span><br><span class="line">netease_basesdk       : &apos;com.netease.nimlib:basesdk:5.1.1&apos;,</span><br><span class="line">// 音视频需要</span><br><span class="line">netease_avchat        : &apos;com.netease.nimlib:avchat:5.1.1&apos;,</span><br><span class="line">// 音视频需要</span><br><span class="line">netease_nrtc          : &apos;com.netease.nimlib:nrtc:5.1.1&apos;,</span><br><span class="line">// 全文检索服务需要</span><br><span class="line">netease_lucene        : &apos;com.netease.nimlib:lucene:5.1.1&apos;,</span><br></pre></td></tr></table></figure><blockquote><p>其中第一个是早就集成了的，自带IM功能，第二第三则是音视频需要的，第四个是需要做聊天记录搜索要用到的</p></blockquote><ol><li>APPID申请</li><li>权限</li><li>初始化</li></ol><ul><li>前两个看官方文档就可以了，初始化一般就是在主APP的Aplication中进行，代码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 注册通知消息过滤器</span><br><span class="line">registerIMMessageFilter();</span><br><span class="line"></span><br><span class="line">// 初始化消息提醒</span><br><span class="line">NIMClient.toggleNotification(true);</span><br><span class="line"></span><br><span class="line">// 注册网络通话来电</span><br><span class="line">enableAVChat();</span><br><span class="line"></span><br><span class="line">//初始化IM UI组件</span><br><span class="line">NimUIKit.init(this);</span><br></pre></td></tr></table></figure><p>官方文档和demo中也有说明，需要使用到哪种能力就去初始化哪些，比如该版本还用到了IM的自定义消息，那么也必须在这里进行注册</p><blockquote><p>注意：以上的初始化只能在主线程中进行，为此，云信提供了一个API：NIMUtil.isMainProcess(this)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NIMClient.getService(MsgService.class).registerCustomAttachmentParser(new CustomAttachParse());</span><br><span class="line">        </span><br><span class="line">NimUIKit.registerMsgItemViewHolder(DiagnosisMsg.class, MsgViewHolderDiagnosis.class);</span><br></pre></td></tr></table></figure><ol start="4"><li>IM消息监听</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注册IM消息监听</span><br><span class="line">        NIMClient.getService(MsgServiceObserve.class)</span><br><span class="line">                .observeReceiveMessage(messageObserver, true);</span><br><span class="line">// 反注册</span><br><span class="line">        NIMClient.getService(MsgServiceObserve.class)</span><br><span class="line">                .observeReceiveMessage(messageObserver, false);</span><br></pre></td></tr></table></figure><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul><li><strong>注册登陆</strong>：集成网易云后，需要将本地用户与网易云id关联，每一个用户在网易云有一个唯一的accid和token，对于登陆相当于用户名及密码，对于业务比如：视频/IM则相当与电话号码，你需要和别人通信的时候必须知道对方的accid。</li><li><strong>用户信息托管</strong>：由于本地用户在网易云有一个id关联，那么当要用到网易云的一些能力的时候，我们希望用户的一些基础信息（头像，昵称）是要与本地后端保持一致的。</li><li><strong>消息锚点</strong>：其实就是一个消息对象，它携带了一些时间或者其他信息，方便搜索。</li></ul><blockquote><p>上面两点都是本地后端处理的，前段需要处理的则是，在登陆系统成功后，需要手动调用网易登陆api去帮助用户登陆到网易云，并且监听用户的登陆状态。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void nimLogin(User user) &#123;</span><br><span class="line">        LoginInfo info = new LoginInfo(user.accid, user.token); // config...</span><br><span class="line">        RequestCallback&lt;LoginInfo&gt; callback =</span><br><span class="line">                new RequestCallback&lt;LoginInfo&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSuccess(LoginInfo param) &#123;</span><br><span class="line">                        Logger.d(&quot;login nim success&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onFailed(int code) &#123;</span><br><span class="line">                        Logger.d(&quot;login nim failed :&quot; + code);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onException(Throwable exception) &#123;</span><br><span class="line">                        Logger.e(exception, &quot;login nim failed&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">        AbortableFuture&lt;LoginInfo&gt; request = NIMClient.getService(AuthService.class).login(info);</span><br><span class="line">        request.setCallback(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void observeNimOnlineStatus(User user) &#123;</span><br><span class="line">        NIMClient.getService(AuthServiceObserver.class).observeOnlineStatus(</span><br><span class="line">                (Observer&lt;StatusCode&gt;) status -&gt; &#123;</span><br><span class="line">                    Log.i(&quot;nim&quot;, &quot;User status changed to: &quot; + status);</span><br><span class="line">                    if (status.shouldReLogin()) &#123;</span><br><span class="line">                        new Handler().postDelayed(() -&gt; nimLogin(user), 5000);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="IM相关"><a href="#IM相关" class="headerlink" title="IM相关"></a>IM相关</h1><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>由于lib_neteaseui库提供了界面能力，所以自然自定义界面的话需要集成他的界面，这里有两种方式</p><ol><li>集成现有类（比如p2pmessage）,只需要修改layout，并且传递需要的参数即可。</li><li>继承SDK中的UI并实现ModuleProxy代理类中方法</li></ol><h3 id="开启单聊"><a href="#开启单聊" class="headerlink" title="开启单聊"></a>开启单聊</h3><p>很简单直接看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMMessageActivity.start(getContext(), entity.accid, customization, null, IMMessageActivity.class);</span><br></pre></td></tr></table></figure><p>其中，entity.accid代表了对方的号码。</p><h3 id="消息面板设置"><a href="#消息面板设置" class="headerlink" title="消息面板设置"></a>消息面板设置</h3><ol><li>面板类：MessageListPanelEx，这里面封装了发送消息面板的所有功能</li><li>抽屉：基类BaseAction，比如拍照，相片或者自定义类型都是通过这个基类来实现的。</li><li>IM面板layout：nim_message_activity_text_layout</li><li>设置用户托管信息：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置网易云用户资料（IM中的头像，昵称等）</span><br><span class="line">NimUserManager.setUserBasicInfo(user.patientName,user.imgUrl);</span><br></pre></td></tr></table></figure><h3 id="消息设置"><a href="#消息设置" class="headerlink" title="消息设置"></a>消息设置</h3><ol><li>消息屏蔽：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//屏蔽所有消息</span><br><span class="line">NIMClient.toggleNotification(false);</span><br><span class="line">//屏蔽某个用户消息</span><br><span class="line">NIMClinet.getService(FriendService.class).setMessageNotify(account,checkState)</span><br></pre></td></tr></table></figure><ol start="2"><li>消息接收</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * IM消息监听</span><br><span class="line">     */</span><br><span class="line">    com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt; messageObserver = new com.netease.nimlib.sdk.Observer&lt;List&lt;IMMessage&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onEvent(List&lt;IMMessage&gt; imMessages) &#123;</span><br><span class="line">            Logger.d(&quot;im message received&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义消息</li></ol><p>自定义消息比较复杂，参见代码。具体步骤如下：</p><ul><li>定义消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 需要多端统一</span><br><span class="line"> */</span><br><span class="line">public interface CustomAttachmentType &#123;</span><br><span class="line"></span><br><span class="line">    int diagnosisMsg = 1001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义消息的基础类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CustomAttachment implements MsgAttachment &#123;</span><br><span class="line">    protected int type;</span><br><span class="line">    CustomAttachment(int type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    public void fromJson(JsonObject data) &#123;</span><br><span class="line">        if (data != null) &#123;</span><br><span class="line">            parseData(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toJson(boolean send) &#123;</span><br><span class="line">        return CustomAttachParse.packData(type, packData());</span><br><span class="line">    &#125;</span><br><span class="line">    public int getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract void parseData(JsonObject data);</span><br><span class="line">    protected abstract JsonObject packData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义消息结构类（用于组装自定义数据）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class DiagnosisMsg extends CustomAttachment</span><br></pre></td></tr></table></figure><ul><li>自定义消息解析类（用于显示自定义消息）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class CustomAttachParse implements MsgAttachmentParser</span><br></pre></td></tr></table></figure><p><a href="https://github.com/netease-im/NIM_Android_UIKit/blob/master/documents/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF.md" target="_blank" rel="noopener">参见官方文档</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>注册账号accid网易云强制小写</li><li>网易云消息从后端还是本地拉取</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageListPanel = new MessageListPanelEx(container, rootView, anchor, false, remote);</span><br></pre></td></tr></table></figure><p>其中最后一个参数remote = true表示从云端拉取数据</p><ol start="3"><li>IM聊天点击头像事件<br>layout：MsgAdapter中layout.nim_message_item</li></ol><p>点击事件：<strong>NimUIKitImpl.setSessionListener</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中需要实现IM通信功能，其实原来已经继承了云信的视频SDK，而IM模块其实已经在SDK中了，但是由于我们的IM聊天界面是需要自己定制了，因此就加了添加了一个lib-ui的库，方便去自定义IM界面&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的常用命令行</title>
    <link href="http://yoursite.com/2018/10/19/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/19/Mac下的常用命令/</id>
    <published>2018-10-18T16:40:41.924Z</published>
    <updated>2018-11-14T07:31:34.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看IP"><a href="#查看IP" class="headerlink" title="查看IP"></a>查看IP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$curl ip.gs</span><br><span class="line"></span><br><span class="line">$ifconfig</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="关于文件操作"><a href="#关于文件操作" class="headerlink" title="关于文件操作"></a>关于文件操作</h3><p>由于mac下面不能使用右键新建文件，所以需要使用一些工具，如workflow，或者直接命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件如果没有则创建新文件</span><br><span class="line">touch filename</span><br><span class="line"># 新建文件夹</span><br><span class="line">mkdir filename</span><br><span class="line"># 删除文件或者目录</span><br><span class="line">rm -rf filename</span><br><span class="line"># 查看文件详细信息</span><br><span class="line">stat filename</span><br><span class="line"></span><br><span class="line"># 查看目录结果，需要装tree</span><br><span class="line">npm install tree</span><br><span class="line">tree -L 1</span><br></pre></td></tr></table></figure><h3 id="vim常规操作"><a href="#vim常规操作" class="headerlink" title="vim常规操作"></a>vim常规操作</h3><table><thead><tr><th>操作命令</th><th>效果</th></tr></thead><tbody><tr><td>i</td><td>在光标处插入，进入编辑模式</td></tr><tr><td>dd</td><td>剪切光标所在的一行内容</td></tr><tr><td>yy</td><td>复制光标所在的一行内容</td></tr><tr><td>D</td><td><strong>删除光标右边的所有内容</strong></td></tr><tr><td>gg</td><td>将光标快速移动到文件首</td></tr><tr><td>G</td><td>将光标快速移动到文件尾</td></tr><tr><td>0</td><td>将光标快速移动到行首</td></tr><tr><td>$</td><td>将光标快速移动到行尾</td></tr></tbody></table><table><thead><tr><th>退出命令</th><th>效果</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>未保存直接退出（如果没有修改，用下面的命令）</td></tr><tr><td>:q！</td><td>强制退出</td></tr><tr><td>:wq</td><td>保存退出</td></tr><tr><td>:wq</td><td>强制保存退出</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查看IP&quot;&gt;&lt;a href=&quot;#查看IP&quot; class=&quot;headerlink&quot; title=&quot;查看IP&quot;&gt;&lt;/a&gt;查看IP&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$curl ip.gs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ifconfig&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Git使用心得</title>
    <link href="http://yoursite.com/2018/10/18/git%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2018/10/18/git使用心得/</id>
    <published>2018-10-18T04:17:12.576Z</published>
    <updated>2018-11-14T07:25:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-具体"><a href="#1-具体" class="headerlink" title="1. 具体"></a>1. 具体</h3><p>1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>将某个文件从暂存区拿出来。</p><p>2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset -soft/--mix/--hard &lt;commite id&gt;</span><br></pre></td></tr></table></figure></p><p>会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有git的提交记录，包括详细commite id</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2-git-add语法"><a href="#2-git-add语法" class="headerlink" title="2. git add语法"></a>2. git add语法</h3><table><thead><tr><th style="text-align:left">语法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">git add -A</td><td>stages All</td></tr><tr><td style="text-align:left">git add .</td><td>stages new and modified, without deleted</td></tr><tr><td style="text-align:left">git add -u</td><td>stages modified and deleted, without new</td></tr></tbody></table><h3 id="3-git-merge合并"><a href="#3-git-merge合并" class="headerlink" title="3. git merge合并"></a>3. git merge合并</h3><p>现在最简单的merge模式就是fast-farward merge了，就是从master拉出的分支develop后，master没有再做任何修改，所有的代码都在develop分支上提交，等到最后要合并develop到master上时，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换到Master分支</span><br><span class="line">git checkout master</span><br><span class="line"># 对Develop分支进行合并</span><br><span class="line">git merge --no-ff develop</span><br></pre></td></tr></table></figure><h3 id="4-git-tag打标签"><a href="#4-git-tag打标签" class="headerlink" title="4. git tag打标签"></a>4. git tag打标签</h3><p>标签可以针对某一时间点的版本做标记，常用于版本发布。</p><p>1.列出标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在控制台打印出当前仓库的所有标签</span><br><span class="line">git tag</span><br><span class="line"># 搜索符合模式的标签</span><br><span class="line">git tag -l ‘v0.1.*’</span><br></pre></td></tr></table></figure><p>2.打标签</p><p>git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建轻量标签</span><br><span class="line">git tag v0.1.2-light</span><br><span class="line"># 创建附注标签</span><br><span class="line">git tag -a v0.1.2 -m &quot;0.1.2版本&quot;</span><br><span class="line"># 针对某个提交打标签</span><br><span class="line">git tag v1.0 &lt;commite id&gt;</span><br></pre></td></tr></table></figure><p>3.切换标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.1.2</span><br></pre></td></tr></table></figure><p>4.删除标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除本地标签</span><br><span class="line">git tag -d v0.1.2</span><br><span class="line"># 删除远程标签</span><br><span class="line">git push origin --delete tag v1.0</span><br></pre></td></tr></table></figure><p>5.标签发布</p><p>通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将v0.1.2标签提交到git服务器</span><br><span class="line">git push origin v0.1.2</span><br><span class="line"># 将本地所有标签一次性提交到git服务器</span><br><span class="line">git push origin –tags</span><br></pre></td></tr></table></figure><h3 id="5-git-stash"><a href="#5-git-stash" class="headerlink" title="5. git stash"></a>5. git stash</h3><p>该命令用来保存当前分支上还没commite的修改，使当前分支保持clean状态（git status）</p><p><code>使用场景:</code>执行git stash后，你在dev分支没有提交的修改暂时被“藏”了起来，看起来dev分支是干净的。但是，请一定注意，你还在dev分支！因为你需要切换到master分支去修改bug，因此此时需要切换到master分支（如果不执行git stash就切换到master分支是不行的：git会报告当前dev分支还存在未提交的修改，比如先提交才允许你切换分支，而出于各种原因，你还不能现在提交dev分支的内容（一般也就先提交了，大不了再切回来改就是哦），这就是git stash存在的价值）。</p><p>切换到stash分支后的恢复命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 恢复并删除stash内容</span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"># 查看现场</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 保存现场</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure></p><h3 id="6-git分支管理"><a href="#6-git分支管理" class="headerlink" title="6. git分支管理"></a>6. git分支管理</h3><ol><li><code>master</code>:主分支，当前分支上的代码随时可以直接发布，并且只能通过Pull Request从其他分支进行合并，而不能直接push修改。当开发告一段落，产生了新的可供发布的代码时，master分支通过Pull Request更新了代码，同时，每一次更新必须添加对应版本号的标签TAG。</li><li><code>develop</code>:开发分支，保存当前最新开发成果的分支，即当一个新功能开发完毕需要先合并到develop分支，这个分支的代码会进行每日的代码持续集成(Daily Build)。所有的开发任务都是从这个分支Checkout新的特性分支进行开发。</li><li><code>feature</code>:特性分支，当开发新的功能时，从develop分支Checkout新的feature分支，这个分支的代码最终要合并回develop分支或者废弃掉(例如预研功能效果不好时)。feature分支最好以功能为单位。</li><li><p><code>hotfix</code>:紧急修复分支，唯一从master分支派生的分支，当生产环境中发现了异常或者缺陷的时候，从master分支上指定的TAG版本Checkout hotfix分支进行紧急修复工作，当修复完成之后，必须同时合并到master分支和develop分支。合并完代码之后删除hotfix分支。</p></li><li><p>新建分支(已feature为例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换本地分支到develop分支</span><br><span class="line">git checkout develop</span><br><span class="line"># 拉取远程Git仓库中的最新的develop分支的代码</span><br><span class="line">git pull</span><br><span class="line"># 创建本地特性分支feature</span><br><span class="line">git checkout -b feature</span><br><span class="line"># 推送本地特性分支到远程Git仓库（即创建远程特性分支），-u为追踪远程分支</span><br><span class="line">git push -u origin feature</span><br></pre></td></tr></table></figure></li><li><p>已feature分支为例开发合并全流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开发代码。以下两步的作用是保证你本地的feature分支的代码为最新，因为有可能你是和别人合作开发的该功能，如果你刚更新过或者你是一个人在开发则可以省略此操作</span><br><span class="line"># 切换到本地feature分支</span><br><span class="line">git checkout feature</span><br><span class="line"># 拉取远程分支代码，--rebase最好加上</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 合并代码</span><br><span class="line"># 切换到本地develop分支</span><br><span class="line">git checkout develop</span><br><span class="line"># 拉取最新的远程origin/develop分支代码，因为可能已经有人提交了代码</span><br><span class="line">git pull --rebase</span><br><span class="line"># 从本地feature-login分支合并代码，--no-ff为禁止fast-farward模式</span><br><span class="line">git merge --no-ff feature-login</span><br><span class="line"># 推送到远程分支</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 代码已经合并完，可以删除本地特性分支和远程特性分支</span><br><span class="line"># 删除本地feature-login特性分支</span><br><span class="line">git branch -d feature-login</span><br><span class="line"># 删除远程origin/feature-login特性分支（废除，实验无效）</span><br><span class="line">git branch -r -d origin/feature-login</span><br><span class="line">#在v1.7.0 之后，可以使用这种语法删除远程分支(同删除标签tag类似)</span><br><span class="line">git push origin --delete &lt;branch name&gt;</span><br></pre></td></tr></table></figure><h3 id="7-git-push"><a href="#7-git-push" class="headerlink" title="7.git push"></a>7.git push</h3><p>push到远程分支有https和ssh两种方式，https每次push都会要求输入用户名和密码，而ssh只要在远端注册了ssh key则不需要。<br>另外，ssh可以上传大文件，https貌似不行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这个会把本地当前分支的内容push到远端的demo分支，如果远端没有该分支则自动创建</span><br><span class="line">git push -u origin demo</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成ssh key,该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</span><br><span class="line">ssh-keygen</span><br><span class="line"># 可以查看远程分支情况</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h3 id="8-git-reset"><a href="#8-git-reset" class="headerlink" title="8.git reset"></a>8.git reset</h3><p>第一小节有类似操作。</p><ol><li>本地代码回滚</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 回滚到commit-id，讲commit-id之后提交的commit都去除</span><br><span class="line">git reset --hard commit-id</span><br><span class="line"># 将最近3次的提交回滚</span><br><span class="line">git reset --hard HEAD~3</span><br></pre></td></tr></table></figure><ol start="2"><li>远程代码回滚。应用场景：app已经发布了，发现有问题需要回滚到某个commit，再重新发布。这时需要先将本地分支退回到某个commit，删除远程分支，再重新push本地分支。操作步骤（还没检验）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">git checkout the_branch</span><br><span class="line"># 2</span><br><span class="line">git pull</span><br><span class="line"># 3 备份一下这个分支当前的情况(本地新建分支？)</span><br><span class="line">git branch the_branch_backup</span><br><span class="line"># 4 把the_branch本地回滚到the_commit_id</span><br><span class="line">git reset --hard the_commit_id</span><br><span class="line"># 5 删除远程 the_branch（可以删除远程分支）</span><br><span class="line">git push origin :the_branch</span><br><span class="line"># 6 用回滚后的本地分支重新建立远程分支</span><br><span class="line">git push origin the_branch</span><br><span class="line"># 7 如果前面都成功了，删除这个备份分支</span><br><span class="line">git push origin :the_branch_backup</span><br></pre></td></tr></table></figure><h3 id="9-git-remote"><a href="#9-git-remote" class="headerlink" title="9.git remote"></a>9.git remote</h3><p>多源操作，一般是一个源，但是多源也很有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如果想关联另一个远端仓库（加一个源）</span><br><span class="line">git remote add &lt;origin name&gt; git@gitlab.com:demo/demo.git</span><br><span class="line"></span><br><span class="line"># 显示全部源</span><br><span class="line">git remote / git remote -v</span><br><span class="line"></span><br><span class="line"># rename</span><br><span class="line">git remote rename &lt;origin name&gt; &lt;origin new name&gt;</span><br><span class="line"></span><br><span class="line"># deleted</span><br><span class="line">git remote rm &lt;origin name&gt;</span><br><span class="line"></span><br><span class="line"># 查看指定源的全部信息</span><br><span class="line">git remote show &lt;origin name&gt;</span><br><span class="line"></span><br><span class="line"># 修改远程仓库地址</span><br><span class="line">git remote set-url origin &lt;origin url&gt;</span><br></pre></td></tr></table></figure></p><h3 id="10-git-commit"><a href="#10-git-commit" class="headerlink" title="10.git commit"></a>10.git commit</h3><p>合并某个分支上的某个commit或者多个commit到master分支上<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd2e86 - <span class="number">946992</span> -<span class="number">9143</span>a9 - a6fd86 - <span class="number">5</span>a6057 [master]</span><br><span class="line">           \</span><br><span class="line">            <span class="number">76</span>cada - <span class="number">62</span>ecb3 - b886a0 [feature]</span><br></pre></td></tr></table></figure></p><ol><li>比如，feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">git checkout master</span><br><span class="line">git cherry-pick 62ecb3</span><br></pre></td></tr></table></figure><ol start="2"><li>在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。(未实验，要实验一下)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：</span><br><span class="line">git checkout -bnewbranch 62ecb3</span><br><span class="line"># 然后，rebase这个新分支的commit到master（--ontomaster）。76cada^ 指明你想从哪个特定的commit开始。</span><br><span class="line">git rebase --ontomaster 76cada^</span><br></pre></td></tr></table></figure><h3 id="11-git-rebase"><a href="#11-git-rebase" class="headerlink" title="11.git rebase"></a>11.git rebase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.git detached HEAD</span><br><span class="line">在一些情况下，会出现detached HEAD的情况，（后面分析下原因）。detached head即游离的HEAD，HEAD指向了未知的分支，即不在所有已知的分支范围内。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">$ git branch</span><br><span class="line">* (HEAD detached at origin/master)</span><br><span class="line">  dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>  HEAD指向了一个未知的分支，可用git checkout -b基于当前分支创建一个新的临时分支保留代码，合并到合适的分支后删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b temp</span><br><span class="line">Switched to a new branch &apos;temp&apos;</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">  master</span><br><span class="line">* temp</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">$ git merge temp</span><br><span class="line">Already up-to-date.</span><br><span class="line">$ git branch -d temp</span><br><span class="line">Deleted branch temp (was 3e74a7a).</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-具体&quot;&gt;&lt;a href=&quot;#1-具体&quot; class=&quot;headerlink&quot; title=&quot;1. 具体&quot;&gt;&lt;/a&gt;1. 具体&lt;/h3&gt;&lt;p&gt;1.使用git add .添加了所有修改文件到暂存区之后在commite到本地之前想撤销add操作可以使用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将某个文件从暂存区拿出来。&lt;/p&gt;
&lt;p&gt;2.已经commite了提交到了本地但是还没有push到远端，这时候发现有个文件不能提交到远端可以使用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset -soft/--mix/--hard &amp;lt;commite id&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;会将本地仓库回退到commite id这个版本（可以是上一次commite的版本）。reset后的参数代表了是否保留本地代码的修改，具体可以查询网络。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查询所有git的提交记录，包括详细commite id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reflog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/10/18/hello-world/"/>
    <id>http://yoursite.com/2018/10/18/hello-world/</id>
    <published>2018-10-18T02:10:52.296Z</published>
    <updated>2018-10-18T06:38:30.444Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
</feed>
