<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ervin</title>
  
  <subtitle>真正的强者是认清了生活的本质，并且去热爱他的人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-16T09:29:22.078Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ervin Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS事件循环</title>
    <link href="http://yoursite.com/2019/12/16/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2019/12/16/JS事件循环/</id>
    <published>2019-12-16T01:15:58.130Z</published>
    <updated>2019-12-16T09:29:22.078Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？</p><a id="more"></a><p>关于执行中的线程：</p><ul><li>主线程：也就是js引擎执行的线程，这个线程只有一个，页面渲染，函数处理都在这个主线程上执行。</li><li>工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取，网络请求灯异步事件。</li></ul><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yd9c7ijxj30u00vhgmp.jpg" alt></p><p>从上图我们可以看出，<strong>js主线程</strong>它是有一个执行栈的，所有的js代码都会在执行栈里运行，在执行代码过程中，如果遇到一些异步代码（比如setTimeout，ajax，promise.then以及用户点击等操作），那么浏览器就会将这些代码放到另一个线程（工作线程）中执行，在前端由浏览器底层执行，在node端由libuv执行，这个线程的执行不阻塞主线程的执行，主线程执行栈中剩余的代码。</p><p>当工作线程里的代码执行完成后（比如setTimeout时间都了，ajax请求的到了响应），该线程就会将它的回调函数放在任务队列中（又称为事件队列，消息队列）中等待执行，而当主线程执行完栈中的所有代码后，它会检查任务队列是否有任务要执行，如果有任务要执行的话，那么久将该任务放到执行任务栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。跟大部分框架的消息队列其实本质原理都是一样的。下面我们来具体分析这套机制的运行过程。</p><h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>那么，问题来了。如果任务队列中，有很多个任务的话，那么要先执行哪个任务呢？js是有两个任务队列的，一个叫做Macrotask Queue（Task Queue）大任务，一个叫Microtask Queue小任务。</p><p>Macrotask常见的任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>用户交互操作，UI渲染</li></ul><p>Micraotask常见任务：</p><ul><li><strong>Promise</strong></li><li>process.nextTick(nodejs)</li><li>Object.observe（不推荐使用)</li></ul><p><strong>重点来了</strong><br>事件循环执行流程如下：<br>主线程在执行主流程</p><ol><li>检查Macrotask队列是否为空，若不为空，则进行下一步，若为空，则跳到第3步；</li><li>从Macrotask队列中取队首（在队列时间最长）的任务进去执行栈中执行，执行完后进入下一步；</li><li>检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到第一步（开始新的事件循环）；</li><li>从Microtask队列中取队首（在队列中时间最长）的任务进去事件队列执行，执行完后，跳到第3步中，<strong>在执行过程中新增的microtask任务会在当前事件循环周期内执行，而新增的macrotask任务只能等到下一个事件循环才能执行。</strong></li></ol><p>来看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//settimeout1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//setinterval1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//settimeout2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//promise1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">12</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">13</span>)</span><br><span class="line">    clearInterval(intervalId)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><blockquote><p>1,9,7,8,2,3,10,11,12,13</p></blockquote><p><strong>运行结果分析</strong></p><ul><li><p>第一次事件循环： </p><ol><li>console.log(1)被执行，输出1</li><li>settimeout1执行，加入macrotask队列</li><li>setinterval2执行，加入macrotask队列</li><li>settimeout2执行，加入macrotask队列</li><li>promise2执行，它的两个then函数加入microtask队列</li><li>console.log(9)执行，输出9</li><li>根据事件循环定义，接下来会执行新增的microtask任务，（上面标记的：在执行过程中新增的microtask任务会在当前事件循环周期内执行），按照进入队列的顺序，执行console.log(7)和console.log(8),输出7和8，microtask队列为空，回到第1步，进入下一个事件循环，此时macrotask队列为：settimeout1，setinterval1,settimeout2。</li></ol></li><li><p>第二次事件循环：<br>  从macrotask队列里面取出队首元素：settimeout1并执行，输出2，microtask队列为空，回到第1步，进行下一个事件循环，此时macrotask队列为：setinterval1，settimeout2。</p></li><li><p>第三次事件循环：<br>  从macrotask队列里取位于队首元素：setiverval1并执行，输出3，然后又将新生成的setinterval1（间隔生产）加入macrotask队列，mincrotask队列为空，回道第1步，进入下一个事件循环，此时macrotask队列为：settimeout2，setinterval1。</p></li><li><p>第四次事件循环<br>  从macrotask对列中取出队首元素：settimeout2并执行，输出10，并且执行new promise内的函数（new promise内的函数式同步操作，并不是异步操作），输出11，并且将它的两个then函数加入到microtask队列中，再从microtask队列中（当前事件循环周期内执行）取队首的任务执行，直到队列为空。因此，两个新增的microtask任务按照顺序执行，输出12和13，并且将setinterval1清空（不会再产生setiterval1的事件）。</p></li><li><p>结束<br>  此时，mac和mic队列都为空，浏览器会一直检查队列是否为空，等待新的任务加入队列。在第一次循环中，<strong>为什么不是macrotask先执行呢</strong>？因为按照流程的话，不是应该先检查macrotask队列是否为空，再检查microtask队列吗。<br>  原因：<strong>因为一开始js主线程中跑的任务就是macrotask任务</strong>，而根据事件循环流程，一次事件循环只会执行一个macrotask任务，因此，执行完主线程的代码后，它就去从microtask队列中取首任务来执行了。</p></li></ul><blockquote><p>注意：由于在执行microtask任务的时候，只有当microtask队列为空的时候，它才会进入下一个事件循环，因此，如果它源源不断地产生新的microtask任务，就会导致主线程一直在执行microtask任务，而没有办法执行macrotask任务，这样我们就无法进行UI渲染/IO操作/ajax请求了，因此，我们应该避免这种情况发生，在nodejs中process.necttick就可以设置最大的调用次数，以此来防止阻塞主线程。</p></blockquote><h1 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题"></a>定时器问题</h1><p>由上，我们来引入一个新的问题，定时器的问题。定时器是否真实可靠呢？比如我执行一个命令：settimeout（task,100）,他是否就能准确的在100ms后执行呢，如果知道上面运行机制就知道答案是否定的。</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Ran after "</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds() - s) + <span class="string">" seconds"</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds() - s &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Good, looped for 2 seconds"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主线程跑了2s后才结束while循环，这才去执行macrotask中的settimeout回调任务。其实，你执行setTimeout（task,100）后只是确保这个任务会在100ms进入macrotask队列，但并不意味着他能立刻运行，可能当前主线程正在进行一个耗时的操作，也可能目前microtask队列有很多个任务，所以用setTimeout作为倒计时其实不会保证准确。</p><h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><p>关于 js 阻塞还是非阻塞的问题，我觉得可以这么理解，不够在这之前，我们先理解下同步、异步、阻塞还是非阻塞的解释，在网上看到一段描述的非常好，引用下：</p><blockquote><p>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。<br>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。（轮询）<br>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗最蠢）<br>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</p></blockquote><p><a href="https://www.zcfy.cc/article/node-js-at-scale-understanding-the-node-js-event-loop-risingstack-1652.html" target="_blank" rel="noopener">理解 Node.js 事件循环</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看js事件循环，事件循环是js运行的核心，js是单线程的，js的异步事件就是依赖于事件循环机制，这里进行总结一下。&lt;/p&gt;
&lt;h1 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h1&gt;&lt;p&gt;首先，我们来解释下事件循环是什么东西：就我们所知道的，浏览器的js是单线程的，也就是说，在同一时刻，最多有且只有一个代码段在执行，可是浏览器又能很好的处理异步请求，这是为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（三）</title>
    <link href="http://yoursite.com/2019/07/18/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/18/日本游记（三）/</id>
    <published>2019-07-17T23:14:30.856Z</published>
    <updated>2019-07-26T15:19:30.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行程（2019-06-03）"><a href="#行程（2019-06-03）" class="headerlink" title="行程（2019-06-03）"></a>行程（2019-06-03）</h1><h2 id="京都"><a href="#京都" class="headerlink" title="京都"></a>京都</h2><p>行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下：</p><p><img src="https://lh3.googleusercontent.com/BHMX3bN7AhJEWmFzL4FAxc1Y8L-oci5khvjwNN3TzPQI6gaGDcNvCo8bqhDRL4cXagfrSUtR55sgbu2gHQXqDBVOngGcBYBiuFaAKgW5IWM3vhrE3xVw3UUw4Fur66KFkcWH5F4zsVfOpmu6QbzFwb1rt9Srr2U8ssojJI6Hzu5M4oTHfqUskJmSMg-3EDFTxK_sUZHvaHn19Ot5mqNRddF1cs-R0YCcuXAzT_CPm4uKc8nJUWPwPqU0mJCexkWNZSdQXhvzuy2Bl1X2VSAsHniWJmaEdgjjqyEyBMr6yObu_hTm13uNVLLMWmnsbMnz56qR8L4ubykpZSKVmmEciM4JujPQB1LCI1dsSpaXrmqlU0JSyjQWQCg9QCVcTFsdx6SNVCI1tvn3gUGmThGTflFmEE9_mxAwfQ85o82QmaVIQlnz8aKAEApGsIKMEYO3y2Tn1OUn6YRKCq5cvG67Kq97W4JOLyTsDwWeJVojTHrMA0tw81DEqfyEl9yA2c7X2PWK8VqhEv9hnOLyKxrUJdZpge3GJ3--01TnqmYZqHjHTjS_9hkHfxVrrDWYzIWwEI610OxrABLj5PPsGgmS0k1w4zZ_VSC7TI1Cirwt-y82zkTLfNGlIzwBB2MQwx-WHxZpEJOdj7mOUyLKAYbjSLEQWhjDhR8T=w1082-h1442-no" alt></p><a id="more"></a><p>这里竖着的带有颜色的竖条代表了各种线路（普通/快速/特快），横着的表示这条线路会停靠的站名。<br>我们坐地铁从九盯木到淡路，然后坐阪急线到乌丸。这里还是要感叹一下，日本的地铁很准时，所以你要上对车，GoogleMap也是利器，标明了每一趟车的到站时间，分秒不差。经过大概1个多小时的车程终于到Kyoto了。</p><p><img src="https://lh3.googleusercontent.com/uytr9kgOuCkAQOG9jcZ7GdomW4q0uwX507T8XpW-4IH9D5NQKHPLgJ8aLOAWtt81BUlsq13uX9kRkU994D_Q1rd_q9wI_psimJP0vM4ko-29bXYzrZAKpMb_qxqfpGF6ulPPKGRl7b7PDLfMGzo6p3YfJ5JOTaXN1VF5P2HX-qU33ezLeWiOn32kwL_1L2sq_JPTTwzjkzqW8JYUQb3X78-4ERS2Fs29205VpzSxvy0_bCmMIrajiKCWXuA-lTC08VfFFsyiP37YonV6pYccyGF1mB6TgGB6GaT8AB8__W2cMroObJpzLXTDJyoAll5tPRLqqSB5n3cu4t3C76wnUXZwt86Jp2wLqYsYeJ9bvdVpQ8GgKN3Od73W6xocTmq_uyKUp8NLitEEUTFg_YB9HStDY0yD7OcxpkqetUsobv3DEW0NzTOTCr3Nrah9lFHmvd1AHG0_XZUIIFTJLQg5xp0K7M8J-GMcOcEZldG97T44Yars1E1f5DHWXfdKarcNOwXJjUSewUUJon8MnlrZtM6occfcjQCDXIy5fB4p_g9Kw3F7JRKavbMGvkJDYNtQ-DrRJ3m3R6AUpM_KmnqokPGbPtehAS8I20Dp8oZUoNhwBStkZ_SLbGkktoqy77pRwwQwfaVRtYgUSrpGzPJyBTVJS4vW6gLt=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/IhiCrbpCcGPHTScgpknrgUy6uaHhXssCvjtVIi0XTTRdH4vbL_BGQ_XeVJMSJhxxaDA5-IzyTEEQNumPU4jxlxBlQ1mu-5E7Glr_l2Lov0yF8kwfupAAu5LyBEjKMlXftV-PDcvKFc3KTNmMmtU9kD6z0vdaa2ZwaO_XjhaZ7nth1ei4OxxPr0c1pleT1nTTZeAc_gS9enywLkK3frI7G8DvoHRi5S6al3qHTCUVS6Cg3pduW65CuU1lPsolMepIsIQUz_wdara0rmm_6gMVSRNhj19hl_EoAOsVJhYYD-UfrBtgxGPrDUZ2naRQQur6lnPhkeS_U6jWmEixWfe-FQVlW2MluN_DtWDSeow0slf7BV3QovTZGJycAiCWbukD66keXuYo2nWlEUiazu1hclVQWGzNJxgPdmSHbbvAUB8DWJ-cUobtBHvkyckMK4Ipez-j9AyG77bgzC0xoQn7a5XmQUH5cD6fRvN8tFmtDhvKZmfyTufDmut8I3v72tm06aS2FlZrcn4fif_FOXWRJpLp2L-bB2AoNlg5uJfvDHcDxLJ5mQuizdf0BaoUNAwgp3MxZKuFT7cNDmyAD_VAbgAyUTn2L_QMIzEVYAKqvVZAZTMMO8_dohoB_Nbsqsd46J6xGQQqk1Cc30d1LUTZdPf0dIJ1O7DN=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/TJstyC14yu61H7q05mjbkIZjZBqqXbFRwUajeAFw6yu4QAsP5rU05896Yv9Wo0nxQWNvH-43PcK7jCpRw321Hp9RBX_xF2tONf81M1CsIONTeKlw3OWkcxjyFsLmi6R_VehKLNOmzTVmoqtoj2Rky1XU6AGko1_ETQ7OjOZD3kkmrYL3S3IW4X-Ou2hSYoyGvI8b4FI4amu4Ahbm4IizmOKx0inEtW_2oqyuFFmfrIlEDMv0FLyZB8kAX9RXdKtzM91IpWRGadTBqRw6Ohk2H0-XuCOWYlAOevzjx5k4UxeMT9EMwlMbEJdBcnj-jbYIBYBkmiPdEyRDvrVq1slwM_m-VpcqhY4s3722uRWudjWystATWBjifbAoW9yvvxiRQyH-E_DFWWvevWubtX-XZKhQwx-EASMvTKhkurpxq-z3FJ7hpiBXnRlRnIYV9DeGFiMFcCnEmdkm5GafX91o0MeHjqDdGwnv6Jx1qdSnIR2MQHQ2KWGAJXkVZ4SykCKH4lIjqmZsWLE57x0OqWYyWNuxxbjk-sJWuVdHPiAT0r7aC7NzukQRXTiwG11o-uIy_JwvmVMJbxbksJ-4P0Puk8CSxFGEfj4kFS5I3sounTC_N5bsOuQuUqwCusI5o3uvSm6goyxxIz--HZtN8hwzzKedMUoaBygi=w1082-h1442-no" alt></p><p>京都给人的感觉更像是大城市，大阪是一种生活的城市。</p><p><img src="https://lh3.googleusercontent.com/9DWtI7aj0sOY1mqh53MqGKnXboTjLT_qc_YmnLvawRN9bkfpxvXv1XwFuFlqFQyW_Igthki1uqvBsum3TFqnKc3eLXHAzvY2exZ0bGIil6vAd3xlsnsO4i_rJoRDTli2vG2wY4iotdlzqYNpkPFAt6-8lFZ6rVHCNGV8qGFqXhmXk2isI-bkXHv5cSPCtqbObvPFJHJ3nqks5MJRs50aP09YB9AqYZ_zYojmEvp05Jt5bL5v0VzlIqBNccOd9ax4oDdn_C4nsysooAxdax0tj4dwe743RjR7bO6BIuzWln1u6Zt0J62CvgnPdTVdXIlCmtPcETelv5Js2O56grIxwKdOKZrLenfYoTCw4cbjbNSYv33ZeovWMvv9-SLeoDvj-CwHeXToaChYKKVh4ETs1bZT0So6kEwuRihDjczRo0Pv6IJtfYJSdw4mGvUt2JqFKCWwQE7uUOPvq4MeGzvk7Jl3FxP2fouzgsC5ZUfIhJfoWdPW81QdP_1W1STEXrIb8t5ppc_PiutfkXnQ4tju_U3NiGFotoCPd8yfO9yH2iOw8QYWKW7DzmoG6ZPLcblj1hacbH2AglgrzWUu2IlNC4bDd8e_eBiW2rnBzXESaGLrB-qRorufqaYPgB9r6HFTAdaauXzcwCje75Rx8fDrlhjfD5OkcrKg=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/glJrNFabUM2i5CxkvJKECnF8YZGZKOE6MKuzpsZ1PlfYacPyU09mJrjuMwUHkz_9EsTljqEtdDXM2C-PB4FYkUWqc_LNkL2J4HHtHUESDvPUVPcksB-wbGVjdZt7-PtaIQ2FemG_18ZBuI5iFPpWLSkGMRHmCCw2cMqL884_T8tAVgjP5aQ7YORC2nALkqMlfvyly3tSgFyjMWMCrPfjvFIcUkx8IwW7ACjcKvJbTFMuLIcGxX9H1H_aNkujsaPdQH3Bq8D-wfHGqrK0aSStxu-GSqC2HhKPU6RElhnrpDBWumSCqnLCkJBwZAF92aihvzSDi67icPcI3Qd332kZHQ1zKxslH4LeP2JsZ9Sc7kW0OZ1HSrrJnM1tJJuPhD2f7ANxNNtPP_xC95IZWgdDTUNsApuPYwszPYtvGFkchDK3DD_GBpbjGsKjcY8ODif-a2zWJHIVbK63z7sMMcpIwOGc_M8V-tAyCYHUWtrU-Bs6ZE4rI-AYfoHLn3W_5oLlUIzFQwa5jVqCk9kWus6zpU_k96SwwB8eW0eZvwxOkFArU9gdAJwJQLAEfd1Mby50SjC4zb9OxvEfj2AncVJJRaaI96RXew4RstFrjZ4KJvAiyv64P5O4YH161lQf3ByZeTFR-L3nRvUYttfia_V3QtDvlXDErpSb=w1924-h1442-no" alt></p><h2 id="清水寺"><a href="#清水寺" class="headerlink" title="清水寺"></a>清水寺</h2><p>来了京都，checkin酒店后，就抓紧时间去附近景点了，防止后面没有时间，选定了不远的清水寺，出发！日本的公交车很贴心（对残障人士），靠站后，整个上车一侧的车身会倾斜下来靠近地面，大家跟容易上车（老年人），而且日本的公交车是前门下车，后门上车的（我觉得很合理）。</p><p><img src="https://lh3.googleusercontent.com/G4MlLHBGbe26ye2Loq_b5S715b3BZchkS4SCuua-WZaPBTlMqUGvVZjeTeH4eEJ7P5NaUN34QXy_z6Imx_BMtoXMIEYV1XlEmjyaJP4PKDduSA08isMQp02DiyXKQDNj6FCdoM_90ES1fjDYVAaXpX30diTj1WKVp0-Qz8RvNF7dgTn6LKo4pdUjWPw4Rl7F5Y1Dh3jdUXaLNgtXArohLDjCVChrqIMIL22cQnKp5JYoLu-P_1_lNVU62IRd3kuFiZ6Rze_8WKxC1HKW902R6JvF0Sk2e3zKi_lML9QExjBeDrcQO6mPvBFTeCRRB8eWjjkN1FKV79S2KJfoaaco-UMDEj3oyjPFQU6FG9BvNWiDmMnV5KnU0-ta8X3WYFSUHMw0CQswaQE6gGYtkg7aejot6UBDSPjhKJAZU3h0IehB74yLjGoWwq-wzzsqnvFaJkHduoor9fIw8p6_pcsyb_zfHlUw534UKHR7_BL1XtRMY7FwLJ7o5BLKJ4FU-Ku9lj83iW56yQHIrlAD9uKJi5xz3E67Ue3EIfxsmWSnF1nxKqyvDV8cfEjld4IpSdulQMN4fzBMAGk8XQwJHG6oCTRo_BAanJT37_5AnFTK-sdioM2VvXgNWk4qec11fCYLzSC3oS3syt7KWnWhz9iqOfnsROFM7Yb4=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/yziGHtcpKxSYgiFtlOXiQwYtHpXQgu39iAQ7i6n4EzvHNn_x_ddV832WlH6XGvv7AzlPiYuM-M4R6C_jaRazDT_hRZ4ve_GRcjiVzjuGMILhPPGvZq7j_F6px-sFDkNRvXc9nRvk0YiPoKGpy_yRFfifXEbIKxLe_8aoRSGmwVq9ZRDDfvxTkiup6TTeK-4GNNVmyUCk1zgEax9tr4hExGjVOsoWBoYbKOFEwrCPq6aeAQyp6N8610NrC8Ycl44zucLjSMYNCxLfr0cTEdMfUYThhOrdErKgZHgttsAWmOFe8EBfgwKlVECO2WfmRswiL9GYYgh8-5Y2mKi7rnuxcgESrPNK5aypbTgjlFo4N9IerRVWeyytTOdqf6419EqxAOquJ4jUuOVrqmQvWhL9zG6bMZaFc7PDgEpnEy0plDRmMNyGWS7DoBEJjD_hCv-pTiFQGoI5ZVy05F5a5GWn-bJKhcW_RWSn88jXMXCG-LlhtflkKugDkBeExmj5IPhdpkelAAfAN6wrV6DetzkAe9sm4g-OyRvTPwuv2Zm6qf-fLJeftqaKAf4ucIvL3iL6r7yAqnMLStOGYrk_YLZattyo56tD51t2Esm9nWlJ65QLkC7t7SuIXHKLPHr0AZGbKMvyAWxt_vy92oBBrYWjAKGA70rk13CD=w1082-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/NZ3mByMUZR0dlar2XUgrBSJ_OtPR-3yBJVKJJSix888bf2pKAJ9C9wadQFeAjvfqw-LN0vQ7npUfPOU8D_7qar4p55xhBY9AWT3zX3NVhXb5bdzrTVVATcIRJL1ykrW6bd0nEXmiAtWGGtZaeVlXMlvc7r7kxp27WEKxETPy0nN7R-6qpQghhrT2Jnf1tZoTPAUPe6jBT83Il4nqR1jFQaltQqOdRAQklw50ETse0unlFeZkJ4020i8x3qWDy5R858Pgvop3yXjZMX3PThhZv1UMndHQfJ4yI-7Hq9aVnuc6FD2imou1G5FGwp4ysvH-wSEiQ1JiYhNAf0iR15zUvrLrxnBviDwrf9-Ltx2RBARXrpVxvJsnvvUTNZL2hAyM1U2BVo4nhAwLzrH4u9vS4H3hYAWvi6r-llphqj-4PDTC-NRytSuWRGe0s_yHUmflr10DbqXqTNXswH8pj_f7HMucMJma-_XWTY0EZQ18v4syJHGoQg5mmb-q0dcVo9gP8axdhdrNaD09wDxL1qL7k9y1Hh99JpHHRWRh9p6G-ltPandfW6Mi2abtQMnLm-QguJLRI3dhvJs2kcGZYPFkHW0mY9eHg1HdKIuWWgU0Lw6SwPq6xLWS3wS06kzyHjWJG8bE3Xax4v-WIrh0OXmS4E5qjScpclLA=w1082-h1442-no" alt></p><p>游客众多，天气也比较热，但是新鲜感让一切都变得那么美好</p><p><img src="https://lh3.googleusercontent.com/CFIH1lM56hivagAjDvZdEFMBmrFDk-3BA9fNpmpmTcMMppo3AHI2_OLHGqwUWF8zZZ5A4GUBCLNLbTs4Lo-eU1cyVST507oMAboN8IuMmzM2HKI5PKuKG-oqhsS2vhGUQZ7HJTpbk10Z74MG_j3Dv267vfTaPtX0pT-FsRPEOCKXO73Iz6CR_aZpeQL8tUj4iuT3BOeaYw0HM_k2s0PPKulcx-sPgXSEIrvMazTHjAZEKX8C5KheRezCZNvF_VK5WCDyYK9TuO9OM2hhABtFDSPAyahbIkgj6eQ_vJiB7NnpE3pB2Fh5n_Nwta93bOwQVRFq0SLUldv6tNz27PEv4bzKNjxgpvEOCVznRKVnEh5ALWEVkhTYiXDDtOXE2OhfnEGn-KelgFn1gambw-QtUZ-wSvdf6bI0c_bjDt3tKUOu8Brzwr59CT9ID9eYokoSmXJ1-LmhwLHAsd8pztA6X-R3e-hlOI6qWSXx5meS4lAJXn3RqKPMtNZ89t_IMORMT-F1pR_LV4Cu3C2PuC7eVS635bzm2eVOILGVhsmYXOGh20BK82sePt13ntqxI7EzheXmhZ57ffMRoZniATIlgZXbVbihNfwRa9R3SXuc5TT0mxNYmpWJMgx4vW5B35vnmaWGnljYlo7MD-NKnAxaEXTUk3ibbMSU=w1924-h1442-no" alt></p><p>正门，其实日本的各种神社，就是类似中国的寺庙<br><img src="https://lh3.googleusercontent.com/PLf91ZQTz9pM0jTHm91bnHjArBjjuzDSHZ1LrMPeDwSc4GuHXNk6c9wrO1_GKWFR4km3Ky55LM2x2dFjTspbNmE22SFhqSmvND_Wa34Ouy3glLscPEt1OawwmgDPryJydqOsnIIHcN-yV46Pg3y6A76mI6C5K32iTlK0iidAOd4gi8vmyvZDsbG032HSO-ofLdkTpZcsv2I_xbXJ024ffcTTT0uVY7nP9X5Mubx1QcGdB-4JxU0vZ6tw6AyMDHcZ6s91hcFxW-KvrAn_HY20MVBkek07QmhtxPVggmGi1KRrwtiAzkWoOoLiQyMLJB86SBgUQIGsuoy0ObWcDe4r3DIffqKvt_L_SpvRp6igxYcr2P6RsxONCPyjZC6VgmmtnAkoWqjvLtnZ8jPUkHOjRRLoKNzGEVOkWY_c-rssJcCLtTv5G_vpOFN5HTp_hAzCbj7rkb95zu6R6qRjNT8nFLACZDwCY_ywW1iH9m_00DHZvYcK5ryKjpLDMSZ4j-1FfZ_ieC-cbUygolz3tsLFPbuvkAL9wTKPMj8LJhjx_NnjbpvZCLMNQ1N7lT185Onvh_pPLAVayNcpK8YeVatv0i6gPOhFBMVipZYCvr9KjbwfLRWoGWkv5vEo1WHYU9UiSrjIN4hVhmiPQQegARVQ5tgly1z42p0F=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/L5B8BSoPN6JrATEPuAQwKVj3rs4E9E8GINWKLgjwGhAPI1wUWGYU9lps1usNYK1B7CaNMBDWzwTavUd0ua7yJef2luZX7AagVpVRmSZra2EZihkK73unEesneTA8jAzKXOxFW9z_0t6Dl1P02kxfgOBqnDDrXnJMOBrt_2SPZEhZXA-rcpNWFGlUyUFWgwcYUeET62lQ0XfsowDVf7CV9uEShJDy6MoGtmQYqtsGHOF8J3PdxqTqxvpv496vCSejtzeXn22vq1fRObhkgi92hYZOcFjAFGhc68-VBn5E5_nrPeug0MOCJhD5n7qAQUU6gMFPcT_StTW0uq7CCPv_5kFsGzOxNg93AxdecERpktvTM4vfGAaIGQ99xp_b3U9jEbb94yaTAvNdbSgdorCdQgfqVAXEWhE9dGv-2qg56QxaSDxhAvuVt9bavYHdgs3ALpduK9ZDRAbOUv-UM3dlKkOngqEBjoTycgYYC6fe6kpzEj6ZrVZotQXZRprEu21-wuF0NbQiME8lf7XzPpX2y5MHnVmxPeCfT92mXXYpSl0nDZHDE989VqB9VLbSv4qvPa2SLvWPGdv_4k_KRUENGoqqBEJAxGd5mgDHWOCbNgvycnKpnJW7gPGnew3X-tiw_8Acppz8SmaK5RtBVYeNMapNyInSgvfi=w1924-h1442-no" alt></p><p><img src="https://lh3.googleusercontent.com/BdH8k7fBHz5RrCMqZ985Ax66zxK00O0xd8a_BPk3yfVM1Cr-qExRZ_bnnIQszj2tinSixXbozd_bg9O_pWRaPSoplvHH3HOfdpT3O9-0xvxGnbP3_11yyiVHFWkHdcvXZ0pPoNSyfa0zxKZr3nFwFDcmMMbK7bcWpVDWBNScANhV-a9l8-Epbna7Bwp7WL4i970WMi5EJhtLu7kUcItHUqT7O9Ridl0AoH3Cm45_TzVeqSrpLdh7N-DfDdfVDAGe8E88nwAwtmGI_AhsY78LEFTnQwFV-4dNbCa4IWsl_z7rS2oXNmhknnBwo-FdMczcdGSangwkz37yIUHgTBFokTYptcY_-3RxAgE2db7eZbnXN1KfNJOPOPJQR8Qgr0NAjTpGxIxIFJZ79LO6lAz0v-AKX4MQc4Zb-7ZlCd36eZr194ciTRt4y6RK1onb0BHnnGAcQPblqqikvaGDweYxLG3GyVmEpyVQ5-BSW2BxSoaKHZKd8fHyMr92NPKgfS198sf76yNz0CTrl7DXAo5RVynz-J9cosFvzFYYw_5dqVubdKS59NdWqo_Vkq7KMMKqTVV5ZXrACrXVFNl1HIUHggLTfhwWJ5DUF2uPkfQuL13K9p6IvifuPjC7LfCwJjnNfaS987zwJahPXsvOtSjuYQgBFH8_lPRk=w1082-h1442-no" alt></p><p>从清水寺回程，我们选择了步行，这个选择我觉得非常正确，可以沿路看到普通的日本人的生活方式和街道等，套用一朋友的话，走在日本的街道上就像是小时候看的日本漫画一样。感觉，整齐，有序。<br><img src="https://lh3.googleusercontent.com/T5VbSqQ6TVPMEqfvUkL3W0yZZ76lp9j1hHys-w8Bk_jLQNaYSQS_VZIZMhrGVGNDQYb09ehfL7R0O2Jil3wX8v6cmDvL--CuxLX9C9NlMn5k9QQBY_vsJz6JS6XZU9Fp8V9z9p4M6IPalGU-OF9FUAjd6c-06HAsON9FtXC4xFEp6wErXshtXVhmpdD9V4Nd-3ZdZpKnv3ojXKoyLE4cLXZB6-y3768g9oREqEqwTZti1ckg9nbugn17sWuCVgKtBR2XQb4FY-Z9qOIu37NMMjdPBgDyzgmBQJIg9F8jGjF42dDGGE75dD-GGrQsuiYxM-_3Qo36lw1ETuRTMp8cpP8GLmmhETQnNdpzIong7pN7VBKR7eShnQgOnVjpI39vALluD_rvLJqz1w2nlupaaauZw_9sg8pOYhJh1nDRaVd3snFBL5zKtmcO4s_1IgXzJBc9aKLXA30Lf3jdbFWzuxVIC_8O1aU8zdJxBvHGg5QnIVnR0RBy1CVsTrH0e78U-bYkjleeQTU0gXq_BIefBPj1iKEBbpwqXFmzYcI8hUdY4x0_kHL3dw8jbuxgjmf9hj0Ul5VX4zYkkC4Ycv4_SMdhnlfl_MFulHi1wJHv-faUTlVW0_OSEw_A_WAjxJQdVd5_5q4PDH9DZI_GVWsX62Yf45WUzso1=w1008-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/ZSWhTqD9y4TakMx_gNeDIEiYSaq7W_jKq_WqzlXqMxMsJxliDs3XrxiSNLEpmsNCYd2lsvTq6VdoymgwNVufgxMzFz4JH_gtRJxgSNdkZ9oGcaNSIOqUXpzf_A5PAu9522RkSrbiktZZptbWFMkrr_7wMLtiZDOoantdHei8mVo-ekjK1_-hxKUZ6UrtCNtrKEEgWwjIAsQn12H_-i0KSbn1eWd9d2-zf6z_P6cLP-XBsSuJ-_IP6RswHs9ml_-PxKG7IDgbU4eH8P-vyjNcOrDDYVfaCs438iwYZudv8vOATGcWRMfypxI8-chWcEI1MQiLqu2MND5-O6xgRLCP4d1WjW1mA0PW7J4D5m8ibUnh1x7T25eZnvMFZP7E2enNpeb_EUAfEtww1YJuPcLslJRvaYL-sosGHssyGimcZvj1XIH4P_rbzDstly9Uj2Ad_ZlMDx_GTyrG_jGDHIICS7La8EUtQUj37Cu0AG2QXAnBkhr5S2NXhlLBIdzwkfgW5pVZdvNnZ_BMKEKcePHy_QeG8VSelLpjoMj7nF3wnoFRjMaiEiRrzw8253ayCnXdjWJKzNpEIw0CZf_nwbXT5ITnLxzkdayUnzzbQUl9ExNRedVBpueSPWY9qP4SqFfIvb7iDbsRwdz7q0ULZFBzdMvx5GWmy3B6=w1792-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/6Lh2dQuF6WrvR0hg5kYffT-lPAUm-6gmf4WwHqEH6kxOsswagiBkqled-y46EVSQMnIunpAFGUw8dG3M0PZF5gxVHKC_u-fOywg2Jx-WYc3HeDeYJiKWpFjAovzLSf6eQ13vLeCIkCUxwsB8QQ-hvmDj9twW-Ec0zTOa1J47tMtYJMQo-h8pCLx6NmNpOS5eV_4wylxydtALEtGD0gIXe6f7cGefub8qcnmAKXawzxqSBKhHgrB3sVXKaQLPRDKekLQW_w8ns2Ft_tbHtrs-GNK0DPRniCBkUOQ-KuDBj7jmgQrq_I_yYiIhgOZY36KxGPUfZdlfstZMjLkjcqdP-cU4q6VDhjjB2O2eG_gxdsMjGqXeEWMvkNWI6ia_xL36GwXn9_UQOt4-nmPHcj4jG4IDiI-WOdIGZAX-W9ao_c-u_tgZHdOIoPla7nSXPz-88hW8D1Ewmv3kJVPxOucqQQeBYbBOFjATEziNQJQQ5mY9zSt5m3ubRVqviVJ0udd7F-dAQsYNI8xVQSV8YiNWBsj7Je-PSDHupiKA3zMN3TeXnG_F528kfhatyiA0ewzhu3KanHTkx8DHkYkPDgyzyamN72w1WTcDonvDZXC14koaBu3UE46MPMyOHu6YBoxQmfSynUNLlSz1rr-dgulRVl7AThiA3yk8=w1008-h1344-no" alt></p><p><img src="https://lh3.googleusercontent.com/6rzKbTpPW7zPTYoYqwZLy5r9uPKWqRlBzJ6ZQw1MOPurOVdTO9Bh3MOdMKZChyZtlj_97DAmDQPi_YgoQr71DFhfInE0dbRsquoRT-mH60Zr3-JX1e0SFbtSm5KoiGnRwHfZNRnLi-xrlc_TTuBimvd1NIUmMV6ngIioc6STXPZ6FhKkMtlVOslfiJminfS2QU3yQterFW9mDBjJiUhWcHLINolhcfplm-w6U3AK5G5yoo_b-4lTQHBqC7o5rMb7QDzSmgUH686hrc4Gptb01nqmv0fhKWKtm4_EeNpodLiTcxVsatNh3GJsjwz2h64myKV9WIt6WqqiNpFL8XPxaKqFrbwM4WzvThsgKPwHDP3A8ma6Bk0bdWC29Qdx9d8jyB3xE67mqYLQ9E4qcqE_Y-JO9Q-q7w-lYJMoE0zO5AsYFSStx6RWQRTGj4jys0QumzLHsDtNN_JcEynoczou_4Jh5zeEHJIeB-o2iQZ2OPa4kcoBnyDaqlokjjlBCrdPT-NNF1IHig2x4EVgUG3y214Fb6WS8Mt1Kk___6xRDJjAOU02a9DdfCZvMde7i6nsm3JoGYusmm-gDeWeJQj7kmD0GXuktO2x95Y4bARJJzHeCh1JD2hqf1U790QLIUfQhNzizT1235GS23EcXmJFV4dRdQ-QIQrp=w1008-h1344-no" alt></p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;行程（2019-06-03）&quot;&gt;&lt;a href=&quot;#行程（2019-06-03）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-03）&quot;&gt;&lt;/a&gt;行程（2019-06-03）&lt;/h1&gt;&lt;h2 id=&quot;京都&quot;&gt;&lt;a href=&quot;#京都&quot; class=&quot;headerlink&quot; title=&quot;京都&quot;&gt;&lt;/a&gt;京都&lt;/h2&gt;&lt;p&gt;行程到了第三天，我们要赶往京都，准备第四天的展会。这时候我对日本地铁之复杂有了更具体的感受，由大阪到京都线路很多，上一张地铁图，大家随意感受下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/BHMX3bN7AhJEWmFzL4FAxc1Y8L-oci5khvjwNN3TzPQI6gaGDcNvCo8bqhDRL4cXagfrSUtR55sgbu2gHQXqDBVOngGcBYBiuFaAKgW5IWM3vhrE3xVw3UUw4Fur66KFkcWH5F4zsVfOpmu6QbzFwb1rt9Srr2U8ssojJI6Hzu5M4oTHfqUskJmSMg-3EDFTxK_sUZHvaHn19Ot5mqNRddF1cs-R0YCcuXAzT_CPm4uKc8nJUWPwPqU0mJCexkWNZSdQXhvzuy2Bl1X2VSAsHniWJmaEdgjjqyEyBMr6yObu_hTm13uNVLLMWmnsbMnz56qR8L4ubykpZSKVmmEciM4JujPQB1LCI1dsSpaXrmqlU0JSyjQWQCg9QCVcTFsdx6SNVCI1tvn3gUGmThGTflFmEE9_mxAwfQ85o82QmaVIQlnz8aKAEApGsIKMEYO3y2Tn1OUn6YRKCq5cvG67Kq97W4JOLyTsDwWeJVojTHrMA0tw81DEqfyEl9yA2c7X2PWK8VqhEv9hnOLyKxrUJdZpge3GJ3--01TnqmYZqHjHTjS_9hkHfxVrrDWYzIWwEI610OxrABLj5PPsGgmS0k1w4zZ_VSC7TI1Cirwt-y82zkTLfNGlIzwBB2MQwx-WHxZpEJOdj7mOUyLKAYbjSLEQWhjDhR8T=w1082-h1442-no&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（二）</title>
    <link href="http://yoursite.com/2019/07/04/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/04/日本游记（二）/</id>
    <published>2019-07-04T14:17:22.464Z</published>
    <updated>2019-07-04T14:49:35.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行程（2019-06-02）"><a href="#行程（2019-06-02）" class="headerlink" title="行程（2019-06-02）"></a>行程（2019-06-02）</h1><h2 id="高津宫"><a href="#高津宫" class="headerlink" title="高津宫"></a>高津宫</h2><p>住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。</p><p><img src="https://lh3.googleusercontent.com/XkWYXNFkvUF5q6r2CX8IKlNPqwdjQ-byij-IM_cFAByHSdIfilYGjE_nvk3vDt4iAMwpVCRwKMiQmDmMqfSlzf2v4Tup8ungxMl9Tu9hZS3bZaucfzWtNNoJIEErPrmUDBUNNhjjIGzY1gQARe9Eu3ZMqYqLUyo4QlkOVr38s-TX-Q4-WVkdgSLT2IKAPdCCLQOVT7cVCf8LzT0ZNTSfFn0g3agxJ2cZEUxZhFF0QUK21g6BG4Ea7tdI5xlc0ocJoeuhnin0TFgJAumJefMDXFme-viHcU38wGK80YqFWRnMTlkgH5Yvdzwe8OmeXFSg1t6c2xjNyN1a7EuSnm8cEFCmx0yFxLZmlwd5_Kxo5NAowwQw0_pOWb7zThp5Sp_mSAidKDNKS6JDqi40jNxbLPZN5ixW3Prx_OZCW1GRkMMNtJHxX9S_bix7_mQsz_QTiMZRtiInW0jZ-cOSPwsv8fTP8b6Fa6MWz0LYfi7eDolikaczgkIvoEQS8v73Lbi2qIbHw34Glk9v0T7SPAWMf4baGf_LRTicwU6u-0xecj8kZiLl169B47Hq-EX43CNyUH6T7e6HrArP1ECNbazS-k8Hi0saLiBV65P28zcBn17yFBfJ1yckE1mgzplKDQel6TY_MEa11d7ZMBOcd5jnciXUJFy9zLVl=w1102-h1468-no" alt></p><a id="more"></a><p><img src="https://lh3.googleusercontent.com/XZi798Rf9OcAazrwTqpduAuk42-Qxr3AqlQlfW5oCp_ckNv7jcvBcnJvqpiaRNz2QHDFjRGIzwGcox1FvWrvq2pgypYz8RH-1A6PBZkwL28q2C5tsHOLUWZHjTw9q5t7AJYYmPqzapOWhGpOgyeK7Pe4_aKgAZzs4avhluj_1fOh2Ez9G3T5rnFX88B9Z4Yc2dCHpBGLyxGl03KGizYCm1Ot2t7FIqCdvTesHksvZ_hJ6JHnBnDGnm-nT0NkoP9mreMbnZ4TroRFb3DDFPza4hJZ-AIU07P6Md0lKhcUksGbQHBVG7fsomXiasA4TWvTq95-sijRYLMg88-tSiPgKvInytanNDoBu5LObQ1-bFYFgYuWZEAM9iiQiNTqH5eRoQjM6lyCFIYoXkmmyPOgOXmzkqWsb5EWa0ymQrqAfRBMhOmODYFR8EjwxWtP1i_wnc1-TYG_Y8KVT-VlDWjx2uRgtT7MO1hstLLyhuPVH4DrI9aTOuEa68z2JlPwICkbZsrP6cIox-JpfcMUmqvv99CdtG1Tij9q14OGaMMits82oBhBovFoyJaiH8aaijQpRcjvawR1yNP-GHUQXXw8ROYhtyqz6t1UML-En3KcalUVCXYACbMrh50ErV4fddt5kr6i05GV8WRVdCvxBJeiKTpBWs3elu06=w1958-h1468-no" alt></p><p>貌似日本人结婚也会来这里祈福或者直接就在这里举行仪式</p><p><img src="https://lh3.googleusercontent.com/GL53pgMO6ff3eN8EGlwRQvFY68NbgUyb0LqArrQlv_gCIV2HwMCVsgijJwEbMcnGH5ZH0v2JjF9_F6JnXTl1iY654AVWH4M_DVZu_Q05HQzt7KAh46NBHjJPziVKmwUhXjV-RM-GFrHCFU8r-BX2X4-qZ2J4_OyYbk4aZhY4laS_BLjpPVqsSpSubyWtNjCyMbTNMEsXMQ8lwry_1EScN4mQ09o8ExfQ00hW8CwJkp2TjR_nBjRkwKxGUvNdE54O2mwPorpoT1zSyZKWsNKFbh9vJSIsAilPvdaywzukg6k7rVjiGVFW7lRasRd126KsHym_t1zPt4Qv2CtGGCF2UfUW4Ysskw8dicZ0lzaD4YWbMivHPHRH2XqkfZ_C3t054ZukTD923VSCNk5FuCbvkUtW3jW_D8iGssviUI23scQaQU1lfGKryDCg-ejAbTgDu-yzr_W9cls2sppfkXs5C1ybnQYVSskocxz_dpWFAIP0wFLC_bQZ2Y5WsW_3mv-Kl482xnr9heCV09cnymwlDzUDM4hDbT6MEr8l7NJ8jhXnPkRYto6sSD8GwgI-KyKStq1bkin849VYSHHHlQCJZvmkwqcRi05R2gR8YUvhxj-04B9bkBajVoV1UXmaup4YxAjkXXyCw87i3wgAYd8fAMyV2PYCYSLw=w1958-h1468-no" alt></p><p>一个老大的墓碑</p><p><img src="https://lh3.googleusercontent.com/hE2TJZb01NYEI9cmJwRkaFqvjK6-q3tQ3grTMXpmdjQfwXIgTOL_d_NpYiCaDXrMxhsnhwBGRJLylH2FSeuzvaSIscyIiAN8Qh7UFN-b5Ch1yqHru5yKZx1umvpSJ_E9RcJb_57UJesBxjWbXjxEY0VPgP-KzNXcB2McTA_5OrVnl1Ah6DKJ5kLzSnz-zZiU5Ok6fcV-2QgTiLeUlpH8w3kjWIHnR6Li-zeJK4Huynzi5JdqbzQCznsZJne1sONZYXT1Ayt6EKtE5J9qBwCeiy8LQkZTDcYjT4YsJJgPjNb5MlmeXivh_IBoGQ2BWe5WWaKYFdvo1hlkZiPYt5G5qEj8ZdI3ezaAqdAlokgTRYboZqKHDRH3vjiLC12Kz4YSe2jmNaUyi_jBFLxI54Dg55XbErXxv_HsGG_SgI_Hz8kH-ahoQC9JMi3zYDBiYO3iZZ2v8w1zf7o8n5tTokKoZp8EqZESYEhg5hPbElIZeV30oGLWZ66z3P2-r3VIUPr0qHN2Lhw66M1S4fSNHVtQhoXz5rvScrhuzcg9QSww1rLTUtrQisQcaGXH7N5_m7D9DmgazpiFufKxvt6M74jN6_KcdxBGPEuPj_XeKeGfhNh3NgVJMJATQqcrO3DE6u_XiD8PV6S6oudpisN8q1g-ur7jna7Bz37K=w1958-h1468-no" alt></p><p>日式微缩版的小桥流水人家</p><p><img src="https://lh3.googleusercontent.com/4p84_9xr0lr_7XTa-B4pjB97WL3WHFqbtQjnoIgdPxV1QZo8kbI4hwktRsxjsgqJX1XmnSAsGtiDexWx82-HnghYIZs6380McCn_6KtBKPl79sBc2DNP8_ESRECe-JL9T6Rroj9VE3JlRYskWJ0qycvV2BNazviqT3-DmCeNqt65DLFzWIrahilyUGNnsgpAIoO9oxhnhe0jTZ5etSkDKyTTKrcU-b8vO5Oxx4MYiG96s3sFA1AtYfSFXeKQT0ix2nLgw5BjelFaSQa77bN25SZRK15OSB4Rserc511MxW1J25uU_h77iSCchLR5PnA-YF0un4oiTgGYsY1iiECHEYFNSSPIQbHIYzbl6ECiJHAjT2eQRbeNXNAuzjbHAprlcy2nZZywnc9JSToNv0wvJ6GKL5ucS5BXMdL4XkPyaVx0yQG48jzW1LmuryrDnumdPi6P_sklwuw-RrenknvlvL3u8fkHg_sDrPMipJYokRy1y6HBKPR-9ubOhNzytrGJbXKVGjF1G8ovz8m9asq9-W913CKmqR1JUYckVjqzYhSQnRKgCgt8XUt-e8HLgQKBhzQfwqKzEaECxnNvjzN67ue_YnGU5andFbIdSDSbLO-AkO95le33_SIawk9WECWJthaeA2YHWINCCJ7Qa0PHPdNkVN_qbuAe=w1958-h1468-no" alt></p><p>典型的日本神社⛩️，门很有特色，然后也有神兽，不知道是狐狸还是狗</p><p><img src="https://lh3.googleusercontent.com/12PnBpVVmDcuGkGrsAaR3WInXVeRsgmldPCz1cpfL3jqvz1wXOj__rQYikIqRAIVRKub8DXQbN6OEk97S1Y0J8M69wXxXfxcsOTgOpnDEOXRctDy1mM6mPiXEorYeHAjN9MImQucCOMIWyaVSknBpHpIW8aN_Pg8j24jQUzxgtnlTwsxzzQJjevy_znaU1_zbZMeuxdWgcahXIkbmhrHIn5uP91hbhWCfSBjl_FCdnUHRE7Sn_luXRJYECXQqrNcpu0dREe3MRVCy1smG4-HO1Dtormn0pc4VGCT8VuVGJh2U2dQygsxN1eqv2uqSb-8gqKIJHyj_PaHaP6OvqUmbVDc67rpGJM7YqBU57QPAclY7uCSoIc-tF9FiPZ2fXzQQxSwzCN6atmsLyFENBSd46OPsSWM6ZKid5SrkV64N794-Jl2eHra-vNFmqWGysIP7H0bU0MkTC-HNrP8xFoJAFLXyeIeWnu4Vnoc3bMJ4Gxydvw2S5NbKWuE80Xl4cE7MKBRP4tq1XnoZK-Zxh4B1UkLu3zZvQoRHAWvZcrvIG0X75cfewHOD-U7ES_KLIoKHASfA9UFMpNCAcvI6h8_Z4neGGYUbqP3Pt7rWM50xTG7dj2UjBvjQevbR4lvfne5YqxY0jukjNLKnheXHKnYOK6Ykv9bROCC=w1102-h1468-no" alt></p><p>神兽<br><img src="https://lh3.googleusercontent.com/TLl2I69ZgpbGP4xi0Bvlr2Fx8hOP7xIp8RF81q6eBvwTPGyp0bKQtUdrHOidEqvmQXgR5k_0JgmdMiGiQj5Buzy4wdAtbfbQul8pHaCL6A4EaKVUlfl74u3Z1_gAquiti6VMnd6MMB-U5UgQiiATm53wpcsrPHFK1j9ZqrqpuRU3WF_hldXCxRzeOOQ14dE-uPooqwHilj0oZgFvThSqIQheMXyFLcpAkx3gqoB00q42Xd78hnhF5Xrb_X2Ddy83Y-8PCgaRZJJWl3CuyCZR45u0qSZcqygmQlr-teYaI8uQ-8-bqJIWbbbD5p4m8b4gS6zc2pPA7BfLVFolYMqmPm8HFwzwYjWr2UDT_VfLF8CbxNVBgrbxjAR5zmr5GSHj3GvjWiE6WnvmiZkiIawm3TJicyHFonSQgWCWGIsKtTAXCQW8BVSoSStrCjh_-ixdRSUou4j7Ds_7svhLTuDfuO2PG0cyADTmMvk55ckqo2HbUyQbmvTXfC7dxb1E_M-S5r9wtJ0py8ukvLWA2boSnI7vvh8H_HyedVufe6-9RsdhRqm2BbQpF0yYofFTCwX_0bW0gwvrX8nvDDwe5yxaX6-SBjfDoXksPJwNs6j8PtDweNIDQl-BaCeZ64Dw2tgWSxdv5gflkDZbQZ-PKjUr8_rWfUn9GksS=w1102-h1468-no" alt></p><p>初来乍到，感觉什么都很新鲜，一路上用手机记录下沿途的风景，拍的有点多，后来去了京东清水寺，伏见稻荷神社发现高津宫就是小case，不过这个神社是日本人自己会来的（看见很多日本人来这里祭拜，投币拍手👏然后双手合十祈福），而那些都是游客去的，各有特色吧。</p><h2 id="黑门市场"><a href="#黑门市场" class="headerlink" title="黑门市场"></a>黑门市场</h2><p>来大阪怎么可能不吃小吃，吃小吃怎么可能不来黑门市场（小吃一条街），我们大概吃了5，6种小吃，由于是吃货，吃完才发现没有拍照。评分很高的章鱼小丸子我倒是不感冒，不过和牛倒是值得一试，特别是网上查的这家店（黑门市场几乎也都是中国人，大众点评很流行）</p><p>黑门市场<br><img src="https://lh3.googleusercontent.com/FYpRyKjXUEDiYqVZWE755jLkYezKwWl_xGj0DaTO_TetX16PZRxtR2WH2s2AF9ZFbymUMtjbaoAYClqlvJkiDfRyuybKW1QdLcTZHA2T-rGJvZpNjIN3gbfot6BOXHlpq7VJW8NS1vQ33cfI0BgbPE-GbUzaWgLQ01-13e9j7jT4mUOCcVAMW_3ilwyZNWDV46Mn8xrMZ_cPcqMAo6Am66UwgRuNr95ben-7mia8qEtu29rnf1BlWFRNQNkqU7N4JZHOhk-JFunEu2uD8E8VPNjAPB-7dAWKNDrMs-jXh7t_YD1XCAiChefCHRuZKQEMhoNr92T-2e_rF8HWO7DseFAuHXKDCQLUAr-epT0ratJDDfkofRqT7EaYi31p2opomA7OHDmQVxHaodG9ni1PD_yzSAMYP6Lmh8Df_v6MEQ4M9n5nO5_h1mo91KRWrLJphm-Dmtl7aLzDAtF_g6eq7el-cH419a4wBnc_dFaLXo7YhJg9OR9mWdjcD1kwvPuHfNZxVEkG5mEU5jTXGRNByfhE6muoVUFRXyC5QsA7jd0byVjy0Zy3eLjhWm3k6UgJkJB_LIkfltrvhiRpcy5gJaqvWj_a6ofIYYFZustkBRwZDn0qq49xWlh3RPewWuEXGstCo6hWHLGijOyJk2Gge1vLf-1JHte5=w1102-h1468-no" alt></p><p>和牛（贵呀）<br><img src="https://lh3.googleusercontent.com/TVCRSvDqtkxSLwrZ2xi2rivgXBT3RZojNFoAAcStLG0wAnps7xvzrHZeHRKP970EbTnh33RGhiujL1qRwnCnthySObvXU1gHZ1lakLKjWd5yWI-ksSHIdetYaUnZWrZV_EHgRoqApN53ymQYS8WRsxxd81MBU7MEA3Q6yLm1Q7OimBqrV9tu-IuraUQJWq_RThRZoMB2gN_ChLyEeg3qeLtIsR8oDtx15R1e-lJblVxe-tMJzT1hgt9sqYEMJ0SDvn0usb-QI-5EugYyyx6hIrtmTNYTbq4ao6ETbdgx_if_sE7NuV4P91YZG_C-mMhdRpAJ6jCILzvW1F1SjWX891ZFIxPnWpWze1_dfg6q_VZdZCCe7657LhRVniIQHdtk41H5Qht7qEyNWJIn3-edismGGo8Lvt25d1fxzg78l2BNu94LnnqyammG3AVtWGP19Ww5XwXc2qV7q05BqvipKZi5-g9qXR6s6ezVmYbRwaXNChCd-T0zWPnRVHOpuYyG06DiRQ4MofJr1XuCnP1grPsK7X1r-oD4NbiNmwxmoZZFFDk4tobuxqN5OtQ6hLozaSovcLpnT_K4fDFIslBUEdRm-dkpX90PWql9ErWhnaixYI8kK0pD3KHMwWwAegoUjsFXXRQ2jNQwZmpSlt0kZwGRto7WehJI=w826-h1468-no" alt></p><p>来一片，就是这家店的牛肉还有食客证。拍照</p><p><img src="https://lh3.googleusercontent.com/LVEpwSv2WpxIDMB4GI3TJRSl_PEOPc3m_ljHDvPmZMn4fsVMTIN-lumfRJvim2C4SD1aQAjBj-H75vuKIz82ee4TImn9VAK1QSwNJNVMHFUm099CteFGlA5ltV30LiJkTCcIZXq-4Nd5rpBXvb2CKDbj5bbt--NHECgGgpxL5azCAFcp_tb19fZrj2j19FiDX9QxEcLoSo0Y_ZdghLOSBqtoJC5Fn2jvQ5pybPReW6N-XqSeWc1XTyQq8qB_YBnUfyLveXujdrcKwQaMNCjUbHUfCu04KZdxfmrgxtypoI9n7-lmxbpKl8HuLR7FN18EvLxuShfopkhfhxvabWnpDPNZ3cfP9-PqfeKJSTKH-K7UrRQ4L0oZvyoQiu5tO6GwORzjpdBML8j8_Z5LJECpdOBbKnKJ4I7xp3VkkyNaqHVZRkjolRuQvU0iGAudUMeFvWvnzi1xjqsibRQb4M713UuvZz5X56-j4ig19fPG2z3VLwRt_UB_KC1XsFFg3cKbX9EC-Z5RhKCUUxCXC75RR1fIR7w2UQvU_iL9vJXQbn6IyJ6ARr45znPhvW7A9dujqXYeww2xjvqTt_BKzxuMyCGFjoCbUHmlMiNN29GR7hewUsUy2QCd64vCH1dwzUXiMOwelb3zOSvTK-xSySv_hTf4XMxctyeH=w1958-h1468-no" alt></p><h2 id="大丸百货"><a href="#大丸百货" class="headerlink" title="大丸百货"></a>大丸百货</h2><p>吃完就是shopping了，来到了心斋桥附近的大丸百货，途径道顿掘<br><img src="https://lh3.googleusercontent.com/N5SpLQMl88Ane-M-Jtiwj9cuRA_qSwc-xonm0GSy7HV0WfunC4miJgjerZZsLSICs5FJwqVtv5mQndh20INBGmgcfMdhMmA27gC0BaC8xyvPZRPrMI0DuImCcsE7cOHTPv5decTw6nKa3QDOCTVMFm2ErIVgTlImS1QxVcnL1K2QcS9uKEYwrthRKEV2ZXkifnnmegbxUARqm2f7OK2-dZSIikDLbznFHrl815kQ1j2dT25G9UHZAq1oDPUpE3q2NHS8q_IZLKOxVWZqhJrzHATR76mw02RR_RTJpUk8Ow0cL5771YkVhHOqzEU7RaaFTueVNviOG1IAfCf4BJZorD5YglIrQ7928hF3Qh6qKZ0-dRBJVHGGMRazMMlNc80UcPWjknGl6YFeDjyvJX2QB6dDbfxSf_EP4OXU7utLYfuHza3ddX16-qC5xIyf-ll6fn42_lakLNetBeDbMKJqGq2vM2nIzQCrRu0pUJ2KuYTtGpD82ii5_hXJ_D_oD_eMiFH2Qeeq3shd_YflqJwrExMBMl8YvAUNQTrvODQnGpizUZGznXbrv7kNIviAb3nLvCdtYLm6B_E4TYbw40n1PnQb5fTpZ3S-uk1NcjIQRdLbkhC-D1LSsZNcU3FH97CJ6m-upz-i8oZS5WHz6EZykUKmuX9PLijl=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/uA0qikR3xcN-My-BK8-qo4E3wdWFxasHLCC8w2rMRs4uWFaJslAyRhkdgxuqlFa7RTYUNsSMwwVy8xgbaja_j5Y89HkQ9bjXklsz4mamwaPMnZ1wLo1FXF3kqveCjPzFdUvzaEJJwbkcIrxRkKjdDK-Xw3NX_IAhVQksMdOXYESTydtHq2za2AQ-u7OzH42K2ipfgJOfrAjo2tmAe6dZC5Hn2PkTnivauj-Vlhfg4NmYTcsnVsHAKSxUQzxxQD2WiYtIgZPmpoTmOeutrD_XFK1zd3wCSD5TYei5zwX2XjEOQ9b1HaER1NvwPCEplUoMtNWQ7GhldlKxL6AQXiQ8mMoMf3DEocy88_GVbKRSURYcLcgsGAc6kyD1Fffi8JqAVOH7Ywmez8wfvWvCTGR5x40ubJ_n4vf7ESW3uzEmJuzYsgYkSA-sLsbzQjZtibishtsTt3e1gDM-JgFlRzrWr6dx90yF-mXUUk-KcAerRlwPIRWiqVnJioYhdL0Xx4Zb92yvlpR4irRi4ojE-0qf2jSahD2jf52Fb5S7I0zl09_qkcxHrgPEqRDfQWOSyq0LKTBmMl_nMcR9rLSyxGH7YYfaRcheTuSCAkidoKiXBXEtLwwdTeBMHoZ4Kl0nrN0_h6zIxuTxq6xezSTtrK1aynK54fgESe8r=w1102-h1468-no" alt></p><p>天公不作美，下雨了。</p><p><img src="https://lh3.googleusercontent.com/a6sNYW6B-Kk9DJoImuWqVehF6PLtKomWEoHZRPXqh2carYDP9axAAgLOOr4RqVQ6uAowzS9dlKK3eUR5vHnMCsWWBVV0o73ubPCSk4PW9wA36eYFHkVzDbDn19cZ1oOepiup-ap8U4lsaRGg3lWovUVpTBhZL1rLYjGxtlczcAXRQ2C2iKQhySWNNONrDIFHe2boHCIU6BDrep3M_SRIGEovjDdw4TZqwhtM48ctaBbYjqcIqi5TI4v3Nq5o0OXN-C_HzAdCzg75rl-Mfcw10Q4nmeYkSVFWt6SzMTs2Vb_cUD4SPpNqP1Z9Ly01HklG-PpJ7xJTiQoRoXdxIHlgK5MxrVCKmc_grFRbH1sKR2a8L0xVQTgDqnd00QSvR5F0rA1BQxe0yHYLUJ9JSq75bH2POfk9shIMMjDSA0mZQYyACEXU2R_g9QvXMI1PxhS8l2SDyN7Iu7NDiMmyj4d4jW4idmLvLL5LyeVyPODrX9Yn7iCaOzC59TSQXrFa7EYOXAyQwfPCD7D6DTZzVTYBpONJpiIAy2P_zMGMeWPyk2iwY9cFvTw2rbSwNssr-xpwVsCBTZqPSMNF-_Yn6fMsrZLnGqIpEKAR_bzjQeQJLw0cz0oMy_XUlU-feBPSXQoIyr6lztSoBGjoJNEfc5J_HiDFDVbkRaPD=w1958-h1468-no" alt></p><p>道顿掘怎么可能少得了这个标志呢，哈哈，感觉他跑很久了</p><p><img src="https://lh3.googleusercontent.com/mXk1wnnmtp8_0wtSYZoyKYvNNrWqlPNB_GETGS0YPsZ96bDMBHGhBigU95wR1b5YsKo_C4KdmY7Vt3A9zPhe-wJttGVoYaNB82QUI8Bi90CDQZzKewZsYK_48-4SgBb3kbAZSPUpMsxaSS7sYQAWyWh2x70M2Gk4-nrt39Wi4BPK3GhkT0mkwiPDGx43qAlejg-RVzbL_X1WoxdWFuFKLWrELD-eXQ0nKqJyBuDeqWA6yBIxjzbrkBise5zj_Nx7anbmKV-nAhuGCG9kaIK-hrf9upw_rn_KOj3UaIIKquM6_0krTNZLja-wdCLgbf3nb6arTMsaRuuy4Rj6qhai17fNV_fEKKUgjgEbvXswsXWmHN63y0NOjBKWm0FdsZjV981nmSlbDGfVBnmC0lJiYRRQNYwTMMYJIBow2pwdVOwBhZIBmWPMgBPqqhTMNAJXQZr22hmy-KZmAL79i3rH1k-KNZ1Uq_Zw31pPqU5HbamW8MxQJgKgRh7ZFU5cCh3SdJldndCeh50OGesvd9grZa_eRB-3y0IXYd-sh2jE7V0Uwxq3lZI3ERUucC3E3oaXJXJQsBKmG_7Qj-0N3xi-dVC_0RU0dlb_2mmBFK7YtxuyfjuRkLCG4KQsxg39NEgbNk0_jLI-ED13Jmdz2uvdWo-FCnt1aqH5=w1958-h1468-no" alt></p><p>好了，购物的就不看了，附一张老婆要的阿尔滨吧，后面的每天在补blog。</p><p><img src="https://lh3.googleusercontent.com/nyKIrfqkGeW74PhEgRUNGrYm7sqg4XP7Sb3Z4nkI3GQnU8urtVHFmTppQVpwU3ezGE2mfk6tXbL3s9cukT2aJl6YRCF9JuNbBxRusNf-GLFtgno3dEyskINOS0yj2jSt12hgtJv4PMaCHh4JPSUZUNZ3p_pvR8ffnmgCDwhQ3s16xhtqCS9dlSiMJCGr7lZ73nghTbgEbBhtKxDkJLW_JlOqo82QJF_9BDzQ_a4gDn2HgppY351z3XzOqDo4dc9C2f1QNjcfRJ99DJ1TCDEt4mTWlCSTaFHsILO0detaWw5tVJL8_6TwI6TjNLyUPUnN1OhdnEttYOhgTSB60TcPAADisev-jF6v3bFDJ0ct5VghTNMV5hQfu8imHl_USFNtxwQpAjJhhuvH8eq2AyZsj9TARm4aP5LlF4dh80VFXMtVdt2F1IwdPWibtWiHK1V5HUjQb_TCnnnH47cX33mMmCtoWfsN8GSulY3JO-HU0wEZL-I6Qsu6_X9cnO9-U0c4oCOg7rAyQrC9tnL_PdOb-yaSbDucKXwbYIul4POIDi3N8kQKEL5RDhbUjIUiedCfPL5vvFesYDOHuR7oeyBXu8ZcNzUa_USjoBTRfXy34WG2oWuXMqi9Kj9_VMCg72BRghxd6VHiv08S0K7CBUQAk0HsCl8QnjKM=w826-h1468-no" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;行程（2019-06-02）&quot;&gt;&lt;a href=&quot;#行程（2019-06-02）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-02）&quot;&gt;&lt;/a&gt;行程（2019-06-02）&lt;/h1&gt;&lt;h2 id=&quot;高津宫&quot;&gt;&lt;a href=&quot;#高津宫&quot; class=&quot;headerlink&quot; title=&quot;高津宫&quot;&gt;&lt;/a&gt;高津宫&lt;/h2&gt;&lt;p&gt;住的名宿在高津宫附近（高津宫类似一个寺庙，貌似古代日本天皇也在这里住过），所以一大早，其实已经11点来，就过来看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/XkWYXNFkvUF5q6r2CX8IKlNPqwdjQ-byij-IM_cFAByHSdIfilYGjE_nvk3vDt4iAMwpVCRwKMiQmDmMqfSlzf2v4Tup8ungxMl9Tu9hZS3bZaucfzWtNNoJIEErPrmUDBUNNhjjIGzY1gQARe9Eu3ZMqYqLUyo4QlkOVr38s-TX-Q4-WVkdgSLT2IKAPdCCLQOVT7cVCf8LzT0ZNTSfFn0g3agxJ2cZEUxZhFF0QUK21g6BG4Ea7tdI5xlc0ocJoeuhnin0TFgJAumJefMDXFme-viHcU38wGK80YqFWRnMTlkgH5Yvdzwe8OmeXFSg1t6c2xjNyN1a7EuSnm8cEFCmx0yFxLZmlwd5_Kxo5NAowwQw0_pOWb7zThp5Sp_mSAidKDNKS6JDqi40jNxbLPZN5ixW3Prx_OZCW1GRkMMNtJHxX9S_bix7_mQsz_QTiMZRtiInW0jZ-cOSPwsv8fTP8b6Fa6MWz0LYfi7eDolikaczgkIvoEQS8v73Lbi2qIbHw34Glk9v0T7SPAWMf4baGf_LRTicwU6u-0xecj8kZiLl169B47Hq-EX43CNyUH6T7e6HrArP1ECNbazS-k8Hi0saLiBV65P28zcBn17yFBfJ1yckE1mgzplKDQel6TY_MEa11d7ZMBOcd5jnciXUJFy9zLVl=w1102-h1468-no&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>日本游记（一）</title>
    <link href="http://yoursite.com/2019/06/27/%E6%97%A5%E6%9C%AC%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/27/日本游记/</id>
    <published>2019-06-27T14:34:56.375Z</published>
    <updated>2019-07-04T14:47:06.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。</p></blockquote><h1 id="行程（2019-06-01）"><a href="#行程（2019-06-01）" class="headerlink" title="行程（2019-06-01）"></a>行程（2019-06-01）</h1><p>此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。</p><a id="more"></a><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><p>我们是从香港出发的，为了赶上12点多的飞机，早上起了个大早去深圳湾过关<br><img src="https://lh3.googleusercontent.com/9mnhn5QKimcMCZk3KeJCAMrALDZAOPKZZZ7SlJ6edv_68WbYZg0BwmRwliDj5l2AZXTGgEodICoXDNN-5JkCJ0pfdwqCEM8wO2zfkwTsdiukhjU4U0-N3U1LQN7tzOfegsS5wuUQXkXHzrCg8pox_9wA00X3t7P58HRVO5luhk1-vmch4ppO8DQg81kvAx6-DxQu1wYfKYBsiPfqXnsvwbQz69liDsMcbzhfcsPAWU549cko145bGC5nHJBYFGKv83ZvafViuj7FmrSHv0uV5g7d9Rb-bWDOKayKSzqlwHAD4yKj949VTPSc1RwNnD_G9S1UrzduUj_WvULvgT76yyScCWV1eMGZmrNJOGRWkOnBFLGP9gkc4_ugh1dDYBdocIg-_QHHSs6vJ9-cIcF771qAxCGz23J_eDTP7yIFROS88Wow18dgMQMg2bIqc93OLW2Noqy6ggzefUgaKSEVWoUU5N5dvtOVDsa1dMY0kcNAJOgEkEK7bkhz4L1RCOeD7dJHkylnIn-EPLz8FlycLLrvAPCBbR_pXehuRzC70ZCM87dnRwAtBbmGWTSAnEj6BOHIyQTz-BR61fYQXbUKQHPF-G2wqKTPIHsTnfX9tFCZp4Gec8h2uHBBejIxGxpTD9e1663nygkwOa66hAobG2zXEwHt5r89=w826-h1468-no" alt="行李"></p><p>坐了个商务车直达香港机场</p><p><img src="https://lh3.googleusercontent.com/1bhd_wB-fdsvJYWrzT8q2_s_2ky5U4S7Tk6aFAuQcBS5lR5aVZaattG0OT8ZOWxd7zzvgFoICnb9Qzcdk7y0yxp3Ni0S8_6a4PHh8EpIi1q6FEYfcZ5c6xaO5gjtZVIT0Fvgw9VFTFEfGAIVkB6KNdW9CnSwh3cvxAUw0FmOv_Dp0uY3IOmpiIOxH3OVZbvgN4Pe6dUVNacNOqSxnfDZXR3BgLmUkn-R2YPDgY1PAp8NoEoNYKuorDGncvE9YRRhfU-6nePsJDEUMDdLeSc-o_CsSvLzUmSpU2FjT2HcvV9HhAFXyaOi6dRpvZX4TWfgmsSPwD2CyW551ZFt5TJ_EE84bMD82NfreJedXQMs6xHhvsujzZvdZQgfNHR3ZVsAH0xEaAjUsxUY1pxyV2DZRxNI-7wYa5C6PYIvefy4mxr1DW-We7yaqKLRbh0voPdB0DV_fPohXCwhT0tAC32bZ3l0oFcBsfnc4ESSHLi9y9IJ7cqXEq8Sn-rSTTbi1nGrb9aGpBgU9Fkwhqx2XzIsUnSsqDoJ3kKvbmrkOsOdw5K8-0-PuuryyrJz_YXvBalkZMsOzue3piaZM3zmH68IJL28C8UufB4UsMsye3IjRmn4gFTd44N2CJ-60z-QJ5T8ErLvuSkO6WQebqBpOp9ZyuQNQWsi3LjJ=w1958-h1468-no" alt="香港机场"></p><p>接着就是托运行李等飞机啦。。。。。省略一万字，怀着不那么激动的心情终于降落到了关西机场</p><p><img src="https://lh3.googleusercontent.com/ExoMihsAtfuA7kkf7OpdGdn_NdFiR0wnxMXpMQN_kKoQL8V3Q5IaefTCtUMxKOORmMiuF9FblbMpHG2RoxaWenwp-mCGp01Zac8WFAcmGIeBhHpAaE0n1tUHf1Tke0GE9rPgAWS9aroQescIAA6ipe2R2nZhT-XRpcRQQ_gV3DBXGAH7vBli6iBHbWYBeAknYGQf8rynlw3jQNKIqtrrqwwkiX-j0eC8vt11uknglOX9MY5IZ0TGRj89DFLXk6b48hzlfR4ErX3ueK0OPOUi0HA_zoyrdl4fZQ5qLqAoyQVqplCq4z96J2cJK9k484LAysvhZSl2Wo5FC-1J4DSpz787KFkpXd0KZlIkpGfdcdpr_gyP-VpJsm9RRQt2iGgTv58nrcc23lpIAzjJtA3ytJnuoNmCa5963v6wR9ERe8ae0kAYyWOqfDvSwfF38IJ4UkZ3Sf9bzjQ7QfPddfDqPzuRn3O8ogIyjJv8XDfVttqu1iMPuPUdle9DomkidWkWdPE36JYyMGrcn_DHFI6HrIr0dv3wwcIusIiavGs9kJi-zzGbQCSiKq0P-Jw-GVQjMugc_U_H1lLXopvCXk7tnEq1ETKP4w1KHtY5g8U9gxyNyz9wKPpwgvOagH5Vb3ofsTN3BoLv3yvuAJkwv58L_CJ4MRIfyfh0=w1102-h1468-no" alt></p><p>接着就是入境啦</p><p><img src="https://lh3.googleusercontent.com/QGZ2pP1mfTQMP4oxrKW23qcqB4eJ8w9RynDanzUAmD1KC2eHMv4Pc5UxDWVAAQaCJQrNQICCYxzRBAJUwkzFxocKRX91Pk17UH1m9k0Fm9kd8zgOVvYMPA73Qni8L2chzD2AZa9P944QrlgOLRtcyA9KpnLgZizSFLuQvuhJYMAfgbSMJBEKboKygDQlFbK0W0Vij36_30otT1ovBUfDdl6s81aQdLqYPXMbYPJp7esCOIPbvA_0GYTw_GAAEpHWW1RIpnf9-vkL64DJLBudAA3tioGkYjEvAiM-vhGR9OISH8ddQ3FqL6e0tln1SvmuldH1s6DWPo8RyLbdQdp0lYw5tqWMBtkVj1A8gOVaTajP6QOSIY9FoWQKG3wPJeVgcBQV37IGiSksvllHiTq3QLimGQgcsBTmXZS6I0OLKVoFwkzpEHHzasoUjxlpScvs3AwRHpbGYkeLdUULbnwBJCPaonSxnieD8rS2hDjnZUFFE5q_oI2ZxJaTSOJu4OLCBnZ-Vwz-s2KMzK1NXzsM0GO53f60TyG3YqaflCLZFNUeDXHnSPXvEMbwW1Tz-KgPp_E0HQ_1zoskiIMCrAgRURGmr2XZUu5ZbEyzjHt8uGqMHelISJTIdJ0_wWC7raWGJoZsYdmr9yI2GzAwssmHDCWXZCw62hzN=w1102-h1468-no" alt></p><p>入境就是填个单证明你来这里是要回去的，要有在日本酒店地址/电话，还要提供返程机票等，入境后有个小插曲，我有两个行李箱，然后出去后发现只有一个了，小的行李箱被我丢在里面了，然后只能用蹩脚的英语跟边境人员解释，最终还是顺利拿回来了。我们在大阪住的是在airbnb上订的名宿，在大阪市区，离周围的什么黑门市场，心斋桥，道顿掘都比较近。</p><h2 id="大阪"><a href="#大阪" class="headerlink" title="大阪"></a>大阪</h2><p>出了机场就是地铁了站（火车站），日本的地铁火车系统很发达，刚去的话坐车肯定是一脸懵逼，因为他们那边地铁站和火车站是一起的，各种运营线路，各种坐车套餐（我到现在还有些不清楚）。下面是关西机场的JR和南海电铁</p><p><img src="https://lh3.googleusercontent.com/U1wmgQobvVk7EuC6YOnDAhfOfhzm1TEJdIouwAdkDd7XwLWXpk7fhzqlioCNYLfP7ieyushA-3Z2Y1zTLuSfNOj8s6BfGC1s3g2N2r1Oa14FaOf2YXTlVKBFYSx2FyXe_FeZwx22HLppDRsHg03_BsC1WGG027S3ZWcC32yNT_J47L4aGLb6TNctgOnmRLe3A4EDRrQNzcs92IDFntfmCXY0QygLXnkxKh8aIFlIZV863mjGsLuhi1n8JI63g3U-cRSGCaMRthfzY1JC144Zzwlfx5ENDHf91H6W94RcyObvHEriYb5c9fc9ewx2-dDkn4kzxwwjL6aX97zId7FBUl4rlpMgulIq5BB0dhkw6x-PXzTOyAS7fnPap7J8UJA5Kz-yWtg9JECC8V0A77M0YbATFC5KYFTrdzUpvjm45op3dySW3lCfTMDEJB-7WkK_IsVtDDXTz8JqpqyOLUWJ8qqjVHkCXwkujaxTxGVwNtxYYdP6qJporRJ74p_wcQr_smfJVUcl1zhWoa9BSIIu2a8uvHhFK2cOxBgzExG3lJepg9P-Wb_pgJwviymll-7MpM8arkuspsCSHTKCvGf7mJj8HKAdEu-W6fUVOcPSXS7u7AHJWnWFpt3REmWHcEOK9o98MHxCoccXTnbnR8nqW0wtgU1lay_F=w1958-h1468-no" alt></p><p>我们去住的地方在难波附近，离的最近的地铁站叫九丁目，顺便说一句，国外Google Map是真好用，特别是日本的地铁火车很准时而且每趟车停的站是不一样的，它有普通，快速，特快之类的，上错车的概率是很大的，所以基本靠问和Google Map，google map完全就是神器。我们坐了南海电铁大概一个半小时到了地铁站</p><p><img src="https://lh3.googleusercontent.com/w7BLbS9kWcSAxTDncdHN5si8CiGdMdHgCKTVyDgTdletMH1-BS2pWLfUDkR_MJExv9eXx5UXBCsXVjb9OOvJ0Zd0vou2UMRTiHfJj8LV1Ur6L0tP14sy14pmSnZ2QgcFURE37Aj38sWlh8IgNDaGgr1ejTA-tfwaR-KyAeZXyhZe2I8LDE48JYa-wqOvHZ7YFZC-_0r3SQK4tjvFbshLyHtlOPrcQQTZT-2tyk4JXRsqAYD_gkNXJ7P1o23Uib5Bt0noOxr424tWjOtRuzbmCYo3m0O_ZU1EHsP1WwGtMxechYQHK6S3aLaFuShQ5kn1GBg2sMPnAriwu_QhIFslNQt22UCs_C0bvwD2rlw7OatY83fs12tBUZ0iNTOE6CDlcSt7zDDi8VGlk3J1Wp0O-kGsCrL0kaFdp1ib3Vo_xyUqRUn9AA3YMNo2x1WuALHSZ8Y3jtydkhru7OtipnZhgRKNhPTHjgEGSSYBsHT9-X3AoucydisNlgvK_VMvpl5C04Fhoh-aQych5Wsnzyd26E_SuYtcZfyS-x-LJedIIA1pOqUCLBIxJqtW9GNDeOyhnFaZhxQO5zonVBvv_JdKl2_IHuB6bD0cNf3Ki71Crq6GKMhxWkcudLr0m1jPFZgDDlM443sMgTMas-pqZAHlBNHPKkyXWFI6=w1958-h1468-no" alt></p><p>一出站就两个小姐姐现场表演，驻足看了下很Hi，但是太累了，而且也要尽快找到住的地方，所以没有多留，直接Google Map导航去民宿。</p><p><img src="https://lh3.googleusercontent.com/Bd9_5KMrqCd6Gz0G7SeQzhCRy4yBHgFmr0Agjlb2xTKdNeynDmQ8diLbd631prf5q1G0MtZf1GjDHmz-uEHlySQKxrxrnI7TMMZr_N1O0UV-Q6Qcv0fruOuap4Pdt3WdRZ_tXKFU-R4ntDHUMNBcquCOj5M_N_I_sWRiW5OeYxE6cBlXbTt-I2QFND3PZPEPwLk2H-tb1oBKzRmuBm6-F4aluTyHpy4KXM29w0-OwhcHo9TfQIgj0FbiC-QmxNr_UCLwpKDnFbxTVfNUtKSG5dyuXao58kvFCe0LPHPN0vzFn1xJwxRNvfkZePIAuwMUT3vb5dAgiLWgAmXkTZpDGiMNRHUOZu-cChouiJRY-b_0GvgrPubXv8L9WKfJrAgJgi92T3_2Osqxr-B7fkW_fRY8FSyZabXDBHArZqCNMnC1knllEHRgS_K60Pf_CFYwrIROLbXP03xTZK6ux6KIUuUDNXIm7BeTgYMFhLScPbDfgEWpAeK13ogZbNCb5Tdvk3fiUhjPJpIBo8acyesGOwzflQzrahNhzdH3KWdbUja5-iYErE0-5MgvVnK3NoyYEKHXqTVYHYgxdKmv8QFv86-j-hbrPwwHw8-Oy6bGOu-zG60TIIQjxoERq9Fcr2RgojAGTNePCI3P5TFxO6HoobZS9vt8CcSp=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/Kmykn7BlNu0Oiw2u0PVI2YqLZRhhtUdrTdlkua60khlx3tWuWyNjFA7EUNXt43O8vPYfPlXhM42NISHPg9fS6nOZb1roIqM0YsVZ5qQ5etVDUpCmQ58qQpPzUmMv7Ydf6qUn3w5A830I2LqqpGJ8Vxi12CKiY2ioCDju9cZFdzr8wSEeW5X-VbvGUmlW0WnYsvRuAFkrVavk-p82M9WAw8_xopoiRx96bI9QvD0YVAiD1qxh_YWtDz5OVWzeAAEQN6rtKK5OIznlWZp4sHwF7Ob9XWo0cQsnwg54zioMBVZejf7N289irx56Hg01yyqOjqWjT4Ff1VzzkWzpk0R2-ukHN7-4n66tnKmbR4-jpnhdFSPcY_IHWXRnOgg3fMCNpefb1oSwI1yoefAoWcMM9XiYV_5cBZVprLVwyGOILtU8_2hPRXUb17QZWOCZ72aH-V1z0Fwqxlbxiyro2VAJ5MnECQ1u5W3Eu3SHIFzsCNsIJhNuAerLFFX2meOznrzakhbYLeud4w-VLti98PE31EWWZzoUhzkOIbC33FXewjzgVqYtg_Ck7Vm3bwUdokxRirTB4k2BpXWguxnxX-lYTDxzru2uje2PH916t1OoouM9UwZsojxWb6mhih64x5IUtT9zLoaW9SsMHTJFNA6EL79mxFlL6eGS=w1102-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/WUU2c4swQ4ZvQmF5wPD0LMr8s45NHkwz1zSucfPErZRUl7t5rNqdTFgutHxke-2hmVjCXHjXjCrI2nsd3vCHXE_cnoz_fCehAxLsJPneB1YOFk5l0ITwbj9qUxO6T8A8CY7M0xLRCVPCGmdWBwRraJFsk9-wZeKvBWcI0Ly3BX5kpYuARncIr5SBm1Va52GxZrYRCxaTXAk1hajlBiHQt3H0AnahOP_ET5lXQ5XRac23as0XRJG6d3U7lYjSrp1E_yJ36lF9gM3YJQKj0VMY_QweB2wqsOWReoa7pIqCU2YrvWrcw-jWPia3N5vCH6TjtH2m8pwGck5VupIhJriqxlCTbtclgPKYk9cMwvO6cqqZuWhVUeuNzidH2NV-kRMYyhROyBSDvDwybPko4UKKWWMOiAzGG3UmAFDa7SoUUociDbMA8iBbtDqF0dDGFbRZcYPcaVJExQZzdLgoC1MT82eX7ntMot0mf5EHrKMQyV4M-GBFmpQZlNrcE-Tiqn8fW7uUZpQYyvt6yoiGELhiKOO6X9lbO0iNbxDyfTaXhtMvNNJ-qpiLOiKsH_13We8E-cpzv1Qk38dqpKQ6vpTL0v51kVfOYCggIGJ8Z8UaDes5rqWhVphvslVX8b0PA1ayz4OgmFoa2uSFzVfRC_ybfvKaEmmSJgdb=w1102-h1468-no" alt></p><p>终于找到了</p><p><img src="https://lh3.googleusercontent.com/MINvBAvtHezmTtiM3z_63G1N9pkIraiCAiO3A3dRPWHcutrJnOgaaS1zSciNktD-FmFQTuWfDlWEjKIfZicAPyxp9Roq5ldVED67ON5BWkvkfbsOE-cbYuBYluvHcRv6ApE-Lywi9p_GqaVxx-gWQcRPJB3AjbO7-LGXsW4dJ1073Vrf3uJH42-DzwFExKh8F2_X0oR2uXMI1xaKNKAvon8OSnPyGLJ2Nq7CFwlmIYRj7QrVbGexY7JXm3NsxoZS8cdOJwljtT7Oalbxw8fvVbVAbAvQmKgHXAgA5aUFHv1zF3alz4OlyUyh2nvYO1eUTFs72Ihfzbwc0DGmEOAhGw8gOB_emIpv0kmxcdetukhmUVAQgdgvHV6p5jM2P_8RCvctzYY1kWBy-QzEJVOzIpHTz4IMsGfUVXCJSi-posKDyEG4Nh8yD9Zmwv-osHJyVcsadhLWbwB_m2BovwK2oOsKk1OHi_75aNm9RdpWU4xBCaU0UBXwOoTELYCM5mnzS8NtebGrVbxDh3tFyfHgi0t44ye2YTRAZ7_4RaF_vzQuC-8OrMGf3LXMSI3sTfbf76bSfuZ28H3HlkRV4g22ZlNOMpLhzF43McdTtT8vfsx_oep-1OwIcRvMH7fEy1megZhfBo3HFkDoJR95bs7_0Cc2cw4nKyMD=w1958-h1468-no" alt></p><p>住的地方（好小啊，不过，五脏俱全）</p><p><img src="https://lh3.googleusercontent.com/mjKTtvOExCg9ZfFqvEomqxVIEVnQIsHBmasjKQcF9YozJkbO2CA9C1orwcW3Ff9HGMGV7SRQohXAwac8HhVVYHzgzbF9Ut-6RhwpiV40xe9gs9PiTr5HQWX0vEvwg4yT2p6Tz8SfKFmT0vvmqjaxsUOqAhSXDQ9m5FsMIkXYqDR-0YnlyLEUVNT_ZkJG4wKXR_WZcfPdX5xnob9am3uO3c1VcFMP-qj4Rh7y0JjNgcUCC6JGFF7qJwC9ePZYyFTl7Ri38-ypuWGDqRDhb8Broz-B3xZw7sU0o6xm9LTa-4ZYne-LG3ZLm7XjZAbqHljhpcJwCXvE4JRs_t-IoCTL6aS9v6NAZMzYW9Ui28OH1nuuIoBuCEWgs_wtDrFPEjInqIE1HgeZuRNaqtGGzwCsJBP6gLL6cGJ3w89cYP86dlU5oBq69CrJjJX0IMDxHTRmqAZljud51eKbSEa3IGDDuBtBa6D4UCvWRdtlodopUoZLlvXrX70wPd7NOCc4xjqZeCmXXMF6nFjUK7a2MJ9mrDCdvR5tl5H39gimBcKeRTBjf60YSxAPxnTzYNo6oNTsW0InI58tXlRW9AM4KtqPpPqBxH6Ho7j9sw4htS-oFSURY_eOTfZwGDO0ixrbkkzs-qaf2u1dKq8cBcl1CRiCT5KItk8yn2cX=w1958-h1468-no" alt></p><p>晚上9点到民宿，还没吃饭，就下去附近逛逛觅食，诶，找到一家</p><p><img src="https://lh3.googleusercontent.com/gMTOkVkgq5F_BSdIdYhd_L0qpm-veNokAJcx_suRxaO5YTWZm6SIpJv1R74DKJvKsis01Y3bTj6Z3MR4LfYqUeqyO98KkX-nU2PAWzXfHp4SniyW8o6l_pZiu4bBuVWVJDMl3SxTfRJTCshpwkoKlIViWySQhnc4H4bxuCAssNoopwDSC4FSTNkFZYOZm2U_cufmJLEGiAFBKcn0zuXhkRtNi_jG59UlMkmMzSSAIqqLraCLiT7RMzQ5QXVirZcqo4Yutvx5dF092cKpO6jHb2ih1Kqv95n5D1vbDis1mFFg7E1Obt9xo18wxNKGP7l9eKHv1KsEHOs01qpTo4Ft35Pry1PKeIoJADfNhP_3EO71UuXnmaO6J4ajMDhllkOuBV7Ubk6Q2WkImtjgt7TpTt86XPLgyTkCYTzjrhvH1Mnx_pJneAePa93d6KWkq-tzqTmirzcdRbOwKVTYLGPKfipb3aMr5VWFffS2SfqGQkZiR0dR23yvgnq6OXrtjO-h1GAdbrbUNIDR2GD0j8OkiN1a7I4ANiHOwNbZrAy-XoqW4M86qoAUb0Q6snS389Hu1XW-3g95Xo99lGzZ8iZCCpxOYzlD2PAWlyhMQR1I7kCpADs_XfzJ0CHQqFRJvmtXpi8iXBngLjh0XP4i30NIQq67DHmTjUqj=w1958-h1468-no" alt></p><p><img src="https://lh3.googleusercontent.com/Vu2V-2vHx871RSKC47xuUildzomhw6eHR9N1LwweuCfleuxbfvkLw01jEPtSeKkoEWz4nhMFMN1XN7zG2eOHPXFbwcuaqkGDzroSpdoVZ31ZyYDIHqvwcub3srPrFvnt4yd9CSyzxDzkZCl8v9XR12maxpX851Ppy0ATqcyjP6fzuSjaBpNrjne4v338z8hMKiCwEa9jbj0Vh8QNEnuFtfBB_9NIZmeMCpZ1IptOsU3PFJvsnDJ9uiNRDgYcayC01q3bWJsmQEIB3IFgy0ah7r8xjks4BMTr0uaNIw0zAKM4tN7Se12EpRtwsU9Q_gNW6340iW8tk5Pu1RQX3dxN7Tv4IdG2wka4yP-Q2cx9vCx6n-hNQU5BnHKWugznkOpJrK8KGTAT5W4-LrgLYP4aIvGWd53iM7hukQr2UgJenwfse50oOqMf6hlp0jvhu7C9IAYuUk7S4SwU9kI3KUeIHbXtNk3xa2MnDhog-ZvR_A_ZbmL6DhyCcXm8gNg-LICUvmKHgaQf1VtYzYXd6qM-p5V5QEp2ryJUzJNgM_9TKgAKHRf_0FCLlfBIr5azKDA1Dh77jgYiLcF0HSxkcjFKYEtwN6K0rYsE6gXbY_fkDXTBdBIBK_PRHO-ob_jcCQSRBkZGYFPGYSx0VRyeuvBni1-UexMm-Dm7=w1920-h1080-no" alt></p><p>图太多了，后面再讲吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很久没更新小窝了，一个是因为上班确实很忙（懒得写），另外就是有些技术的东西感觉积累不够（比如Spring boot后台开发）没有办法做一个好的总结就停更了。然后我新买的MBP也在家吃灰，感觉这样有些暴殄天物，就打算拿出来写写东西。6月份，公司给了个福利去日本参加一个国际展会，大概7天时间，30岁人了第一次出国，不知道算不算失败，不过感觉是真的好，日本的人，物，景给了我很深刻的印象，这里做一个流水账式记录吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;行程（2019-06-01）&quot;&gt;&lt;a href=&quot;#行程（2019-06-01）&quot; class=&quot;headerlink&quot; title=&quot;行程（2019-06-01）&quot;&gt;&lt;/a&gt;行程（2019-06-01）&lt;/h1&gt;&lt;p&gt;此行是去日本京都，但是京都没有机场，所以一般去京都的都会飞大阪（Osaka）关西（Kansai）机场，然后从关西坐车到京都（Kyoto），由于我们行程还比较宽松，所以决定先在大阪呆两天，然后去京都，最后再回大阪返程。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>熵</title>
    <link href="http://yoursite.com/2019/04/28/%E7%86%B5/"/>
    <id>http://yoursite.com/2019/04/28/熵/</id>
    <published>2019-04-27T16:12:34.182Z</published>
    <updated>2019-04-27T16:33:27.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是熵"><a href="#什么是熵" class="headerlink" title="什么是熵"></a>什么是熵</h1><p>为了理解熵，必须讲一点物理学。</p><p>19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。<strong>他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。</strong></p><p>后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。</p><a id="more"></a><h1 id="能量的状态"><a href="#能量的状态" class="headerlink" title="能量的状态"></a>能量的状态</h1><p>熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnesha9rj30cs078whz.jpg" alt></p><p>物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。</p><p>上图中，能量转化会新生成大量的状态，那么状态多意味着什么呢？</p><h1 id="熵的另外一种解释"><a href="#熵的另外一种解释" class="headerlink" title="熵的另外一种解释"></a>熵的另外一种解释</h1><p>状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：<strong>能量转换会让系统的混乱度增加，熵就是系统的混乱度。</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g2hnhmgjbwj30hg07m754.jpg" alt></p><p>熵的英文名为Entropy，我觉得这个翻译的人（胡刚复教授于1923年根据热温商之意首次把entropie译为“熵”）确实很牛逼，翻译的名字很好听。熵低则混乱度低，熵高则混乱度高。</p><p>转换的能量越大，创造出来的新状态就会越多，因此高能量系统不如低能量系统稳定，因为前者的熵较大。而且，<strong>凡是运动的系统都会有能量转换</strong>，热力学第二定律就是在说，<strong>所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。</strong></p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g2hnk9koktj30e8041glh.jpg" alt></p><p>冰块是分子的有序排列，能量释放后，变成液体水，分子排列变得无序。那么冰这个系统里的熵就比较低，而水这个系统的熵比较高。</p><h1 id="熵：一种新的世界观"><a href="#熵：一种新的世界观" class="headerlink" title="熵：一种新的世界观"></a>熵：一种新的世界观</h1><p>熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。为什么”世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。</p><p>这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。</p><p>工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。</p><p>我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。我们需要能量，让世界变得有秩序，但这样是有代价的。<strong>物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。</strong></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。（能量守恒定律告诉我们地球的能量肯定是固定的，那么当人类能利用完地球上所有的能量（不一定能利用完），而假设没有外部能量输入，则这个时候的熵如果大到一定程度是不是就是人类悲剧的开始，比如核弹，病毒等。另外一种可能，为了一部分地区的有序和稳定，牺牲了另外一部分地区的有序和生态，而目前好像就是如此，人类破坏了其它生物的家园而将自己的家园建设的越来越好）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是熵&quot;&gt;&lt;a href=&quot;#什么是熵&quot; class=&quot;headerlink&quot; title=&quot;什么是熵&quot;&gt;&lt;/a&gt;什么是熵&lt;/h1&gt;&lt;p&gt;为了理解熵，必须讲一点物理学。&lt;/p&gt;
&lt;p&gt;19世纪，物理学家开始认识到，世界的动力是能量，并且提出”能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。&lt;strong&gt;他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来，这个概念被总结成了”热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="热力学第二定律" scheme="http://yoursite.com/tags/%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之集合操作符</title>
    <link href="http://yoursite.com/2019/03/28/Kotlin%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/28/Kotlin之集合操作符/</id>
    <published>2019-03-28T03:10:02.000Z</published>
    <updated>2019-12-19T05:57:50.299Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。</p><a id="more"></a><h2 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h2><p>Kotlin中允许你去将表达式当作参数传递，你也可以直接传递函数，跟Java8一样，如果你把函数转化为一个值的话，可以用成员引用</p><p><code>val getAge = Person::age</code></p><p>这个表达式叫做 成员引用 。它为创建一个直接调用方法或访问属性的函数值提供了一种简短的语法。双冒号将类名从你需要引用的成员（方法或属性）名中分隔出来。它所做的事情跟下面其实是一样的，但是更简洁（少了一个中间变量）：</p><p><code>val getAge = { person: Person -&gt; person.age }</code></p><p>这个成员引用是lambda中的知识点，还有很多用法，需要去理解。</p><h2 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h2><p>找出这个集合中根据某个字段排序最大的值，可以仔细观察下面代码，它们的结果和意思完全一样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之maxby</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorMaxBy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当lambda表达式是最后一个参数的时候可以不要（），直接用&#123;&#125;</span></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>))</span><br><span class="line">    println(people.maxBy &#123; it.age &#125;)</span><br><span class="line">    println(people.maxBy &#123; person2 -&gt; person2.age &#125;)</span><br><span class="line">    people.maxBy(Person2::age)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transform-joinString"><a href="#transform-joinString" class="headerlink" title="transform/joinString"></a>transform/joinString</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之transform/joinToString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorTransform</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> names = people.joinToString(separator = <span class="string">"，"</span>,postfix = <span class="string">": "</span>,transform = &#123;p: Person2 -&gt;  p.name&#125;)</span><br><span class="line">    <span class="keyword">val</span> names1 = people.joinToString(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="number">1</span>) &#123; p -&gt; p.name &#125;</span><br><span class="line">    println(names)  <span class="comment">//Bob，Alice:</span></span><br><span class="line">    println(names1) <span class="comment">//Bob</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>根据条件过滤操作<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符之filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是要注意，这份代码为每个人重复了最大年龄的查找步骤。所以，如果集合中有100个人，最大年龄的搜索将会执行100次！</span></span><br><span class="line">    people.filter &#123; it.age == people.maxBy(Person2::age)!!.age &#125;</span><br><span class="line">    <span class="comment">//people.filter &#123; it.age == people.maxBy&#123;person2 -&gt;  person2.age&#125;!!.age &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只计算了一次最大值</span></span><br><span class="line">    <span class="keyword">var</span> maxAge = people.maxBy(Person2::age)?.age</span><br><span class="line">    people.filter &#123; it.age == maxAge &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="all，any，count，find等"><a href="#all，any，count，find等" class="headerlink" title="all，any，count，find等"></a>all，any，count，find等</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * list操作符all，any</span></span><br><span class="line"><span class="comment"> * list是否包含了所有这个条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorAllAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conditions = &#123;p: Person2 -&gt; p.age &gt; <span class="number">25</span>&#125;</span><br><span class="line">    <span class="comment">//全部匹配条件</span></span><br><span class="line">    people.all(conditions) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    people.all &#123; p:Person2 -&gt; p.age &gt; <span class="number">23</span> &#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个匹配条件的</span></span><br><span class="line">    people.any(conditions) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有多少个符合条件的</span></span><br><span class="line">    people.count(conditions) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找哪个是符合条件的(如果有多个元素，函数将返回第一个匹配的元素。</span></span><br><span class="line">    <span class="comment">// 如果没有满足的元素，函数返回 null 。 find 的一个同义词是 firstOrNull 。</span></span><br><span class="line">    <span class="comment">// 如果如能够更加清晰的表达你对想法，你可以使用)</span></span><br><span class="line">    people.find &#123; p:Person2 -&gt; p.age &gt; <span class="number">23</span> &#125; <span class="comment">//Alice,Ervin</span></span><br><span class="line">    people.firstOrNull(conditions)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>分组操作符，想象一下，你需要根据你某些特性来将所有元素分割成不同的组。例如，你想把年龄相同的人放在一组。把这个特性直接作为一个参数进行传递非常方便！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符groupBy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorGroupBy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>),</span><br><span class="line">        Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),</span><br><span class="line">        Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>),</span><br><span class="line">        Person2(<span class="string">"Anny"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    people.groupBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一组都被保存成一个列表。所以结果的类型为 Map&lt;Int, List&lt;Person&gt;&gt; 。</span></span><br><span class="line">    <span class="comment">// 你可以使用像 mapKeys 和 mapValues 这样的函数对这个映射做更多的修改。</span></span><br><span class="line">    print(people.groupBy &#123; it.age &#125;[<span class="number">34</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>groupBy之后返回结果是一个Map集合，最后<code>print(people.groupBy { it.age }[34])</code>中[34]其实是输出以34为key的Person。</p><h2 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h2><p>这两个操作符在RxJava中是使用频率很高的操作符，map是对一个基本类型做一个转换，例如string -&gt; int，而flagMap则是将上游的observerable变为另外一个observerable。Kotlin中，map其实也是类型转换的意思，flatmap则是将集合中每个元素映射（map），然后把多个列表合并成一个。最终，其实它是一个集合</p><p>flatMap 函数做了两件事：首先它根据作为参数而给定的函数把每一个元素都变换（或映射）到一个集合中。然后它把多个列表合并为一个。有一个处理字符串的案例很好的解析了这个概念<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g1k0wgeommj30ig0act9c.jpg" alt></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list操作符flatMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line">    print(people.map &#123; it.name + <span class="string">"'s"</span> &#125;) <span class="comment">//[Bob's, Alice's, Ervin's]</span></span><br><span class="line">    print(people.flatMap &#123; it.name.toList() &#125;) <span class="comment">//[B, o, b, A, l, i, c, e, E, r, v, i, n]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h2><ul><li>集合的序列操作，这个是很有用的东西。一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择，举个例子：<blockquote><p>NOTE 注意 一般来说，无论何时，你在大型集合中有链式操作时，请使用序列。在8.2一节，我们将会讨论为什么在Kotlin中，常规集合的延迟操作是高效的，尽管它会创建中间的集合。但是如果集合包含大量的元素，中间的元素重拍耗时巨大，所以延迟计算更 加可取。</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list的序列操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一般在集合的链式调用中会生成很多的中间集合来存放过程中的临时变量，当集合中元素过多，则明显会影响性能，这时候使用序列会是一种好的选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>), Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的链式调用</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Kotlin标准库参考（文档）指出， filter 和 map 都返回一个列表。这意味着这个链式调用将会创建两个列表：一个保存 filter 函数的结果，另一个存储 map 函数的结果。</span></span><br><span class="line"><span class="comment">     * 当原来的列表只有包含两个元素时，这不会有问题。但是如果你有百万个元素时，这会变得非常低效。 为了把它变得更加高效，你可以转换这个操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    people.map(Person2::name).filter &#123; it.contains(<span class="string">'A'</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列的操作</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有保存元素的中间集合，对于元素比较大的集合来说，性能会有客观的改善</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    people.asSequence()                    <span class="comment">//初始集合转化为序列</span></span><br><span class="line">        .map(Person2::name)</span><br><span class="line">        .filter &#123; it.contains(<span class="string">'A'</span>) &#125;</span><br><span class="line">        .toList()                          <span class="comment">//序列转化为集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合本身的操作是实时的，而序列的操作是懒加载式的，下面会详细说明序列的中间操作和最终操作</p><ul><li>序列的中间和最终操作</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1k0xt8zioj30ty06c0tu.jpg" alt></p><p>看一个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list的序列操作之不同点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sequence的操作</span></span><br><span class="line">    <span class="comment">//map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</span></span><br><span class="line">    listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; print( <span class="string">"map(<span class="variable">$it</span>) "</span> ); it * it &#125;</span><br><span class="line">        .filter &#123; print( <span class="string">"filter(<span class="variable">$it</span>) "</span> ); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">        .toList()<span class="comment">//最终操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合本身操作</span></span><br><span class="line">    <span class="comment">//map(1) map(2) map(3) map(4) filter(1) filter(4) filter(9) filter(16)</span></span><br><span class="line">    listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .map &#123; print( <span class="string">"map(<span class="variable">$it</span>) "</span> ); it * it &#125;</span><br><span class="line">        .filter &#123; print( <span class="string">"filter(<span class="variable">$it</span>) "</span> ); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意看sequence结果：map和filter是交替进行的，每个元素都是先map再filter，这证明了sequence是延迟计算的。而集合本身则是所有元素先map（中间集合），再用中间集合去filter。<strong>sequence中没有最后的toList（最终操作），则什么都不会输出。</strong></p></blockquote><p>最终操作导致所有的延迟计算都被执行了。 还有一个更重要的事要注意，在这个例子中，计算的执行顺序。原始的方法首先将会对每个元素调用 map 函数，然后对结果序列中的每个元素调用 filter 函数。这就是 map 和 filter 在集合上如何工作的。但序列并不是这样的。对于序列来说，所有的操作都会逐个应用于每个元素：处理完第一个元素（映射，然后过滤），然后处理第二个，以此类推。 这个方法意味着如果过早获取结果，某些元素根本不会被变换。我们来看一个有 map 和 find 操作的例子。首先，你把一个数映射为它的平方，之后你查找当中<strong>第一个大于３的元素</strong>（find操作符的作用）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    print(listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; <span class="number">3</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同样的操作应用于一个集合而不是序列，那么首先会计算 map 的结果，变换初始集合中所有的元素。第二步，在中间集合中发现一个满足预言的元素。使用序列，惰性方法意味着你可以提阿偶偶处理某些元素。下图解释了（使用集合）提前和延迟（使用序列）方式执行这份代码的不同点。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g1k107da1kj30uw0bsq56.jpg" alt></p><p>集合提前计算对整个集合运行每一个操作，惰性求值则逐个计算（元素多的时候效率高，性能好）</p><p>再看一个例子啊：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listOperatorSequence2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    println(listOf( <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> )</span><br><span class="line">        .asSequence()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .find &#123; it &gt; <span class="number">3</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person2(<span class="string">"Bob"</span>,<span class="number">24</span>),</span><br><span class="line">        Person2(<span class="string">"Alice"</span>,<span class="number">42</span>),</span><br><span class="line">        Person2(<span class="string">"Ervin"</span>,<span class="number">34</span>),</span><br><span class="line">        Person2(<span class="string">"Dan"</span>,<span class="number">34</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先filter有助于减少变换的总次数，</span></span><br><span class="line"><span class="comment">     * 如果先进行 map ，每个元素都会进行变换。</span></span><br><span class="line"><span class="comment">     * 但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//先map再过滤</span></span><br><span class="line">    println(people.asSequence().map(Person2::name).filter&#123; it.length &lt; <span class="number">4</span>&#125;.toList())</span><br><span class="line">    <span class="comment">//println(people.asSequence().map&#123; person: Person2 -&gt; person.name&#125;.filter &#123; it.length &lt; 4 &#125;.toList())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先过滤再映射</span></span><br><span class="line">    println(people.asSequence().filter&#123;it.name.length &lt; <span class="number">4</span>&#125;.map(Person2::name).toList())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1k115spoaj30ta09ugng.jpg" alt></p><p>先filter有助于减少变换的总次数。如果先进行 map ，每个元素都会进行变换。但是如果你先进行 filter ，不合适的元素会尽快过滤掉，而且不会进行变换。</p><blockquote><p>流 vs 序列 如果你熟悉Java 8的流，你将会看到，（Kotlin的）序列是完全一样的概念。由于Java 8的流在使用旧版本的Java搭建的平台中无法使用，比如Android，所以Kotlin提供了它自己的轮子。如果你把Java 8作为目标平台，流会给你带来一个很大的好处。但是，Kotlin的集合与序列并未实现在多个CPU上并行执行流操作（ map() 或者 filter() ）的能力。你可以基于你面向的Java版本和你的具体要求来选择流和序列。</p></blockquote><p><a href="https://github.com/ervinsae/KotlinLesson" target="_blank" rel="noopener">实例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kotlin中集合操作基本跟Java的api类似，不过它比Java多了很多扩展方法。这些扩展方法很像Java中Rx中的操作符，可以对原集合做各种变换。这些扩展方法在Kotlin中是标准库函数中的一部份，当你了解之后配合lambda表达式写代码时，你会感觉太爽了，代码就应该这样写。下面就我的理解做一个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Android Https证书详解</title>
    <link href="http://yoursite.com/2019/03/21/Android%20Https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/21/Android Https证书详解/</id>
    <published>2019-03-21T02:36:35.000Z</published>
    <updated>2019-03-22T14:37:19.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。</p><a id="more"></a><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS是基于 X.509 认证，他假定所有的数字证书都是由一个层次化的数字证书认证机构发出，即 CA。另外值得一提的是 TLS 是独立于 HTTP 的，任何应用层的协议都可以基于 TLS 建立安全的传输通道，如 SSH 协议。</p><h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><p>Https通信过程中需要交换服务器的公钥，但是怎么确保公钥就是服务器的公钥呢，就需要引入了一个第三方，也就是上面所说的 CA(Certificate Authority)。<br>CA 用自己的私钥签发数字证书，数字证书中包含A的公钥。然后 B 可以用 CA 的根证书中的公钥来解密 CA 签发的证书，从而拿到合法的公钥。那么又引入了一个问题，如何保证 CA 的公钥是合法的呢。答案就是现代主流的浏览器会内置 CA 的证书。我们可以在浏览器中看到Https网站的证书信息：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1by50u8rgj31yn0u0q8g.jpg" alt></p><h2 id="中间证书"><a href="#中间证书" class="headerlink" title="中间证书"></a>中间证书</h2><p>当然，现在大多数CA不直接签署服务器证书，而是签署中间CA，然后用中间CA来签署服务器证书。这样根证书可以离线存储来确保安全，即使中间证书出了问题，可以用根证书重新签署中间证书。上图中第三级就是中间证书了。</p><h1 id="Android配置Https"><a href="#Android配置Https" class="headerlink" title="Android配置Https"></a>Android配置Https</h1><p>Android 使用的是 Java 的 API。那么 Https 使用的 Socket 必然都是通过SSLSocketFactory 创建的 SSLSocket，当然自己实现了 TLS 协议除外。目前Android使用的网络通信基本都是Okhttp了，OK默认就支持Https，当你不配置的时候，它默认是支持在Android内部默认安装的100多个证书，在Android设置中可以看到这些内置根证书（会自动更新）。</p><blockquote><p>如果你的后端证书是购买的那么基本就是这些内置根证书中的一种了，你可以不需要任何改动，直接就可以从Http过渡到Https（直接修改BaseURL），但是如果后端使用的是自制证书，那么你就必须要配置了（如果不配置会报证书锚点找不到的错误）。</p></blockquote><ul><li>SSLSocketFactory</li></ul><p>创建SSL的工厂类，默认是这样实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> private synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">    sslContext.init(null, null, null);</span><br><span class="line">    return defaultSslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line">  &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">    throw new AssertionError(); // The system has no TLS. Just give up.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TrustManager</li></ul><p>上文说了，SSL 握手开始后，会校验服务器的证书，那么其实就是通过 X509ExtendedTrustManager 做校验的，更一般性的说是 X509TrustManager :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The trust manager for X509 certificates to be used to perform authentication</span><br><span class="line"> * for secure sockets.</span><br><span class="line"> */</span><br><span class="line">public interface X509TrustManager extends TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">            throws CertificateException;</span><br><span class="line"></span><br><span class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">            throws CertificateException;</span><br><span class="line"></span><br><span class="line">    public X509Certificate[] getAcceptedIssuers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么最后校验服务器证书的过程会落到 checkServerTrusted 这个函数，如果校验没通过会抛出 CertificateException 。很多博客说，配置 SSL 差不多是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        sslContext.init(null, new TrustManager[]&#123;</span><br><span class="line">                new X509TrustManager() &#123;</span><br><span class="line">                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        return new X509Certificate[0];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, null);</span><br><span class="line">        return sslContext.getSocketFactory();</span><br><span class="line">    &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是信任所有证书的，包括自制证书，相当于客户端不会去检查证书的签名。这么做毫无安全性可言，一般不要这么做</p><h2 id="SSL的配置"><a href="#SSL的配置" class="headerlink" title="SSL的配置"></a>SSL的配置</h2><p>Android中SSL的配置，可以不配置（系统会默认信任Android内置证书），但是如果用系统默认的 SSL，那么就是假设一切 CA 都是可信的。可往往 CA 有时候也不可信，比如某家 CA 被黑客入侵什么的事屡见不鲜。虽然 Android 系统自身可以更新信任的 CA 列表，以防止一些 CA 的失效。那么为了更高的安全性，我们希望指定信任的锚点（我们信任的证书），可以类似采用如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Ervin on 2017/3/14.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class CertificationFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static SSLContext getSLLContext(Context context)&#123;</span><br><span class="line">        SSLContext sslContext = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //取得本地证书的流</span><br><span class="line">            CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">            InputStream cerInputStream = context.getAssets().open(&quot;root.crt&quot;);</span><br><span class="line">            Certificate ca = cf.generateCertificate(cerInputStream);</span><br><span class="line">                       </span><br><span class="line">           //创建Keystore包含我们的证书</span><br><span class="line">            String keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">            keyStore.load(null, null);</span><br><span class="line">            keyStore.setCertificateEntry(&quot;ca&quot;, ca);</span><br><span class="line"></span><br><span class="line">            // 创建一个 TrustManager 仅把 Keystore 中的证书 作为信任的锚点</span><br><span class="line">            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">            tmf.init(keyStore);</span><br><span class="line">            TrustManager[] trustManagers = tmf.getTrustManagers();</span><br><span class="line">            </span><br><span class="line">            // 用 TrustManager 初始化一个 SSLContext</span><br><span class="line">            sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            sslContext.init(null, trustManagers, null);</span><br><span class="line">        &#125; catch (CertificateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return  sslContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Okhttp中开启配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">httpClient = new OkHttpClient</span><br><span class="line">                    .Builder()</span><br><span class="line">                    .addInterceptor(new TokenValidInterceptor(this.context))</span><br><span class="line">                    .addInterceptor(new HttpRespV3ConvertInterceptor())</span><br><span class="line">                    .addInterceptor(loggingInterceptor)</span><br><span class="line">                    //开启SSL配置</span><br><span class="line">                    .sslSocketFactory(CertificationFactory.getSLLContext(this.context).getSocketFactory())</span><br><span class="line">                    .connectTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>这样的话Okhttp会只<strong>信任“root.crt”以及被它签发的证书</strong>才会被信任。这里有个地方要注意：这里的root.crt在我的项目中代表了CA的根证书（第一级的证书，也许也是中间证书，过期时间比较久），还有一种证书是用这个root去签发的，在你购买证书后会给你去服务器配置的。因为在实际情况中，一般购买的证书（子证书）有效期都是2年左右，如果客户端信任这个子证书那么也就是2年后证书过期，你的APP就不能用了，因此我们考虑了使用根证书，（根证书默认会信任他以及他所签发的证书），这样子证书到期后，只要还用这家CA的证书签发一个子证书，APP还是会继续信任。这样比起信任100多个根证书，我只信任一个要安全得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;现在主流APP基本都在使用https做数据请求的通道了，相比较于Http，Https多了一个TLS的加密协议（传输层安全协议），具体Https的介绍在blog中已经写过，这里记录下在实际开发过程中，客户端要怎么配置。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Https" scheme="http://yoursite.com/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>QUANTUMULT的配置</title>
    <link href="http://yoursite.com/2019/03/18/Quantumult%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/18/Quantumult配置/</id>
    <published>2019-03-18T15:43:00.000Z</published>
    <updated>2019-12-19T06:24:16.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。</p><a id="more"></a><blockquote><p>老板由于已知的原因，时隔半年回归。寄语：“Whatever does not kill us makes us stronger.” - Friedrich Nietzsche</p></blockquote><p>这里Quantumul讲的很详细，这里就不多啰嗦了，后续还会更新最新的FQ技术及方法。</p><p>Mac：shadowsocksR-NG-R，ClashX<br>IOS：quantumul,shadowrockets,surge<br>Android: SSR,ClashNG,…</p><p><a href="https://withdewhua.space/2018/09/14/Quantumult_1/" target="_blank" rel="noopener">配置教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于众所周知的原因，我们在用的是一张局域网，由于我们的局域网足够大，生态丰富，自给自足，所以我们没有动力去了解除了这张网之外的世界是什么样的，从而也没法更客观更具体的了解你所在的世界是什么样的。幸好，网络的墙是有办法翻的。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="GFW" scheme="http://yoursite.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>Alfred的简单配置</title>
    <link href="http://yoursite.com/2019/03/14/alfred%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/14/alfred简单配置/</id>
    <published>2019-03-14T15:19:27.085Z</published>
    <updated>2019-12-19T07:39:39.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧</p><p><img src="https://www.hi-linux.com/img/linux/alfred19.png" alt></p><a id="more"></a><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>从官网就可能下载使用Alfred了，但是想用他的完整功能，比如workflow就要激活powerpack了，在天朝这些都不是问题，推荐几个Mac软件搬运工网站：</p><ul><li><p><a href="https://xclient.info/?t=6dacdaeb762299d9df9fac82782e70febed6d9c3" target="_blank" rel="noopener">大名鼎鼎的xclinet</a></p></li><li><p><a href="https://www.waitsun.com/" target="_blank" rel="noopener">域名很黄的waitsun</a></p></li><li><p><a href="http://www.orsoon.com/" target="_blank" rel="noopener">未来软件园</a></p></li></ul><p>等等吧，收藏夹里一堆。</p><h2 id="基础功能介绍"><a href="#基础功能介绍" class="headerlink" title="基础功能介绍"></a>基础功能介绍</h2><p>首先是启动alfred了，一般为避免和spotlight快捷键冲突，会将alfred启动快捷键设置为：double cmd。这样也确实挺方便的</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>这个是最简单最基础的功能了，alfred自带了一些查询，例如：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13w98d0wmj30we0rqkbi.jpg" alt></p><p>只要输入关键字，就可以打开浏览器Google一下你要的内容了，alfred会自动匹配所有和关键字相关的内容（10个）给你选择。你也可以自己设置自定义的搜索规则：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga22detzflj31880u00x3.jpg" alt></p><h3 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h3><p>剪切板功能也是一个很赞的功能，我的使用频率也是最高的之一，一般快捷键设置为：cmd+option+C。会弹出最近你所复制的文本，图片，甚至文件。如果一段文字你需要多次用到，那么这个将会大大提高你的效率。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13wiqzej1j30w00nuaop.jpg" alt></p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>这个功能主要是你可以使用alfred的感觉真关机，待机，锁定屏幕等等。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g13wkaz6fqj30w409swko.jpg" alt></p><h3 id="Terminal-shell"><a href="#Terminal-shell" class="headerlink" title="Terminal/shell"></a>Terminal/shell</h3><p>这个是由于我在Mac上使用的是程序员专用的iTerm命令行工具，然后Alfred可以通过“&gt;”来开启命令行（很好的功能），但是它默认使用的是mac系统自带的terminal，如果你想开启iTerm，那么：</p><blockquote><p>Preference - Terminal/shell - Application:custom</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//适用于iTerm2</span><br><span class="line">on alfred_script(q)</span><br><span class="line">if application &quot;iTerm2&quot; is running or application &quot;iTerm&quot; is running then</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to false</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to true</span><br><span class="line">end try</span><br><span class="line">tell current session of the first window</span><br><span class="line">if onlywindow is false then</span><br><span class="line">tell split vertically with default profile</span><br><span class="line">write text q</span><br><span class="line">end tell</span><br><span class="line">end if</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">else</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">end try</span><br><span class="line">tell the first window</span><br><span class="line">tell current session to write text q</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">end if</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><h2 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h2><p>这个是收费功能，也是alfred可以拥有无限可能的功能，他类似于IOS中的捷径（其实原来也叫workflow，被Apple收编后叫捷径）</p><p>下面简单介绍几个有用的workflow：</p><h3 id="New-File"><a href="#New-File" class="headerlink" title="New File"></a>New File</h3><p>mac上新建文件是个比较蛋痛的事，一般人还新建不来。如果有这个就好办了。该插件默认启动关键字是：new。默认情况下，你可以直接新建 TXT、MD、自定义文件类型这三种类型的文件和目录。其中 TXT、MD 格式也是比较常用的文本格式，插件就将这两种类型的文件直接作为了默认文件类型。真是非常贴心！</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13wwgsd46j30w20ikdpy.jpg" alt></p><h3 id="TerminalFinder"><a href="#TerminalFinder" class="headerlink" title="TerminalFinder"></a>TerminalFinder</h3><p>看名字就知道是Finder和Terminal互相切换的，有时候我们在Finder中想开启命令行，还有时候在命令行中打开了一个目录又想在Finder中显示。用这个吧。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g13wz57gcaj31q20cy45w.jpg" alt></p><h3 id="有道词典"><a href="#有道词典" class="headerlink" title="有道词典"></a>有道词典</h3><p>系统自带的词典，查找起来不太方便，alfred的workflow中使用yd关键字就能英汉互查</p><p><img src="https://static.hufangyun.com/hexo/img/alfred-youdao.jpg?imageView2/2/w/500" alt></p><blockquote><p>好用的workflow其实有很多，需要大家去发掘去使用，但是另一方面我们其实也用不到那么多功能，所以还是适合自己的才是最好的。</p></blockquote><h3 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h3><p>workflow插件是傻瓜式的，直接下载.workflow文件下来后，点击就能安装了。下面给几个下载workflow的网站：</p><p><a href="http://www.packal.org/" target="_blank" rel="noopener">Packal</a></p><p><a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">alfredflow</a></p><p>还有就是Google了。。。。。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>最后，如果你有多台mac之间都在用alfred，你想使用一个配置文件，那么你就要使用同步功能了。坑爹的是，aflred默认是不同步的（连iCloud都不支持），它只是把配置文件保存在本地，那么怎么才能同步呢，上图：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g13x8udixpj319j0u01j0.jpg" alt></p><p>说白了也就是自己把配置文件上传到云端，多端同步。</p><p>最后，其实这个blog只是我使用的一个简单介绍或者记录，alfred还有很多高级功能没有去涉及，还是希望能帮助到别人吧。生命在于折腾！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Alfred是Mac上著名的效率工具，自从上手后，基本每天都会用到。他和Mac的官方应用Spotlite是一类的，不过相比之下，alfred除了能全文搜素以外还有强大的“工作流”等扩展功能。下面简单介绍下我在使用中的感受，以及经常用的功能。先看下官网是怎么说的吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/alfred19.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Git的常规配置</title>
    <link href="http://yoursite.com/2019/02/28/git%E7%9A%84%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/28/git的常规配置/</id>
    <published>2019-02-28T08:16:18.972Z</published>
    <updated>2019-02-28T08:20:10.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h1><p>git的全局和单个仓库的用户名和邮箱的配置</p><ul><li>全局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;email&quot;</span><br><span class="line">//查询</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>某个仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;name&quot;</span><br><span class="line">git config user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>未完待续，持续更新。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mark&quot;&gt;&lt;a href=&quot;#Mark&quot; class=&quot;headerlink&quot; title=&quot;Mark&quot;&gt;&lt;/a&gt;Mark&lt;/h1&gt;&lt;p&gt;git的全局和单个仓库的用户名和邮箱的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android后期开发的几个方向</title>
    <link href="http://yoursite.com/2019/02/25/Android%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E5%90%91/"/>
    <id>http://yoursite.com/2019/02/25/Android开发的几个方向/</id>
    <published>2019-02-25T04:05:41.864Z</published>
    <updated>2019-02-26T06:51:36.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。</p><a id="more"></a><h1 id="移动端未来的几个方向"><a href="#移动端未来的几个方向" class="headerlink" title="移动端未来的几个方向"></a>移动端未来的几个方向</h1><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>目前我们项目已经在尝试走组件化和插件化，前两年，插件化火起来了，为什么火呢，因为可以实现Android不用发布版本就可以热更新，但是插件化有自己的问题，就是兼容性。Android机型太多（马上要出折叠屏了），插件化框架难免要涉及到系统API的hook，兼容性问题就出现了，开发者会莫名其妙碰到各种错误，随着Android版本迭代，插件化这条路越来越不好走，Android P给了开发者一个信号，不能再随便hook系统API了，Google要开始整顿了。然后，另外一个动态化就是Hybrid开发了，利用H5和原生混合开发（目前最为流行的开发方式），例如老牌的Cordova，Facebook的React-Native（通过Jscore进行js解析，使得原生View进行渲染，提供桥机制调用原生的能力）。RN是第一个真正的高性能动态框架，它的出现让Web前端和客户端的界限变得模糊。随之而来的是各个大公司的自研框架，例如阿里巴巴的Weex和美团的Picasso框架，RN只提供了Android和IOS的支持，Weex扩展了思路，提供了Web端的支持，一个是React语法糖，一个Vue语法糖。另外，Google自己在2018年下半年正式推出了自己的跨平台方案—Flutter（前面Blog已经写过），通过Dart编写APP，然后编译成机器码运行在IOS和Android上，对开发者最好的是Hot reload，而且做到了原生跨平台。</p><h2 id="移动端机器学习"><a href="#移动端机器学习" class="headerlink" title="移动端机器学习"></a>移动端机器学习</h2><p>毫无疑问，移动端机器学习从2017年年底就开始火起来了，TensorFlow 也推出了移动端框架，很多应用都开始在移动端部署机器学习模型，例如相机类应用（FaceU）、电商类应用（唯品会）等，包括离线的机器学习。<br>如果深挖这个方向，我觉得十年内不会被淘汰。当然了，难度也不小。</p><h2 id="AR和VR"><a href="#AR和VR" class="headerlink" title="AR和VR"></a>AR和VR</h2><p>从支付宝的 AR抢红包、QQ的AR踢球等玩法被越来越多的人体验，AR走进了人们的视野。对于广告引流玩法来说，AR无疑是能带来巨大收益的。那么开发AR引擎的移动开发者自然成了香饽饽，目前AR主要应用的领域是广告变现，不过很多公司也找到了AR的一些落地场景，如果是研究OpenGL，计算机图形学的移动开发者，可以往AR引擎开发方向发展，非常有前景。</p><h2 id="移动端音视频"><a href="#移动端音视频" class="headerlink" title="移动端音视频"></a>移动端音视频</h2><p> 这个领域最火的就是抖音了，还有各种相机，图片应用等都需要音视频开发领域的专业开发人员，图像处理，滤镜，剪裁等，研究OpenGL，计算机图形学的移动开发者在这个领域也有很大的优势</p><h2 id="移动端区块链"><a href="#移动端区块链" class="headerlink" title="移动端区块链"></a>移动端区块链</h2><p>在人人都知道比特币的时候，背后的区块链技术也得到了大家的拥护，区块链应用目前最多的还是数字钱包，但是未来应该会有更多的落地方式，例如Status。如果有移动开发同学对区块链方向感兴趣的，可以开始研究起来了。如果要学习智能合约开发的同学，我推荐一个非常好的网站：Cryptozombies，绝对是入门 solidity 智能合约开发的精品。</p><p>目前移动端的区块链人才还不多，各大公司也没有在招，但是两三年内，应该就会爆发了，现在还在探索落地场景的阶段，也给了对区块链技术感兴趣的移动开发同学学习的时间。改变世界的技术了解一下？</p><h2 id="移动端基础框架"><a href="#移动端基础框架" class="headerlink" title="移动端基础框架"></a>移动端基础框架</h2><p>UI未来可能都会被动态化技术接管，但是移动基础框架不会。一个APP总要有网络请求，日志处理，ORM，缓存，PUSH等框架，这部分和UI关系不大，但是是组成APP不可或缺的部分。框架其实就是轮子，我们用轮子用的很溜并不代表你的代码能力很溜，而是人间写的轮子很溜，好的轮子就是无论开发者代码能力好坏，写出来的功能和性能都是差不多的，比如Retrofit，OKhttp等。在这些框架基础上P5和P7写的代码不会有多大差别。然后，轮子总要有人写，而且大公司的需求可能开源的轮子不满足，这时候就要自创轮子了。写轮子就需要开发者的知识深度和广度了，需要沉淀和学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;从2008年左右移动端的兴起，到2012-2015年左右移动端的炙手可热，到如今各种“凉凉论”的现状，作为一个Android开发者，自己的思考以及别人的观点，写一些自己的看法，供自己参考。目前，大环境也比较差（好像每年都这么说），焦虑没用，说白了只有积累自己，厚积薄发才可能不被市场和时间淘汰。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android动画总结</title>
    <link href="http://yoursite.com/2019/02/16/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/16/Android动画总结/</id>
    <published>2019-02-16T07:55:33.060Z</published>
    <updated>2019-02-27T14:43:44.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">lottie</a>,<a href="https://github.com/yyued/SVGAPlayer-Android" target="_blank" rel="noopener">SVGA</a> 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。)</p><a id="more"></a><h1 id="动画分类"><a href="#动画分类" class="headerlink" title="动画分类"></a>动画分类</h1><h2 id="各自特点及区别"><a href="#各自特点及区别" class="headerlink" title="各自特点及区别"></a>各自特点及区别</h2><p>Android动画主要分为视图动画和属性动画，视图动画只有透明度，旋转，平移，伸缩四种，而属性动画则是只要是对象的属性且有setter该属性的方法就可以对该属性执行一种动态变化效果。视图动画主要是使用<strong>Animation</strong>，组合动画使用AnimationSet，而属性动画主要是<strong>Animator</strong>，组合使用AnimatorSet。视图动画主要就是四种操作，对对象的颜色，背景等就无能为力了。相对来说，属性动画会更精细点，能实现更多更好的效果。</p><h2 id="视图动画"><a href="#视图动画" class="headerlink" title="视图动画"></a>视图动画</h2><p>视图动画很早就出现在Android中，主要在android.view.animation包下面，这里可以看到主要是对View进行操作的，里面有很多的类帮助我们实现一些简单动画效果，如对view进行移动，缩放，旋转，淡入淡出等，并且我们可以借助AnimationSet将这些动作组合起来</p><ul><li>补间动画（Tween Animation）</li></ul><table><thead><tr><th>名称</th><th>原理</th><th>对应Animation 子类</th></tr></thead><tbody><tr><td>平移动画</td><td>移动视图位置</td><td>TranslateAnimation</td></tr><tr><td>缩放动画</td><td>放大缩小视图</td><td>ScaleAnimation</td></tr><tr><td>旋转动画</td><td>旋转视图位置</td><td>RotateAnimation</td></tr><tr><td>透明度动画</td><td>改变视图透明度</td><td>AlphaAnimation</td></tr></tbody></table><ul><li>逐帧动画（Frame Animation）</li></ul><p>这个类似动画片，一帧一帧播放，每一帧是一张图片，按顺序去播放一组预先定义好的图片，简单方便，但是容易OOM，占资源</p><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画在Android3.1的时候才引入到Android中，主要在android.animator包下面。属性动画机制已经不仅仅是针对View来设计了（看包名就知道），也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不在是视觉上的动画效果了。它实际上是一种不断对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性（真的改变了对象属性）。属性动画的工作原理和逻辑：</p><p><img src="http://upload-images.jianshu.io/upload_images/944365-16a162a731f548d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>步骤2中的插值器，默认会有一些系统自带的插值器，如下表，表示的是初始值到结束值的一个变化关系，关系到动画的一个显示效果。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>插值器（Interpolator）</td><td>值的变化模式（匀速,加速）</td></tr><tr><td>估值器（TypeEvaluator）</td><td>决定值的具体变化数值</td></tr></tbody></table><table><thead><tr><th>插值器名称</th><th>描述</th></tr></thead><tbody><tr><td>AccelerateDecelerateInterpolator</td><td>先加速再减速</td></tr><tr><td>AccelerateInterpolator</td><td>先加速再一直加速</td></tr><tr><td>AnticipateInterpolator</td><td>先往后一下，再加速往前</td></tr><tr><td>AnticipateOvershootInterpolator</td><td>先往后一下，再一直往前超过终点，再往回收一下。</td></tr><tr><td>BounceInterpolator</td><td>最后会回弹一下</td></tr><tr><td>CycleInterpolator</td><td>重复几次，感觉就是环形进度条那种，具体我还没试过</td></tr><tr><td>DecelerateInterpolator</td><td>一直减速</td></tr><tr><td>LinearInterpolator</td><td>线性匀速</td></tr><tr><td>OvershootInterpolator</td><td>到了终点之后，超过一点，再往回走。有个参数可以定义，超过的力度。</td></tr></tbody></table><h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><ul><li><p>定义：通过不断控制值的变化，再不断手动赋值给对象的属性，从而实现动画效果。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/944365-d74ed6378954939b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>用法</p></li></ul><pre><code></code></pre><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator<br>测试Hexo本地是否要保留原文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Android动画其实是Android开发的一个基础能力，在开发中不可避免的需要去用到动画，github上也有一些很好的动画开源库例如：&lt;a href=&quot;https://github.com/airbnb/lottie-android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lottie&lt;/a&gt;,&lt;a href=&quot;https://github.com/yyued/SVGAPlayer-Android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SVGA&lt;/a&gt; 等，但是轮子用多了，基础的倒是很容易忘，所以这里做个总结，备查纠错。(未完成待续。。)&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>SBT环境搭建</title>
    <link href="http://yoursite.com/2019/01/30/SBT%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/30/SBT环境配置/</id>
    <published>2019-01-30T08:32:09.016Z</published>
    <updated>2019-01-30T09:25:18.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol><li>由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做个记录（凑数）。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li>前提<br>必须要装JDK，sbt也是运行在JVM上的，所以需要java的环境，没有环境sbt会提示你先要装JDK，然后就是配置好环境变量了。</li><li><p>下载IDE<br>现在宇宙IDE非IDEA莫属了（VS Code表示不服），前后端主要的平台都支持，AndroidStudio就是基于这个IDE写的。咱也熟。下载完成后下载插件：Scala和Sbt。下载完成后重启IDE，导入Sbt项目后，会自动在右侧多了个sbt编译按钮<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzopvtb2v6j30l40ocacg.jpg" alt></p></li><li><p>下载sbt sdk<br>这里要下载sbt最新版本（好像是1.2.+），配置好环境变量，在命令行测试命令：sbt或者sbt test。这样在user目录下会生成一个.sbt目录。</p></li></ul><ul><li>配置私服访问<br>一般上面三步基本就能配好环境。直接导入代码就可以使用sbt编译了，但是我们的后端很多依赖包是在自己公司搭建的私服上的，所以还需要配置访问私服的密钥和路径。（问人的，这个貌似很多文章都找不到），生成两个文件（一个私服仓库的路径文件，一个授权访问私服的文件）见图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzoqdm8mctj30dc0e0gmc.jpg" alt><br>需要放在上面所说的.sbt文件中。</li></ul><blockquote><p>这里还有一个很坑人的地方，导致你编译失败，代码一片红，因为我们在上面的私服仓库路径文件里面配置的第三方依赖包和我们自己仓库的依赖包都会同时下载，但是基于经验判断我们下载自己仓库的包的时候先决条件是需要把第三方包都下载好，这样如果同时下载会导致所有包都下不下来（坑），这时候就需要根据经验先下载一些优先的第三方包，注释掉另外一些路径，等下载完成后再打开这些路径，接着下载所需的私有仓库中的包。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;由于临时的变动，我需要去搭建一个跑Scala的环境去跑后台服务，但是Scala和Sbt我都不太熟悉，只能去找资料和问人了，这里做
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="scala，sbt" scheme="http://yoursite.com/tags/scala%EF%BC%8Csbt/"/>
    
  </entry>
  
  <entry>
    <title>kotlin常用操作符</title>
    <link href="http://yoursite.com/2019/01/03/Kotlin%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/01/03/Kotlin中常见的操作符/</id>
    <published>2019-01-03T06:43:00.000Z</published>
    <updated>2019-01-03T06:51:56.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="？操作符"><a href="#？操作符" class="headerlink" title="？操作符"></a>？操作符</h3><p>表示这个对象可能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在变量后面加？，代表这个变量可以为空</span><br><span class="line">var name: String? = &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果str不能转为Int类型，则返回null</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？</span><br><span class="line">b?.length</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="?:操作符"></a>?:操作符</h3><p>如果操作符左边表达式不为空用左边表达式结果，为空则用右边的值。类似三元运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val l: Int = if(b!=null) b.length else -1</span><br><span class="line">// 除了完整的if表达式，这个还可以用Elvis操作符来表示：</span><br><span class="line">val l = b?.length ?: -1</span><br><span class="line">// 如果?: 左侧表达式非空，elvis操作符就返回左侧表达式的值，否则返回右侧的值。</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：当且仅当左侧为空时，才会对右侧表达式求值。</p></blockquote><h3 id="！！操作符"><a href="#！！操作符" class="headerlink" title="！！操作符"></a>！！操作符</h3><p>一定是非空的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这会返回一个非空的b值，或者如果b为空，就会抛出空指针异常</span><br><span class="line">var l = b!!.length</span><br></pre></td></tr></table></figure><h3 id="与"><a href="#与" class="headerlink" title="== 与 ==="></a>== 与 ===</h3><p>这个类似java中的 == 和 .equals()</p><p>== 判断值是否相等，=== 判断值及引用是否完全相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val num: Int = 128;</span><br><span class="line">val a:Int? = num</span><br><span class="line">val b:Int? = num</span><br><span class="line">println(a == b) //true</span><br><span class="line">print(a === b) //false</span><br></pre></td></tr></table></figure><h3 id="符号以及-in-和-in-操作符"><a href="#符号以及-in-和-in-操作符" class="headerlink" title="..符号以及 in 和 !in 操作符"></a>..符号以及 in 和 !in 操作符</h3><p>..代表从x到y，==包括x和y,这是一个闭区间==运算符，而until则是半闭区间运算符，代表从a到b范围内所有的值，==包括a和不包括b==。<br>in代表在一个区间中，！in代表不在一个区间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i in 1..10)&#123; //等价于 1 &lt;= i &lt;= 10</span><br><span class="line">    println(i) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用until函数，创建一个不包括其结束元素的区间</span><br><span class="line">for(i in 1 until 10)&#123;&#125; // i in [1,10)</span><br></pre></td></tr></table></figure><h3 id="downTo-函数"><a href="#downTo-函数" class="headerlink" title="downTo()函数"></a>downTo()函数</h3><p>倒叙遍历，区间内循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(i in 4 downTo 1)&#123;&#125; //print(i) -- 4321</span><br></pre></td></tr></table></figure><h3 id="step函数"><a href="#step函数" class="headerlink" title="step函数"></a>step函数</h3><p>可以进行任意数量的迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..4 step 2) print(i) // prints &quot;13&quot;</span><br><span class="line">for (i in 4 downTo 1 step 2) print(i) // prints &quot;42&quot;</span><br></pre></td></tr></table></figure><h3 id="符号"><a href="#符号" class="headerlink" title="::符号"></a>::符号</h3><p>得到类的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(this@KotlinActivity, MainActivity::class.java))</span><br></pre></td></tr></table></figure><h3 id="符号-1"><a href="#符号-1" class="headerlink" title="@符号"></a>@符号</h3><p>限定this的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    inner class State&#123;</span><br><span class="line">        fun getUser(): User&#123;</span><br><span class="line">            //返回User</span><br><span class="line">            return this@User</span><br><span class="line">        &#125;</span><br><span class="line">        fun getState(): State&#123;</span><br><span class="line">            //返回State</span><br><span class="line">            return this@State</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为标签<br>跳出双层循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loop@ for (itemA in arraysA) &#123;</span><br><span class="line">     var i : Int = 0</span><br><span class="line">      for (itemB in arraysB) &#123;</span><br><span class="line">         i++</span><br><span class="line">         if (itemB &gt; 2) &#123;</span><br><span class="line">             break@loop</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         println(&quot;itemB:$itemB&quot;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==命名函数自定义标签：==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun fun_run()&#123;</span><br><span class="line">    run &#123;</span><br><span class="line">        println(&quot;lambda&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    var i: Int = run &#123;</span><br><span class="line">        return@run 1</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;$i&quot;)</span><br><span class="line">    //匿名函数可以通过自定义标签进行跳转和返回</span><br><span class="line">    i = run (outer@&#123;</span><br><span class="line">        return@outer 2</span><br><span class="line">    &#125;)</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从forEach跳出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun forEach_label(ints: List&lt;Int&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    var i =2</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        //forEach中无法使用continue和break;</span><br><span class="line">//        if (it == 0) continue //编译错误</span><br><span class="line">//        if (it == 2) /*break //编译错误 */</span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">     run outer@&#123;</span><br><span class="line">         ints.forEach &#123;</span><br><span class="line">             if (it == 0) return@forEach //相当于在forEach函数中continue,实际上是从匿名函数返回</span><br><span class="line">             if (it == 2) return@outer //相当于在forEach函数中使用break,实际上是跳转到outer之外</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    if (i == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        //每个函数的名字代表一个函数地址，所以函数自动成为标签</span><br><span class="line">        return@forEach_label //等同于return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="as-操作符"><a href="#as-操作符" class="headerlink" title="as?操作符"></a>as?操作符</h3><p>当使用as转型的时候，可能经常出现ClassCastException。所以，现在可以用==as?安全转型==，当转型不成功的时候，它会返回null。</p><blockquote><p>注意：在使用intent传值的时候，会出现空字符串不能用as强制转型，应该使用as?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val m: Int? = a as? Int</span><br></pre></td></tr></table></figure><h3 id="冒号："><a href="#冒号：" class="headerlink" title="冒号："></a>冒号：</h3><p>用于类的继承，变了的定义</p><ol><li>类型和超类型之间的冒号前要有一个空格</li><li>实例和类型之间的冒号前不能用空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义全局变量时</span><br><span class="line">var str: String? = null</span><br><span class="line"></span><br><span class="line">//类的继承与变量定义</span><br><span class="line">class TestActivity&lt;T : Serializable&gt;(str: String) : Activity&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型判断符is"><a href="#类型判断符is" class="headerlink" title="类型判断符is"></a>类型判断符is</h3><p>检查某个实例是否是某个类型，如果判断出属于某个类型，那么判断后的分支中可以直接可当该类型使用，==无需显示转换==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">        //obj在&amp;&amp;右边自动动转换成&quot;String&quot;类型</span><br><span class="line">        if (obj is String &amp;&amp; obj.length &gt; 0)</span><br><span class="line">            return obj.length</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="操作符-2"><a href="#操作符-2" class="headerlink" title="$操作符"></a>$操作符</h3><p>字符串可以包含模板表达式，及一小段代码，会求值并把结果包含到字符串中。模板字符串以美元符号$开头，由一个简单的名字构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val value:Int=5;</span><br><span class="line">val str:String=&quot;the value is $value&quot;</span><br></pre></td></tr></table></figure><h2 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h2><p>run 、 apply 、 let 、 also 和 with 五个函数均位于 kotlin 包下的 Standard 文件中，其含义和用法比较相似，现分别介绍如下。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul><li>run函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.run&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>run函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>run函数实际上可以说是let和with的结合体，run函数只是接受一个lambda函数作为参数，以闭包形式返回，==返回值为最后一行的值或者指定的return的表达式==</p></li><li><p>例子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.run &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">  public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>适用场景<br>适用于let，with函数任何场景，因为run函数是let，with两个函数的结合体，它既弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样省略，直接访问实例的公有属性和方法，另一方面也弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p></li><li><p>run函数使用前后对比</p></li></ul><p>不使用run函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"></span><br><span class="line">   with(item)&#123;</span><br><span class="line"></span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用run函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line"></span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       // 可以看到直接省略了item，并且可以在之前判空</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>let函数的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object.let&#123;</span><br><span class="line">it.todo()//在函数体内使用it替代object对象去访问其公有的属性和方法</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//另一种用途 判断object为null的操作</span><br><span class="line">object?.let&#123;//表示object不为null的条件下，才会去执行let函数体</span><br><span class="line">it.todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>let函数底层的inline扩展函数+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>从源码let函数来看，它是一个只有一个lambda 函数块block作为参数的函数，调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过it指代该对象，返回值为函数块的最后一行或者指定return表达式。</p></li><li><p>let函数的kotlin和java转化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //kotlin</span><br><span class="line"></span><br><span class="line"> fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = &quot;testLet&quot;.let &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line"> &#125;</span><br><span class="line">//返回值：7/1000</span><br><span class="line"></span><br><span class="line"> //java</span><br><span class="line"></span><br><span class="line"> public final class LetFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var2 = &quot;testLet&quot;;</span><br><span class="line">      int var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      System.out.println(result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>let函数适用的场景<br>最常用的场景就是使用let函数处理需要针对一个可以null的对象统一判空处理。</p></li><li><p>let函数的前后对比</p></li></ul><p>没有使用前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mVideoPlayer?.setVideoView(activity.course_video_view)</span><br><span class="line">mVideoPlayer?.setControllerView(activity.course_video_controller_view)</span><br><span class="line">mVideoPlayer?.setCurtainView(activity.course_video_curtain_view)</span><br></pre></td></tr></table></figure><p>使用后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对对象做了统一的判空处理</span><br><span class="line">mVideoPlayer?.let &#123;</span><br><span class="line">       it.setVideoView(activity.course_video_view)</span><br><span class="line">       it.setControllerView(activity.course_video_controller_view)</span><br><span class="line">       it.setCurtainView(activity.course_video_curtain_view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><ul><li>with函数的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with(object)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>with函数底层的inline扩展函数+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure><ul><li><p>结构分析<br>with函数和前面几个函数使用方法略有不同，因为它不是以扩展的形式存在的。它是将某个对象作为函数的参数，==在函数块内可以通过this指代该对象==。返回值为函数块最后一行或者指定的return表达式。</p><p>可以看出with函数接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始的样子如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user, &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>但是由于，with函数最后一个参数是一个函数，可以把函数提到圆括号外部，所以最终with函数的调用形式如下：（可以看下kotlin的lambda表达式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user) &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>with函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = with(user) &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line"> public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var4 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>with函数的适用场景</li></ul><p>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBindViewHolder中，数据model的属性映射到UI上</p><ul><li>with函数使用前后对比</li></ul><p>没有使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line"></span><br><span class="line">   ArticleSnippet item = getItem(position);</span><br><span class="line">        if (item == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">        holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">        String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">        String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">        String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">        String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">        holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"></span><br><span class="line">   with(item)&#123;</span><br><span class="line"></span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       //省略了item，直接调用了实例中的方法</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul><li>apply函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.apply&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数的inline结构分析</li></ul><p>从结构上来看，apply函数和run函数很像，唯一不同点就是他们各自返回值不同，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回值则是传入对象的本身。</p><ul><li>apply函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.apply &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//输出：result：kotlin，1，111111（User本身对象被打印出来）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class ApplyFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      String var3 = &quot;result: &quot; + user;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>apply函数使用前后的对比</li></ul><p>没有使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)</span><br><span class="line">mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">mSheetDialogView.course_comment_seek_bar.max = 10</span><br><span class="line">mSheetDialogView.course_comment_seek_bar.progress = 0</span><br></pre></td></tr></table></figure><p>使用后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//形成了链式调用</span><br><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line"></span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多层级判空问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mSectionMetaData.questionnaire.userProject != null) &#123;</span><br><span class="line">    renderAnalysis();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123;</span><br><span class="line">    fetchQuestionData();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt; 使用了apply后可以变为链式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line"></span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //questionnaire不为空的时候操作questionnaire</span><br><span class="line"></span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //section不为空的时候操作section</span><br><span class="line"></span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"></span><br><span class="line">    //sectionArticle不为空的时候操作sectionArticle</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><ul><li>also函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.also&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>also函数的inline+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">//可以看到这个函数是从kotlin1.1开始才有的</span><br><span class="line">public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125;</span><br></pre></td></tr></table></figure><ul><li>also函数的inline结构分析</li></ul><p>also函数的结构实际上和let很像，唯一的区别是返回值不一样，let是以闭包的形式返回的，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值，而also函数则返回传入对象本身。这个和apply一样。</p><ul><li>also函数的kotlin和java转化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = &quot;testLet&quot;.also &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line">//结果：7/testLet</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class AlsoFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var2 = &quot;testLet&quot;;</span><br><span class="line">      int var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准函数总结"><a href="#标准函数总结" class="headerlink" title="标准函数总结"></a>标准函数总结</h3><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">定义inline结构</th><th style="text-align:left">函数体内代指对象</th><th style="text-align:left">返回值</th><th style="text-align:left">是否是扩展函数</th><th style="text-align:left">使用场景</th></tr></thead><tbody><tr><td style="text-align:left">let</td><td style="text-align:left">fun T.let(block: (T) -&gt; R): R = block(this)<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">it</td><td style="text-align:left">闭包返回</td><td style="text-align:left">是</td><td style="text-align:left">适用于处理不为null的操作场景</td></tr><tr><td style="text-align:left">with</td><td style="text-align:left">fun with(receiver: T, block: T.() -&gt; R): R = receiver.block()</td><td style="text-align:left">this</td><td style="text-align:left">返回闭包</td><td style="text-align:left">否</td><td style="text-align:left">适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</td></tr><tr><td style="text-align:left">run</td><td style="text-align:left">fun T.run(block: T.() -&gt; R): R = block()<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">this</td><td style="text-align:left">闭包返回</td><td style="text-align:left">是</td><td style="text-align:left">适用于let,with函数任何场景。</td></tr><tr><td style="text-align:left">apply</td><td style="text-align:left">fun T.apply(block: T.() -&gt; Unit): T { block(); return this }<span class="Apple-tab-span" style="white-space:pre"></span></td><td style="text-align:left">this</td><td style="text-align:left">返回this</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">also</td><td style="text-align:left">fun T.also(block: (T) -&gt; Unit): T { block(this); return this }</td><td style="text-align:left">it</td><td style="text-align:left">返回this</td><td style="text-align:left">是</td><td style="text-align:left">适用于let函数的任何场景，一般可用于多个扩展函数链式调用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;h3 id=&quot;？操作符&quot;&gt;&lt;a href=&quot;#？操作符&quot; class=&quot;headerlink&quot; title=&quot;？操作符&quot;&gt;&lt;/a&gt;？操作符&lt;/h3&gt;&lt;p&gt;表示这个对象可能为空&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//在变量后面加？，代表这个变量可以为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var name: String? = &amp;quot;zhangsan&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//如果str不能转为Int类型，则返回null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fun parseInt(str: String): Int?&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 如果b非空，就返回b.length，否则返回null，这个表达式的类型是Int？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b?.length&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>常见算法（二）</title>
    <link href="http://yoursite.com/2018/12/21/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/21/常见算法（二）/</id>
    <published>2018-12-21T07:45:16.298Z</published>
    <updated>2018-12-24T03:54:50.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。</p><a id="more"></a><h3 id="单向链表转置"><a href="#单向链表转置" class="headerlink" title="单向链表转置"></a>单向链表转置</h3><p>这个问题其实是很常见的一个算法问题，但是如果没弄清楚就会被它给搞晕了，从晕到不晕的过程就是你理解该算法的过程。</p><blockquote><p>算法还是需要理解它，才能真正的去掌握它</p></blockquote><p>下图是一个单向链表转置的初始状态和终止状态。<br><img src="https://img-blog.csdn.net/20170419120811149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHloMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>转置后：<br><img src="https://img-blog.csdn.net/20170419120851823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHloMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>首先要知道链表的数据结构是怎么样的，链表首先有自己的值（value），其次它有一个指针指向了下个结点，我们用代码来表示是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    public int value;</span><br><span class="line">    </span><br><span class="line">    public Node next;</span><br><span class="line">    </span><br><span class="line">    public Node(int data)&#123;</span><br><span class="line">        this.value = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以很清楚的看到链表的特点，他是区别于数组的一种数据结构。</p><h4 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h4><p>在数组中，是通过==索引==来访问元素的，很多算法都是利用索引来操作的，所以数组这种数据结构可以快速的查询到数据。<br>链表的优势则是删除/插入数据，因为数组是固定长度的，所以增删都会改变数组的所有元素（下标变化了），而链表是可以动态改变大小的，他只会影响左右相邻的两个结点。另外链表在内存中的存储不是连续的。</p><h4 id="算法分析过程"><a href="#算法分析过程" class="headerlink" title="算法分析过程"></a>算法分析过程</h4><p>先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Node reverseList(Node head)&#123;</span><br><span class="line">    //临时变量</span><br><span class="line">    Node pre = null</span><br><span class="line">    Node next = null</span><br><span class="line">    </span><br><span class="line">    while(head != null)&#123;</span><br><span class="line">        next = head.next // 1</span><br><span class="line">        head.next = pre // 2</span><br><span class="line">        </span><br><span class="line">        pre = head  //3</span><br><span class="line">        head = next. //4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析下具体过程，其实主要是while循环中四句话。我们逐一来分析，第一轮过程：</p><p>首先初始状态：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyhomubpa9j30pq059glm.jpg" alt></p><p>执行完1：next = head.next后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhoo4er7vj30nz06p74d.jpg" alt></p><p>执行完2: head.next = pre后：（pre此时是null）<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyhoq2nt8hj30po079aa7.jpg" alt></p><p>执行完3: pre = head后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhor37xb8j30pw07yt8w.jpg" alt></p><p>执行完4: head = next后：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyhosor3w2j30qa07h74g.jpg" alt></p><p>第一轮结束，我们看到头结点head在2的位置了，递归操作，我们继续分析第二轮：</p><p>执行完1：next = head.next后：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyhovdga7nj30q807tt90.jpg" alt></p><p>执行完2: head.next = pre后：（pre此时是指向了1）<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyhowpw07sj30p106zq37.jpg" alt><br>这一步很巧妙将1和2转置了。<br>执行完3: pre = head后：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyhoykh8iqj30op06taab.jpg" alt></p><p>执行完4: head = next后：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyhozd97bpj30p206f74j.jpg" alt></p><p>如此，经过5次循环就能将这个单向链表成功转置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;面试过程中，特别是一些大公司，对于程序员的要求越来越高，你必须会一些和本职工作没什么关系的技能，这样才能使你stand out，面试其实是需要精心准备的，也许你在面试完后，这些东西你都用不到，但是为了那个offer你还是要去准备，这些可以概括为“面试造航母，工作拧螺丝”，另一方面，这些知识其实对我们自身来说是有用的（有用和无用其实不好定义，而且看似无用的东西往往它的生命周期会更长），它能帮我们开阔眼界，系统搭建我们的知识架构，让我们掌握的东西能串起来，而且我们在未来碰到问题的时候可以多一种选择。算法就是这样一个东西。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 (一)</title>
    <link href="http://yoursite.com/2018/12/16/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/16/常见排序算法（一）/</id>
    <published>2018-12-16T06:39:02.868Z</published>
    <updated>2019-02-27T15:13:02.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。</p><a id="more"></a><h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>原理：分治，前后两个指针交替前进，然后递归，主要步骤是：</p><ol><li>取一个数作为基数（一般就选第一个）</li><li>将数组中比这个数大的放在它的右边，比基数小的放在它左边</li><li>递归两遍的数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] a,int low,int high)&#123;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = high;</span><br><span class="line">    int temp = a[low] //比较的数</span><br><span class="line">    </span><br><span class="line">    while(i &lt; j)&#123;</span><br><span class="line">        while(i&lt;j &amp;&amp; a[j] &gt;= temp)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; j) &#123;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(i &lt; j &amp;&amp; a[j] &lt; temp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a[i] = temp;</span><br><span class="line">    quickSort(a,low,i-1);</span><br><span class="line">    quickSort(a,i+1;high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>原理：堆其实是一个完全二叉树，它的特征是当前结点下标为i，那么它的根结点为i/2，它的左子结点为：2i+1；右子结点为：2i+2。<br>堆排序要经过两步：</p><ol><li>将树变为稳定的二叉树（大堆模式），即每个根结点都要大于等于它的子结点。</li><li>将根结点和最后一个结点互换，递归以上操作</li></ol><p>手写代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一步变为稳定树</span><br><span class="line">public void adjustHeap(int[] ,int parent,int length)&#123;</span><br><span class="line">    int temp = a[parent];</span><br><span class="line">    int leftChildIndex = 2*parent + 1;</span><br><span class="line">    </span><br><span class="line">    while(leftChildIndex &lt; length)&#123;</span><br><span class="line">        if (a[leftChildeIndex] &lt; a[leftChildIndex + 1]&#123;</span><br><span class="line">            leftChildIndxe = leftChildIndex + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (temp &gt; a[leftChildIndex])&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        a[parent] = a[leftChildIndex];</span><br><span class="line">        </span><br><span class="line">        parent = leftChildIndex;</span><br><span class="line">        leftChildIndex = 2*leftChildIndex + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a[parent] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>原理：内存循环会不停比较两个数的大小，进行换位，完成一轮后，最大的数会排在最后。（注意和选择排序的区别，选择排序是内层循环和外层循环比较）<br>算法时间复杂度：O（n2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] a)&#123;</span><br><span class="line"></span><br><span class="line">    int len = a.length;</span><br><span class="line">    for(int i =0 ;i&lt;len;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;len - i -1;j++)&#123;//每一轮最后一个数不用比较</span><br><span class="line">        // 内存循环比较相邻两个数</span><br><span class="line">            if(a[j] &gt; a[j+1])&#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>原理：遍历数组中最小值，放在最左边，再从剩下数组中找最小值，直到排序完成（在要排序的一组数中，选出最小的一个数与第一个位置的数交换位置）<br>算法时间复杂度：O（n2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void selectSort(int[] a)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">        for(int j = i+1; j&lt; len;j++)&#123;</span><br><span class="line">        // 和外层第一个元素比较</span><br><span class="line">            if(a[j] &gt; a[i])&#123;</span><br><span class="line">                int temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于算法知识的极度缺乏，但是做程序猿，算法其实是进阶绕不过去的坎，因此硬着头皮从各种排序算法学起了，感觉有些收获，而且当你理解了算法的原理后，能帮你去分析复杂的数据结构，也能帮你去手写代码。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法，Android" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%EF%BC%8CAndroid/"/>
    
  </entry>
  
  <entry>
    <title>GDG Shenzhen 2018</title>
    <link href="http://yoursite.com/2018/12/09/GDG%20Shenzhen%202018/"/>
    <id>http://yoursite.com/2018/12/09/GDG Shenzhen 2018/</id>
    <published>2018-12-09T07:27:54.609Z</published>
    <updated>2018-12-09T08:30:33.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于GDG"><a href="#关于GDG" class="headerlink" title="关于GDG"></a>关于GDG</h2><p>GDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。<br><img src="https://chinagdg.org/wp-content/uploads/2015/07/2015_ChinaSummit-1024x382.jpg" alt="全国组织"></p><p><a href="https://chinagdg.org/" target="_blank" rel="noopener">GDG官网</a></p><p>昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。</p><a id="more"></a><h2 id="活动打卡"><a href="#活动打卡" class="headerlink" title="活动打卡"></a>活动打卡</h2><p>活动地址，关键离我住的地方很近。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fy0jnaidt2j30u0140qv6.jpg" alt="活动地址"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy0jpf392lj30u0140kjl.jpg" alt="活动标题"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy0jqeujphj31400u04qq.jpg" alt="现场"></p><p><a href="https://gallery.vphotos.cn/vphotosgallery/index.html?vphotowechatid=1EF7FAB4CF1DE5D92DAC7EE20115154C&amp;gallery_source_code=0&amp;from=groupmessage&amp;isappinstalled=0&amp;gallery_source_code=0#/" target="_blank" rel="noopener">更多照片–现场图片直播</a></p><h2 id="心得感想"><a href="#心得感想" class="headerlink" title="心得感想"></a>心得感想</h2><p>今年的活动收获还比较多，GDE（Google developer expert）将了很多AI，TensorFlow，Google的一些东西，包括很具体的Flutter，Kotlin以及Android的优化等等东西。干活还是比较多的。作为一个Android开发者，对于Android的未来其实一直有关注，blog里面也写了很多，这里就写一些经过这个活动后的感受吧，Google其实已经在开发Android的替代系统了，而且kotlin也迭代到了V1.3版本，这个时候又来了个Flutter（跨平台开发），感觉这些项目都是各自为政，其实看过《硅谷之谜》这本书后也能理解，大公司其实内部为了保持创新活力会鼓励团队或者部门去折腾，类似公司里面的成立小的创业团队，每个团队负责一个项目，如果做好了就会被公司收购，做的不好就被关掉（垃圾Google关掉了多少优秀的服务，看看隔壁百度。。。）。对于我们这些开发者而言，其实还是要靠自己的兴趣去选择，感觉李锐博士说的很好：选择职业要看自己的兴趣，不要太功利，AI很火大家都去AI，市场饱和后还是靠大家的实力，如果已自己的兴趣为出发点，赚钱是一个自然的过程。保持好奇心，紧跟前沿技术，不断去学习。然后，我自己感觉，flutter这个东西还是需要去认真对待的，特别是感受到他的hot reload的特性后，感觉非常爽，还有kotlin也是需要快速去掌握的，目前个人掌握的并不全面。另外，需要移动端结合AI来做些东西，可能会有不一样的发现。下面列出个人比较关注和感兴趣的点：</p><ol><li>数据安全，在中国还有很多工作要做</li><li>隐藏的歧视，这里其实指的是，在技术发展飞速的今天，很多年轻人已经享受到了技术带来的好处，但是还有些人是没有得到实惠的，这些人在这个时代是弱势群体，但是他们经常会被忽略。</li><li>Flutter的优势在众多跨平台框架中是很out standing的</li><li>Android WorkManager某些情况下是可以替代Service的，比如在那些不用立即在后台执行操作的场景下</li><li>Kotlin的协程概念。这个我比较感兴趣，这个特性是V1.3刚发布的，这个是kotlin中的异步概念的实现，很像Rxjava的链式调用，需要去学习一下，另外kotlin好像也能有在大数据里面。</li><li>供web和移动端调用的轻量级TensorFlow，包括tensorflwo.js tensorflow.lite。</li><li>中国的AI发展很快，美帝国主义可能要制裁这些公司了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于GDG&quot;&gt;&lt;a href=&quot;#关于GDG&quot; class=&quot;headerlink&quot; title=&quot;关于GDG&quot;&gt;&lt;/a&gt;关于GDG&lt;/h2&gt;&lt;p&gt;GDG是Google Developer Group的缩写，也就是Google开发者组织，一般是Google信仰者线下组织，目前全球各地很多城市都有GDG组织，包括中国。&lt;br&gt;&lt;img src=&quot;https://chinagdg.org/wp-content/uploads/2015/07/2015_ChinaSummit-1024x382.jpg&quot; alt=&quot;全国组织&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chinagdg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDG官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天（2018/12/08），深圳GDG组织了2018年的线下活动，我在9月份就申请了门票，10月份就通过了。我本身就是Android开发者，也觉得Google大法好，GDG正好就是这种开发者线下交流平台。下面来贴些照片以及直播的图文链接，包括我的心得感受，记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="GDG" scheme="http://yoursite.com/tags/GDG/"/>
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>悖论之共有知识和公共知识</title>
    <link href="http://yoursite.com/2018/12/07/%E6%82%96%E8%AE%BA%E4%B9%8B%E5%85%B1%E6%9C%89%E7%9F%A5%E8%AF%86%E5%92%8C%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/07/悖论之共有知识和公共知识/</id>
    <published>2018-12-07T09:24:04.140Z</published>
    <updated>2018-12-07T10:20:04.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩：</p><ol><li>大家不能讨论别人眼睛的颜色。</li><li>如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。</li></ol><p>有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，根据规则，其实大家都知道在村里有红/蓝两种眼睛的人，但是大家都不知道自己眼睛是什么颜色的。直到来了外乡人说了一句“你们中有人跟我一样是蓝色眼睛的人”，我们来分析下：假设村里只有1个蓝眼睛的人，那么这个人只知道村里都是红眼睛的，那么那个蓝眼睛就是自己了。那么再假设村里有2个蓝色眼睛的人，那么这两个人都知道对方是蓝眼睛的，但是第一天对方没有去自杀，那么理由只有一个村里蓝眼睛的人不止一个，也就是自己也是蓝眼睛，那么这两个人都会第二天自杀；依次类推，有3个蓝眼睛的人，如果第二天没人死，那么就是村里不止两个蓝眼睛的人，也就是自己就是蓝眼睛。。。。那么，红眼睛的人会死吗？答案是不会，因为红眼睛的人不知道自己眼睛的颜色是什么？可能红色，也可能黑色对不对</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>我们来看下，其实外乡人什么信息都没增加，为什么就发生了这种事情呢？这就要从知识分类来说了，知识分两类：共有知识，公共知识。<br>共有知识：大家都知道的知识<br>公共知识：大家都知道大家知道的知识</p><p>那么，从上面例子可以看出，大家原来都知道村里有红蓝眼睛的人，这就是共有知道，但是当外乡人把这件事情说出来共有知识就变成了公共知识，大家就都知道大家知道这件事情了。其实现实生活中有很多这样的例子，大家可以去发现，只有去讨论，将自己心里知道的东西说出来，才能变成公共知识，发挥出效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;继续来学习李老师的课程，李老师有一期讲的是共有知识和公共知识的问题，原来没听过这两个概念，然后通过李老师举的例子发现，这个现象真的蛮有意思，就想记录下来。其实看的时间已经很久了，但是例子很生动所以就根据记忆和理解来写这篇blog了。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;说是有一个村子，里面有100个村民，然后有95个人是红色眼睛的，还有5个是蓝色眼睛的。然后，村子里面有这么些规矩：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大家不能讨论别人眼睛的颜色。&lt;/li&gt;
&lt;li&gt;如果谁知道了自己眼睛的颜色，那么他就得第二天去村口自杀。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有一天，来了一个外乡人，大家热情招待了他，在外乡人离开这里的时候，对村民们说了一句话：“我第一次发现尽然有跟我眼睛颜色一样的人”，然后就离开了。到第五天早上发现村里的蓝眼睛都死在了广场上，那么这是为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="心理学，悖论" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%8C%E6%82%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>悖论系列之分金问题</title>
    <link href="http://yoursite.com/2018/12/06/%E6%82%96%E8%AE%BA%E4%B9%8B%E4%B8%89%E5%A7%AC%E5%88%86%E9%87%91/"/>
    <id>http://yoursite.com/2018/12/06/悖论之三姬分金/</id>
    <published>2018-12-06T12:10:53.117Z</published>
    <updated>2018-12-06T12:39:30.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>有一期的问题是：</strong><br>从前有一个国王，一天他的三位妃子想玩一个游戏，这个游戏规则是这样的：</p><ol><li>有100金币供三个人A B C分</li><li>每个人按顺序发言，即提议分配这100金的方案</li><li>如果这个人的发言超过半数的人同意，则方案达成，如果没有，提议的人则要被处死。</li><li>每个人都很聪明而且人性本恶，每个人都想尽量多的获得更多的金币，如果还能杀死对方，那么则更好。<br>问题是：最终这个金币会怎么分？</li></ol><hr><p>想一想。。。。。。。。。。。。。。。。。<br>初想下：A应该分的最少吧，因为最先提</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，我们来假设A已经死了，只剩下B和C来分这个金币会出现什么情况，这个时候其实很简单了，按照第四条原则：B不管提出什么方案，C都不同意，那么C就能分到100金币，并且杀死了A和B。那么，<strong>其实在A死的情况下B也一定死</strong>；所以，B要怎么做才能不死呢，答案只有一个：A不能死。这个情况A是知道的，B也知道。<br>那么就是说：无论A提出什么样的方案，B都会同意，这个时候分配方案是A：100/B：0/C：0，那么也有答案是A应该给一块金币B，那么B更加会同意A，如果A死，B一定死而且一毛钱拿不到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们引申下这个问题，如果来了四个人来分金币，会怎么样呢：M A B C？依然遵循上面的分析过程，M会拿到最多的金币，但是A就是一毛拿不到了，B和C反而会各拿到1个金币（大家想想是不是）：如果M死了，B和C都会一毛拿不到，这个时候M如果给B和C一人一个金币，那么B和C必然赞同，而A为了自己利益最大化，当然是想把M干掉，但是BC同意的话A的意见也没什么作用了。</p><p>这个问题很像现在的社会，国家也一样，老大永远提防老二，而老二永远想干掉老大，老大为了压制老二还会去讨好老三老四组成联盟。这个问题其实蛮有趣的，以前没想过这个问题，现在慢慢发现，很多问题其实都来源于人性。这个问题就到此，后面会有其它悖论的题目再分析吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直在YouTube上看李永乐老师的视频，学到了很多东西，在这里对老师表示感谢！然后，李老师有个系列讲悖论的，看后感觉很有意思，所以想记录下来，加上自己的理解和感想供以后看看。&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="悖论" scheme="http://yoursite.com/tags/%E6%82%96%E8%AE%BA/"/>
    
      <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Flutter V1.0.0发布</title>
    <link href="http://yoursite.com/2018/12/06/Flutter1.0%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2018/12/06/Flutter1.0发布/</id>
    <published>2018-12-06T06:26:33.488Z</published>
    <updated>2018-12-06T07:01:51.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flutter是什么"><a href="#flutter是什么" class="headerlink" title="flutter是什么"></a>flutter是什么</h2><p>Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编写。2018/12/04Google正式发布了它的V1.0.0稳定版本，也就是说移动端的开发有可能会发生革命性的变化。本人第二天看了youtube上的发布会，然后试玩了一下发布会上说的Google三个员工三个月为这场发布会写的Demo app：The history of everything。个人感觉：完全感觉不出是非原生的，动画，过渡非常流畅，而且我还用的是老的Nexus 6P来运行的，这种表现打破了我对跨平台开发的认知，让我相当震撼，也许原生开发真的要被取代了，喊了N多遍的狼来了看来也只是时间问题了。</p><h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>当变化来的时候，也许最好的方式是去拥抱变化，而不是墨守成规，扛着原生开发的大旗拉上kotlin小弟一起为Google的保守势力买单。技术现在发展月来越快，技术更新周期越来越短，这也对开发者提出了更高的要求，你需要不断的学习新东西，去适应这个快速发展的世界；但是，每个人的精力都是有限的，怎样在这个信息爆炸的时代学习到保命技能做到以不变应万变，这就需要你的眼光，高度以及眼界了，形而上的东西看着像套路但是归根结底被前人总结的其实就是这些东西，如果你具有了这些“能力”，你就会敏锐的知道在这些快速发展的技术中，哪些是革命性的？哪些是过渡的？集中精力去学习革命性的技术会让你在以后有先发优势，而如果你选择错误，则只能看着刚学的内容马上就out了。</p><p>个人总结的几点建议：</p><ol><li>不盲目跟风口。如果自己专业领域就是风口，那就是最好，这里说的是不同领域为了去风口而盲目转型，最少要有关联性，而且是你喜欢的。</li><li>跟随大公司。这里的大公司指的是掌握核心科技的公司，站在业界前沿的公司如Google，他们发布的技术有可能就是革命性的。</li><li>对新技术保持永远的好奇心。还是刚说的要去拥抱变化，而不是抵触。</li><li>抓住机会，去更大的平台。大平台的优势不用说了。在技术变革期，大平台是最敏感的。</li><li>在技术外，丰富自己的知识库，多看书，多阅历，多和优秀的人沟通。</li></ol><h2 id="flutter的特性"><a href="#flutter的特性" class="headerlink" title="flutter的特性"></a>flutter的特性</h2><p>这里就贴一些文章，看到的都是各种赞不绝口，希望我也能把它收进武器库。<br><a href="https://mp.weixin.qq.com/s/lYisub0Zg9Yz6o9KsYopvA" target="_blank" rel="noopener">Google 要用 Flutter 一统移动、桌面开发江湖？</a></p><p><a href="https://mp.weixin.qq.com/s/hCIN42OMmmc6HkOveegwWQ" target="_blank" rel="noopener">Flutter 1.0 正式版: Google 的便携 UI 工具包</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flutter是什么&quot;&gt;&lt;a href=&quot;#flutter是什么&quot; class=&quot;headerlink&quot; title=&quot;flutter是什么&quot;&gt;&lt;/a&gt;flutter是什么&lt;/h2&gt;&lt;p&gt;Flutter是Google开发出来的一套跨平台开源框架，使用Dart语言编
      
    
    </summary>
    
      <category term="文章" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
</feed>
